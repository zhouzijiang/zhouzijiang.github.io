<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>周子江</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="周子江">
<meta property="og:url" content="https://zhouzijiang.github.io/index.html">
<meta property="og:site_name" content="周子江">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="周子江">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="周子江" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">周子江</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhouzijiang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-gdb-1-启动和退出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/gdb-1-启动和退出/" class="article-date">
  <time datetime="2016-04-23T05:01:29.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/gdb-1-启动和退出/">gdb(1):启动和退出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The most usual way to start gdb is with one argument, specifying an executable program:<br>gdb program<br>You can also start with both an executable program and a core file specified:<br>gdb program core<br>You can, instead, specify a process ID as a second argument, if you want to debug a running process:<br>gdb program 1234<br>would attach gdb to process 1234.<br>You can optionally have gdb pass any arguments after the executable file to the inferior using —args. This option stops option processing.<br>gdb —args gcc -O2 -c foo.c</p>
<p>To exit gdb, use the quit command (abbreviated q), or type an end-of-file character (usually Ctrl-d). If you do not supply expression, gdb will terminate normally; otherwise it will terminate using the result of expression as the error code.</p>
<p>An interrupt (often Ctrl-c) does not exit from gdb, but rather terminates the action of any gdb command that is in progress and returns to gdb command level. It is safe to type the interrupt character at any time because gdb does not allow it to take effect until a time when it is safe.</p>
<p>If you need to execute occasional shell commands during your debugging session, there is no need to leave or suspend gdb; you can just use the shell command.<br>shell command-string Invoke a standard shell to execute command-string.<br>The utility make is often needed in development environments. You do not have to use the shell command for this purpose in gdb:<br>make make-args Execute the make program with the specified arguments. This is equivalent to ‘shell make make-args’.</p>
<p>Command Completion<br>you might want to set a breakpoint on a subroutine whose name begins with ‘make<em>’, but when you type b<br>make_TAB gdb just sounds the bell. Typing TAB again displays all the function names in<br>your program that begin with those characters, for example:<br>(gdb) b make</em> TAB<br>gdb sounds bell; press TAB again, to see:<br>make_a_section_from_file make_environ<br>make_abs_section make_function_type</p>
<p>gcc, the gnu C/C++ compiler, supports ‘-g’ with or without ‘-O’, making it possible<br>to debug optimized code. We recommend that you always use ‘-g’ whenever you compile<br>a program. You may think your program is correct, but there is no sense in pushing your<br>luck. </p>
<p>Use the run command to start your program under gdb. The arguments to your program can be specified by the arguments of the run command.<br>The ‘start’ command does the equivalent of setting a temporary breakpoint<br>at the beginning of the main procedure and then invoking the ‘run’ command.</p>
<p>attach process-id This command attaches to a running process—one that was started outside<br>gdb.The first thing gdb does after arranging to debug the specified process is to stop it.</p>
<p>When you have finished debugging the attached process, you can use the detach<br>command to release it from gdb control. Detaching the process continues its<br>execution.</p>
<p>On certain operating systems, gdb is able to save a snapshot of a program’s state, called<br>a checkpoint, and come back to it later.</p>
<p>Thus, if you’re stepping thru a program and you think you’re getting close to the point<br>where things go wrong, you can save a checkpoint. Then, if you accidentally go too far and<br>miss the critical statement, instead of having to restart your program from the beginning,<br>you can just go back to the checkpoint and start again from there.<br>This can be especially useful if it takes a lot of time or steps to reach the point where<br>you think the bug occurs.<br>checkpoint<br>Save a snapshot of the debugged program’s current execution state. The<br>checkpoint command takes no arguments, but each checkpoint is assigned<br>a small integer id, similar to a breakpoint id.<br>info checkpoints<br>restart checkpoint-id<br>delete checkpoint checkpoint-id</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/04/23/gdb-1-启动和退出/" data-id="cinvexirz0010tw3acjbies2m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gdb/">gdb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-最让人头疼的歧义most-vexing-parse" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/29/最让人头疼的歧义most-vexing-parse/" class="article-date">
  <time datetime="2016-03-29T08:53:09.000Z" itemprop="datePublished">2016-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/最让人头疼的歧义most-vexing-parse/">最让人头疼的歧义most vexing parse</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The most vexing parse is a specific form of syntactic ambiguity resolution in the C++ programming language.<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Timer();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  TimeKeeper(<span class="keyword">const</span> Timer&amp; t);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TimeKeeper time_keeper(Timer());</span><br><span class="line">  <span class="function"><span class="keyword">return</span> time_keeper.<span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The line <code>TimeKeeper time_keeper(Timer());</code> is ambiguous, since it could be interpreted either as</p>
<ol>
<li>a variable definition for variable time_keeper of class TimeKeeper, initialized with an anonymous instance of class Timer or</li>
<li>a function declaration for a function time_keeper which returns an object of type TimeKeeper and has a single (unnamed) parameter which is a function returning type Timer (and taking no input).</li>
</ol>
<p>Most programmers expect the first, but the C++ standard requires it to be interpreted as the second. One way to force the compiler to consider this as a variable definition is to add an extra pair of parentheses:<code>TimeKeeper time_keeper( (Timer()) );</code></p>
<p>Using the new uniform initialization syntax introduced in C++11 solves this issue (and many more headaches related to initialization styles in C++). The problematic code is then unambiguous when braces are used:<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">TimeKeeper</span> <span class="tag">time_keeper</span>&#123;<span class="tag">Timer</span>&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/29/最让人头疼的歧义most-vexing-parse/" data-id="cinvexiqf0006tw3aedztflt5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-不可复制noncopyable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/29/不可复制noncopyable/" class="article-date">
  <time datetime="2016-03-29T03:06:54.000Z" itemprop="datePublished">2016-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/不可复制noncopyable/">不可复制noncopyable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        noncopyable() &#123;&#125;</span><br><span class="line">        ~noncopyable() &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        noncopyable(<span class="keyword">const</span> noncopyable &amp;orig);</span><br><span class="line">        noncopyable &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">private</span> <span class="title">noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;rhs) &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">private</span> <span class="title">noncopyable</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    A a1,a2;</span><br><span class="line">    B b1,b2;</span><br><span class="line"></span><br><span class="line">    a1 = a2;  <span class="comment">// ok</span></span><br><span class="line">    b1 = b2;  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，构造函数和析构函数设置为protected，这样子类能够调用，但是却不能被外部调用。其次，拷贝构造函数和赋值运算符设置为私有的，并且只声明不实现。对于类A而言，它自己又实现了赋值运算符，并且在实现中它没有去调用父类的赋值运算符，所以是ok的。对于类B而言，它自己没有实现赋值运算符，那么编译器会自动合成一个，合成的赋值运算符会去调用父类的私有的赋值运算符从而导致编译失败。如果没有a1=a2这个语句，即没有需要赋值运算符的地方，则编译器不会为类A自动合成赋值运算符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/29/不可复制noncopyable/" data-id="cinvexiql000ctw3adn372mus" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程同步之条件变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/26/线程同步之条件变量/" class="article-date">
  <time datetime="2016-03-26T10:34:03.000Z" itemprop="datePublished">2016-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/26/线程同步之条件变量/">线程同步之条件变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The common use of condition vars is something like:<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">thread 1<span class="value">:</span><br><span class="line">    <span class="function">pthread_mutex_lock</span>(&amp;mutex);</span></span><br><span class="line">    while (!condition)</span><br><span class="line">        <span class="function">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">    <span class="comment">/* do something that requires holding the mutex and condition is true */</span></span><br><span class="line">    <span class="function">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">thread2<span class="value">:</span><br><span class="line">    <span class="function">pthread_mutex_lock</span>(&amp;mutex);</span></span><br><span class="line">    <span class="comment">/* do something that might make condition true */</span></span><br><span class="line">    <span class="function">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">    <span class="function">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure></p>
<h2 id="1-_pthread_cond_wait">1. pthread_cond_wait</h2><p>pthread_cond_wait到底做了什么事情呢？<br>(1)释放mutex<br>(2)把当前线程加入到此条件变量的等待线程队列，然后睡眠<br>(3)当其他线程调用pthread_cond_signal或者pthread_cond_broadcast后，调用pthread_cond_wait的线程从睡眠状态醒来，然后试图重新获取mutex，如果此时能够获取mutex则从pthread_cond_wait返回，如果不能获取mutex则进入阻塞状态，等待其他线程释放mutex</p>
<p>其中，系统保证第一步和第二步是原子操作。为什么是原子操作呢？因为如果不是原子操作的话，会存在竞争条件(race condition)。当前线程释放mutex后，其他线程可以获得该mutex并调用pthread_cond_signal，然后当前线程再执行第二步，则会一直处于睡眠状态(直到其他线程再次调用pthread_cond_signal)，即错过了一次条件变量变为真的情况。</p>
<h2 id="2-_pthread_cond_signal">2. pthread_cond_signal</h2><p>pthread_cond_signal does not unlock the mutex (it can’t as it has no reference to the mutex, so how could it know what to unlock?) In fact, the signal need not have any connection to the mutex; the signalling thread does not need to hold the mutex, though for most algorithms based on condition variables it will.</p>
<h2 id="3-_线程1和线程2的并发执行情况">3. 线程1和线程2的并发执行情况</h2><p>所以，线程1和线程2的并发执行情况是这样的:<br>(1)线程1获得mutex<br>(2)线程1测试条件为满足，则调用pthread_cond_wait，导致其释放mutex并把自己加入到条件变量的等待线程队列，然后睡眠<br>(3)线程2获得mutex<br>(4)线程2将条件设置为true，调用pthread|_cond_signal唤醒线程1，线程1被唤醒后，试图重新获取mutex，因为此时mutex被线程2持有，所以线程1被阻塞在获取mutex的操作上。<br>(5)线程2释放mutex<br>(6)线程1获得mutex，并从pthread_cond_wait返回。</p>
<h2 id="4-_pthread_cond_signal和pthread_mutex_unlock的顺序">4. pthread_cond_signal和pthread_mutex_unlock的顺序</h2><p>我们看到线程2是先调用pthread_cond_signal，再释放mutex的。那么它们的执行顺序能反过来吗？答案是不能，因为反过来的话存在竞争条件。线程2在释放mutex后，线程1获取mutex，进行条件测试发现为false，于是线程1准备调用pthread_cond_wait。但就在此时，线程2执行pthread_cond_signal。之后，线程1再调用pthread_cond_wait导致其阻塞。即错过了一次条件变量变为真的情况。</p>
<h2 id="5-_后记">5. 后记</h2><p>A spin lock is like a mutex, except that instead of blocking a process by <code>sleeping</code>, the process is blocked by <code>busy-waiting</code> (spinning) until the lock can be acquired.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/26/线程同步之条件变量/" data-id="cinvexiqb0004tw3aa7jd50uj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记27-Pointer-to-Class-Member" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/c-primer笔记27-Pointer-to-Class-Member/" class="article-date">
  <time datetime="2016-03-21T06:10:05.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/c-primer笔记27-Pointer-to-Class-Member/">c++ primer笔记27: Pointer to Class Member</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Pointer_to_Class_Member">1. Pointer to Class Member</h2><p>A pointer to member embodies the type of the class as well as the type of the member. Pointers to member apply only to non static members of a class.  static class members are not part of any object, so no special syntax is needed to point to a  static member. Pointers to static members are ordinary pointers.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="keyword">size_t</span>ype index;</span><br><span class="line">        <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(index ht, index wd)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">        index cursor;</span><br><span class="line">        index height, width;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">## 2. Defining a Pointer to Data Member</span></span><br><span class="line"><span class="built_in">string</span> Screen::*ps_Screen = &amp;Screen::contents;</span><br></pre></td></tr></table></figure></p>
<p>普通指针使用*来标示，而指向类的成员函数的指针使用ClassName::*标示。需要注意的是，指向类的数据成员的指针并非指针，因为它既不包含地址，行为也不像指针。与常规指针不同，一个指向成员的指针并不指向一个具体的内存位置，它指向的是一个类的特定成员，而不是指向一个特定对象里的特定成员。通常最清晰的做法是将指向数据成员的指针看作 为一个偏移量 。 C++标准并没有说该如何实现指向成员的指针，大多数编译器都将指向数据成员的指针实现为一个整数，其中包含被指向成员的偏移量。另外加上1（加1是为了让0值可以表示一个空的数据成员指针）。 这个偏移量告诉你，一个特定成员的位置距离对象的起点有多少个字节。一个类成员的偏移量在任何对象中都是相同的。 为啥偏移量会加1呢？这主要用来区分“没有指向任何数据成员的指针”和“指向第一个数据成员的指针”这两种情况。考虑下面这样的例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d::x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( p1 == p2 )&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;” p1 &amp; p2 contain the same value.”;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;”they must address the same member!”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-_Defining_a_Pointer_to_Member_Function">3. Defining a Pointer to Member Function</h2><p>A pointer to a member function must match the type of the function to which it points, in three ways:</p>
<ul>
<li>The type and number of the function parameters, including whether the member is  const.</li>
<li>The return type.</li>
<li>The class type of which it is a member <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> (Screen::*pmf)() <span class="keyword">const</span> = &amp;Screen::get;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (Screen::*pmf2)(Screen::index, Screen::index) <span class="keyword">const</span>;</span><br><span class="line">pmf2 = &amp;Screen::get;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">char</span> (Screen::*Action)(Screen::index, Screen::index) <span class="keyword">const</span>;</span><br><span class="line">Action get = &amp;Screen::get;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-_Using_a_Pointer_to_Member_Function">4. Using a Pointer to Member Function</h2><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line">char <span class="params">(Screen::*pmf)</span><span class="params">()</span> const = &amp;Screen::get;</span><br><span class="line">Screen myScreen;</span><br><span class="line">char c1 = myScreen.get<span class="params">()</span>; <span class="comment">// call get on myScreen</span></span><br><span class="line">char c2 = <span class="params">(myScreen.*pmf)</span><span class="params">()</span>; <span class="comment">// equivalent call to get</span></span><br><span class="line">Screen <span class="built_in">*</span>pScreen = &amp;myScreen;</span><br><span class="line">c1 = pScreen-&gt;get<span class="params">()</span>; <span class="comment">// call get on object to which pScreen points</span></span><br><span class="line">c2 = <span class="params">(pScreen-&gt;*pmf)</span><span class="params">()</span>; <span class="comment">// equivalent call to get</span></span><br></pre></td></tr></table></figure>
<h2 id="5-_Using_a_Pointer_to_Data_Member">5. Using a Pointer to Data Member</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="constant">Screen:</span><span class="symbol">:index</span> <span class="constant">Screen:</span><span class="symbol">:*pindex</span> = &amp;<span class="constant">Screen:</span><span class="symbol">:width</span>;</span><br><span class="line"><span class="constant">Screen </span>myScreen;</span><br><span class="line"><span class="regexp">//</span> equivalent ways to fetch width member of myScreen</span><br><span class="line"><span class="constant">Screen:</span><span class="symbol">:index</span> ind1 = myScreen.width; <span class="regexp">//</span> directly</span><br><span class="line"><span class="constant">Screen:</span><span class="symbol">:index</span> ind2 = myScreen.*pindex; <span class="regexp">//</span> dereference to get width</span><br><span class="line"><span class="constant">Screen </span>*pScreen;</span><br><span class="line"><span class="regexp">//</span> equivalent ways to fetch width member of *pScreen</span><br><span class="line">ind1 = pScreen-&gt;width; <span class="regexp">//</span> directly</span><br><span class="line">ind2 = pScreen-&gt;*pindex; <span class="regexp">//</span> dereference pindex to get width</span><br></pre></td></tr></table></figure>
<h2 id="6-_Pointer-to-Member_Function_Tables">6. Pointer-to-Member Function Tables</h2><p>One common use for function pointers and for pointers to member functions is to store them in a function table. A function table is a collection of function pointers from which a given call is selected at run time.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// other interface and implementation members as before</span></span><br><span class="line">        Screen&amp; home(); <span class="comment">// cursor movement functions</span></span><br><span class="line">        Screen&amp; forward();</span><br><span class="line">        Screen&amp; back();</span><br><span class="line">        Screen&amp; up();</span><br><span class="line">        Screen&amp; down();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Screen &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// other interface and implementation members as before</span></span><br><span class="line">        <span class="comment">// Action is pointer that can be assigned any of the cursor movement members</span></span><br><span class="line">        <span class="keyword">typedef</span> Screen&amp; (Screen::*Action)();</span><br><span class="line">        <span class="keyword">static</span> Action Menu[]; <span class="comment">// function table</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// specify which direction to move</span></span><br><span class="line">        <span class="keyword">enum</span> Directions &#123; HOME, FORWARD, BACK, UP, DOWN &#125;;</span><br><span class="line">        Screen&amp; move(Directions);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Screen&amp; Screen::move(Directions cm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fetch the element in Menu indexed by cm</span></span><br><span class="line">    <span class="comment">// run that member on behalf of this object</span></span><br><span class="line">    (<span class="keyword">this</span>-&gt;*Menu[cm])();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// What's left is to define and initialize the table itself:</span></span><br><span class="line">Screen::Action Screen::Menu[] = &#123;   &amp;Screen::home,</span><br><span class="line">                                    &amp;Screen::forward,</span><br><span class="line">                                    &amp;Screen::back,</span><br><span class="line">                                    &amp;Screen::up,</span><br><span class="line">                                    &amp;Screen::down,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Screen myScreen;</span><br><span class="line">myScreen.move(Screen::HOME); <span class="comment">// invokes myScreen.home</span></span><br><span class="line">myScreen.move(Screen::DOWN); <span class="comment">// invokes myScreen.down</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/21/c-primer笔记27-Pointer-to-Class-Member/" data-id="cinvexisi001ntw3allf55qml" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记26-RTTI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/c-primer笔记26-RTTI/" class="article-date">
  <time datetime="2016-03-21T03:25:40.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/c-primer笔记26-RTTI/">c++ primer笔记26: RTTI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Run-Time_Type_Identification">1. Run-Time Type Identification</h2><p>RTTI is provided through two operators:</p>
<ul>
<li>The typeid operator, which returns the actual type of the object referred to by a pointer or a reference</li>
<li>The  dynamic_cast operator, which safely converts from a pointer or reference to a base type to a pointer or reference to a derived type</li>
</ul>
<p>These operators return dynamic type information only for <code>classes with one or more virtual functions</code>. For all other types, information for the static (i.e., compile-time) type is returned. Dynamic casts should be used with caution. Whenever possible, it is much better to define and use a virtual function rather than to take over managing the types directly.</p>
<h2 id="2-_The_dynamic_cast_Operator">2. The  dynamic_cast Operator</h2><p>The  dynamic_cast operator can be used to convert a reference or pointer to an object of base type to a reference or pointer to another type in the same hierarchy.</p>
<p>Unlike other casts, a  dynamic_cast involves a run-time type check. If the object bound to the reference or pointer is not an object of the target type, then the  dynamic_cast fails. If an dynamic_cast to a pointer type fails, the result of the  dynamic_cast is the value 0. If a dynamic_cast to a reference type fails, then an exception of type  bad_cast is thrown. The verification that the dynamic_cast operator performs must be done at <code>run time</code>.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *derivedPtr = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(basePtr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use the Derived object to which derivedPtr points</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// BasePtr points at a Base object</span></span><br><span class="line">    <span class="comment">// use the Base object to which basePtr points</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Performing a  dynamic_cast in a condition ensures that the cast and test of its result are done in a single expression. Another advantage is that the pointer is not accessible outside the  if. If the cast fails, then the unbound pointer is not available for use in later cases where the test might be forgotten.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Derived &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</span><br><span class="line">        <span class="comment">// use the Derived object to which b referred</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (bad_cast) &#123;</span><br><span class="line">        <span class="comment">// handle the fact that the cast failed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-_The_typeid_Operator">3. The  typeid Operator</h2><p><code>typeid(e)</code> where  e is any expression or a type name. When the operand is not of class type or is a class without virtual functions, then the  typeid operator indicates the static type of the operand. When the operand has a class-type that defines at least one virtual function, then the type is evaluated at run time. The result of a  typeid operation is a reference to an object of a library type named  type_info.<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line">Base <span class="built_in">*</span>bp;</span><br><span class="line">Derived <span class="built_in">*</span>dp;</span><br><span class="line"><span class="comment">// compare type at run time of two objects</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(typeid<span class="params">(*bp)</span> == typeid<span class="params">(*dp)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// bp and dp point to objects of the same type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test whether run time type is a specific type</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(typeid<span class="params">(*bp)</span> == typeid<span class="params">(Derived)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// bp actually points to a Derived</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Note that the operands to the  typeid are expressions that are objectswe tested  *bp , not  bp. Dynamic type information is returned only if the operand to  typeid is an object of a class type with virtual functions. Testing a pointer (as opposed to the object to which the pointer points) returns the static, compile-time type of the pointer.</p>
<p>If the value of a pointer  p is 0, then  typeid(<em>p) throws a  bad_typeid exception if the type of  p is a type with virtual functions. If the type of  p does not define any virtuals, then the value of  p is irrelevant. As when evaluating a  sizeof expression the compiler does not evaluate  </em>p . It uses the static type of  p , which does not require that  p itself be a valid pointer.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/21/c-primer笔记26-RTTI/" data-id="cinvexiwe001ptw3a1e375n2i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记25-Optimizing-Memory-Allocation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/c-primer笔记25-Optimizing-Memory-Allocation/" class="article-date">
  <time datetime="2016-03-20T12:57:08.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/c-primer笔记25-Optimizing-Memory-Allocation/">c++ primer笔记25: Optimizing Memory Allocation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_A_Memory-Allocator_Base_Class">1. A Memory-Allocator Base Class</h2><p>One common strategy is to preallocate a block of raw memory to hold unconstructed objects. When new elements are created, they could be constructed in one of these preallocated objects. When elements are freed, we’d put them back in the block of preallocated objects rather than actually returning memory to the system. This kind of strategy is often known as maintaining a <code>freelist</code> . The freelist might be implemented as a linked list of objects that have been allocated but not constructed. We’ll define a new class that we’ll name  <code>CachedObj</code> to handle the freelist. </p>
<p>The  CachedObj class will have a simple interface: Its only job is to allocate and manage a freelist of allocated but unconstructed objects. This class will define a member  operator new that will return the next element from the freelist, removing it from the freelist. The  operator new will allocate new raw memory whenever the freelist becomes empty. The class will also define operator delete to put an element back on the freelist when an object is destroyed. Classes that wish to use a freelist allocation strategy for their own types will inherit from CachedObj.</p>
<p>As we’ll see,  CachedObj may be used only for types that are not involved in an inheritance hierarchy. Unlike the member  new and<br>delete operations,  CachedObj has no way to allocate different sized objects depending on the actual type of the object: Its freelist holds objects of a single size. Hence, it may be used only for classes, such as  QueueItem , that do not serve as base classes. The data members defined by the  CachedObj class, and inherited by its derived classes, are:</p>
<ul>
<li>A  static pointer to the head of the freelist</li>
<li>A member named  next that points from one  CachedObj to the next</li>
</ul>
<p>The  next pointer chains the elements together onto the freelist. Each type that we derive from CachedObj will contain its own type-specific data plus a single pointer inherited from the CachedObj base class. When the object is in use, this pointer is meaningless and not used. When the object is available for use and is on the freelist, then the  next pointer is used to point to the next available object.</p>
<p>The only remaining question is what types to use for the pointers in CachedObj. We’d like to use the freelist approach for any type, so the class will be a template. The pointers will point to an object of the template type:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> CachedObj</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CachedObj() : next(NULL) &#123;&#125;</span><br><span class="line">        <span class="keyword">void</span> * <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, size_t)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~CachedObj() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_to_freelist</span><span class="params">(T*)</span></span>;</span><br><span class="line">        <span class="keyword">static</span> allocator&lt;T&gt; alloc_mem;</span><br><span class="line">        <span class="keyword">static</span> T *freeStore;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> chunk;</span><br><span class="line">        T *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The  static members manage the freelist. These members are declared as  static because there is only one freelist maintained for all the objects of a given type. The  freeStore pointer points to the head of the freelist. The member named  chunk specifies the number of objects that will be allocated each time the freelist is empty.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> * CachedObj&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t sz)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// new should only be asked to build a T, not an object</span></span><br><span class="line">    <span class="comment">// derived from T; check that right size is requested</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sz != <span class="keyword">sizeof</span>(T))</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"CachedObj: wrong size object in operator new"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NULL == freeStore)</span><br><span class="line">    &#123;</span><br><span class="line">        T *<span class="built_in">array</span> = alloc_mem.allocate(chunk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add_t</span>o_freelist(&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;CachedObj&lt;T&gt;::next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// constructor of T will construct the T part of the object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CachedObj&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p, size_t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(NULL != p)</span><br><span class="line">        <span class="keyword">add_t</span>o_freelist(<span class="keyword">static_cast</span>&lt;T*&gt;(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CachedObj&lt;T&gt;::<span class="keyword">add_t</span>o_freelist(T *p)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;CachedObj&lt;T&gt;::next = freeStore;</span><br><span class="line">    freeStore = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The only tricky part is the use of the  next member. Recall that  CachedObj is intended to be used as a base class. The objects that are allocated aren’t of type  CachedObj . Instead, those objects are of a type derived from  CachedObj . The type of  T , therefore, will be the derived type. The pointer  p is a pointer to  T , not a pointer to  CachedObj . If the derived class has its own member named  next , then writing <code>p-&gt;next</code> would fetch the  next member of the derived class! But we want to set the  next in the base, CachedObj class.</p>
<p>What remains is to define the static data members:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; allocator&lt; T &gt; <span class="type">CachedObj</span>&lt; T &gt;::alloc_mem;</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; T *<span class="type">CachedObj</span>&lt; T &gt;::freeStore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="keyword">const</span> size_t <span class="type">CachedObj</span>&lt; T &gt;::chunk = <span class="number">24</span>;</span><br></pre></td></tr></table></figure></p>
<p>Here is how we use CachedObj:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">class <span class="type">Screen</span>: public <span class="type">CachedObj</span>&lt;<span class="type">Screen</span>&gt; &#123;</span><br><span class="line">    // <span class="keyword">interface</span> <span class="keyword">and</span> implementation members <span class="keyword">of</span> class <span class="type">Screen</span> are unchanged</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt;</span><br><span class="line">class <span class="type">QueueItem</span>: public <span class="type">CachedObj</span>&lt; <span class="type">QueueItem</span>&lt;<span class="type">Type</span>&gt; &gt; &#123;</span><br><span class="line">    // remainder <span class="keyword">of</span> class declaration <span class="keyword">and</span> all member definitions unchanged</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_练习题">2. 练习题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> iStack &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        iStack(<span class="keyword">int</span> capacity): <span class="built_in">stack</span>(capacity), top(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> top;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(a) iStack *ps = <span class="keyword">new</span> iStack(<span class="number">20</span>);        <span class="comment">// ok</span></span><br><span class="line">(b) iStack *ps2 = <span class="keyword">new</span> <span class="function"><span class="keyword">const</span> <span class="title">iStack</span><span class="params">(15)</span></span>; <span class="comment">// error</span></span><br><span class="line">(c) iStack *ps3 = <span class="keyword">new</span> iStack[ <span class="number">100</span> ];    <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>注意iStack中类类型的数据成员stack的初始化方式。b错误是因为返回的是const iStack *类型的指针。c错误是因为使用new表达式动态分配数组时，如果数组元素具有类类型，则使用该类的默认构造函数初始化，但是iStack没有。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/20/c-primer笔记25-Optimizing-Memory-Allocation/" data-id="cinvexiwh001rtw3a4h4equ3g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记24-Optimizing-Memory-Allocation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/c-primer笔记24-Optimizing-Memory-Allocation/" class="article-date">
  <time datetime="2016-03-20T11:04:19.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/c-primer笔记24-Optimizing-Memory-Allocation/">c++ primer笔记24: Optimizing Memory Allocation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_operator_new_and_operator_delete_Functions">1. operator new and operator delete Functions</h2><p>We have learned how to use the allocate class. Now we are using the more primitive library facilities. <code>string * sp = new string(&quot;initialized&quot;);</code> Three steps actually take place. First, the expression calls a library function named <code>operator new</code> to allocate raw, untyped memory large enough to hold an object of the specified type. Next, a constructor for the type is run to construct the object from the specified initializers. Finally, a pointer to the newly allocated and constructed object is returned. When we use a  delete expression to delete a dynamically allocated object: <code>delete sp;</code> Two steps happen. First, the appropriate destructor is run on the object to which sp points. Then, the memory used by the object is freed by calling a library function named  operator delete.</p>
<p>The library functions operator new and operator delete are misleadingly named. Unlike other operator functions, such as operator= , these functions do not overload the new or delete expressions. In fact, we cannot redefine the behavior of the  new and delete expressions. A new expression executes by calling an operator new function to obtain memory and then constructs an object in that memory. A delete expression executes by destroying an object and then calls an operator delete function to free the memory used by the object.</p>
<p>There are two overloaded versions of  operator new and operator delete functions. Each version supports the related new and delete expression:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>; <span class="comment">// allocate an object</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>); <span class="comment">// allocate an array</span></span><br><span class="line"><span class="keyword">void</span> *<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>; <span class="comment">// free an object</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*); <span class="comment">// free an array</span></span><br><span class="line"></span><br><span class="line">T* newelements = alloc.allocate(newcapacity);</span><br><span class="line"><span class="comment">// which could be rewritten as</span></span><br><span class="line">T* newelements = <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">operator</span> <span class="keyword">new</span>[](newcapacity * <span class="keyword">sizeof</span>(T)));</span><br><span class="line"></span><br><span class="line">alloc.deallocate(elements, end - elements);</span><br><span class="line"><span class="comment">// which could be rewritten as</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[](elements);</span><br></pre></td></tr></table></figure></p>
<p>In general, it is more type-safe to use an allocator rather than using the operator new and operator delete functions directly.</p>
<h2 id="2-_Placement_new_Expressions">2. Placement new Expressions</h2><p>The library functions operator new and operator delete are lower-level versions of the allocator members  allocate and deallocate. Each allocates but does not initialize memory. There are also lower-level alternatives to the allocator members construct and  destroy. These members initialize and destroy objects in space allocated by an allocator object. Placement new allows us to construct an object at a specific, preallocated memory address. The form of a placement  new expression is:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) <span class="class"><span class="keyword">type</span></span></span><br><span class="line"><span class="keyword">new</span> (place_address) <span class="class"><span class="keyword">type</span> </span>(initializer-list)</span><br><span class="line"></span><br><span class="line">alloc.construct(first_free, t);</span><br><span class="line"><span class="comment">// would be replaced by the equivalent placement new expression</span></span><br><span class="line"><span class="comment">// copy t into element addressed by first_free</span></span><br><span class="line"><span class="keyword">new</span> (first_free) T(t);</span><br></pre></td></tr></table></figure></p>
<p>Placement new expressions are more flexible than the construct member of class allocator. When placement new initializes an object, it can use any constructor, and builds the object directly. The construct function always uses the copy constructor.<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"><span class="built_in">string</span> *<span class="keyword">sp</span> = alloc.allocate(<span class="number">2</span>); // allocate space <span class="keyword">to</span> hold <span class="number">2</span> strings</span><br><span class="line">// two ways <span class="keyword">to</span> construct <span class="keyword">a</span> <span class="built_in">string</span> from <span class="keyword">a</span> pair of iterators</span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">sp</span>) <span class="built_in">string</span>(<span class="keyword">b</span>, <span class="keyword">e</span>); // construct directly in place</span><br><span class="line">alloc.construct(<span class="keyword">sp</span> + <span class="number">1</span>, <span class="built_in">string</span>(<span class="keyword">b</span>, <span class="keyword">e</span>)); // build <span class="built_in">and</span> <span class="built_in">copy</span> <span class="keyword">a</span> temporary</span><br></pre></td></tr></table></figure></p>
<p>The placement new expression uses the  string constructor that takes a pair of iterators to construct the string directly in the space to which sp points. When we call construct, we must first construct the string from the iterators to get a string object to pass to construct. That function then uses the string copy constructor to copy that unnamed, temporary string into the object to which sp points.</p>
<h2 id="3-_Explicit_Destructor_Invocation">3. Explicit Destructor Invocation</h2><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="params">(T *p = first_free; p != elements; /* empty */ )</span></span><br><span class="line">    alloc.destroy<span class="params">(--p)</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="params">(T *p = first_free; p != elements; /* empty */ )</span></span><br><span class="line">    p-&gt;~T<span class="params">()</span>; <span class="comment">// call the destructor</span></span><br></pre></td></tr></table></figure>
<p>The effect of calling the destructor explicitly is that the object itself is properly cleaned up. However, the memory in which the object resided is not freed. We can reuse the space if desired.</p>
<h2 id="4-_Class_Specific_new_and_delete">4. Class Specific new and delete</h2><p>Another way to optimize memory allocation involves optimizing the behavior of new expressions. As an example, consider the Queue class from Chapter 16. That class doesn’t hold its elements directly. Instead, it uses new expressions to allocate objects of type  QueueItem.</p>
<p>It might be possible to improve the performance of Queue by preallocating a block of raw memory to hold QueueItem objects. When a new QueueItem object is created, it could be constructed in this preallocated space. When QueueItem objects are freed, we’d put them back in the block of preallocated objects rather than actually returning memory to the system.</p>
<p>By default, new expressions allocate memory by calling the version of operator new that is defined by the library. A class may manage the memory used for objects of its type by defining its own members named operator new and operator delete.</p>
<p>When the compiler sees a  new or  delete expression for a class type, it looks to see if the class has a member  operator new or  operator delete . If the class defines (or inherits) its own member  new and  delete functions, then those functions are used to allocate and free the memory for the object. Otherwise, the standard library versions of these functions are called.</p>
<p>When we optimize the behavior of  new and  delete , we need only define new versions of the operator new and  operator delete . The  new and  delete expressions themselves take care of constructing and destroying the objects. If a class defines either of these members, it should define both of them.</p>
<p>A class member  operator new function must have a return type of  void* and take a parameter of type  size_t . The function’s  size_t parameter is initialized by the  new expression with the size, in bytes, of the amount of memory to allocate. A class member  operator delete function must have a  void return type. It can be defined to take a single parameter of type  void<em> or to take two parameters, a  void</em> and a  size_t . The void* parameter is initialized by the  delete expression with the pointer that was  delete d. That pointer might be a null pointer. If present, the  size_t parameter is initialized automatically by the compiler with the size in bytes of the object addressed by the first parameter.</p>
<p>The  size_t parameter is unnecessary unless the class is part of an inheritance hierarchy. When we  delete a pointer to a type in an inheritance hierarchy, the pointer might point to a base-class object or an object of a derived class. In general, the size of a derived-type object is larger than the size of a base-class object. If the base class has a  virtual destructor, then the size passed to  operator delete will vary depending on the dynamic type of the object to which the deleted pointer points. If the base class does not have a virtual destructor, then, as usual, the behavior of deleting a pointer to a derived object through a base-class pointer is undefined.</p>
<p>These functions are implicitly static members. There is no need to declare them  static explicitly, although it is legal to do so. The member  new and  delete functions must be static because they are used either before the object is constructed ( operator<br>new ) or after it has been destroyed ( operator delete ). There are, therefore, no member data for these functions to manipulate. As with any other static member function,  new and  delete may access only static members of their class directly.</p>
<p>We can also define member  operator new[] and  operator delete[] to manage arrays of the class type. If these  operator functions exist, the compiler uses them in place of the global versions.</p>
<p>A class member  operator new[] must have a return type of  void* and take a first parameter of type  size_t . The operator’s  size_t parameter is initialized automatically with a value that represents the number of bytes required to store an array of the given number of elements of the specified type.</p>
<p>The member operator  delete[] must have a  void return type and a first parameter of type void<em> . The operator’s  void</em> parameter is initialized automatically with a value that represents the beginning of the storage in which the array is stored.</p>
<p>The operator  delete[] for a class may also have two parameters instead of one, the second parameter being a  size_t . If present, the additional parameter is initialized automatically by the compiler with the size in bytes of the storage required to store the array.</p>
<p>A user of a class that defines its own member  new and  delete can force a  new or  delete expression to use the global library functions through the use of the global scope resolution operator. If the user writes<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Type *p = ::<span class="keyword">new</span> Type; <span class="regexp">//</span> uses <span class="built_in">global</span> operator <span class="keyword">new</span></span><br><span class="line">::<span class="keyword">delete</span> p; <span class="regexp">//</span> uses <span class="built_in">global</span> operator <span class="keyword">delete</span></span><br></pre></td></tr></table></figure></p>
<p>If storage was allocated with a  new expression invoking the global operator new function, then the  delete expression should also<br>invoke the global  operator delete function.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/20/c-primer笔记24-Optimizing-Memory-Allocation/" data-id="cinvexiwk001ttw3a8cleatc5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记23-Optimizing-Memory-Allocation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/c-primer笔记23-Optimizing-Memory-Allocation/" class="article-date">
  <time datetime="2016-03-20T05:52:07.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/c-primer笔记23-Optimizing-Memory-Allocation/">c++ primer笔记23: Optimizing Memory Allocation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Optimizing_Memory_Allocation">1. Optimizing Memory Allocation</h2><p>A common strategy is to preallocate memory to be used when new objects are created, constructing each new object in preallocated memory as needed. We need to decouple memory allocation from object construction. The obvious reason to decouple allocation and construction is that constructing objects in preallocated memory is wasteful.</p>
<p>In C++, When we use a <code>new expression</code>, memory is allocated, and an object is constructed in that memory. When we use a <code>delete expression</code>, a destructor is called to destroy the object and the memory used by the object is returned to the system. When we take over memory allocation, we must deal with both these tasks. When we allocate raw memory, we must construct object(s) in that memory. Before freeing that memory, we must ensure that the objects are properly destroyed. C++ provides two ways to allocate and free unconstructed, raw memory:</p>
<ul>
<li>The allocator class, which provides type-aware memory allocation. This class supports an abstract interface to allocating memory and subsequently using that memory to hold objects.</li>
<li>The library <code>operator new</code> and <code>operator delete</code> functions, which allocate and free raw, untyped memory of a requested size.</li>
</ul>
<p>C++ also provides various ways to construct and destroy objects in raw memory:</p>
<ul>
<li>The allocator class defines members named construct and destroy. The construct member initializes objects in unconstructed memory;<br>the destroy member runs the appropriate destructor on objects.</li>
<li>The placement new expression takes a pointer to unconstructed memory and initializes an object or an array in that space.</li>
<li>We can directly call an object’s destructor to destroy the object. Running the destructor does not free the memory in which the object resides.</li>
<li>The algorithms uninitialized_fill and  uninitialized_copy execute like the fill and copy algorithms except that they construct objects in their destination rather than assigning to them.</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// <span class="type">The</span> behavior <span class="keyword">of</span> copy <span class="keyword">template</span> <span class="keyword">is</span> equivalent to:</span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">InputIterator</span>, class <span class="type">OutputIterator</span>&gt;</span><br><span class="line">  <span class="type">OutputIterator</span> copy (<span class="type">InputIterator</span> first, <span class="type">InputIterator</span> last, <span class="type">OutputIterator</span> <span class="literal">result</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    *<span class="literal">result</span> = *first;</span><br><span class="line">    ++<span class="literal">result</span>; ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说copy是赋值行为，uninitialized_copy是在一块raw内存中的初始化行为。赋值行为意味着将释放原来的数据。Assigning to an object in unconstructed memory rather than initializing it is undefined. For many classes, doing so causes a crash at run time. Assignment involves freeing the existing object. If there is no existing object, then the actions in theassignment operator can have disastrous effects.</p>
<p>Modern C++ programs ordinarily ought to use the <code>allocator</code> class to allocate memory. It is safer and more flexible. However, when<br>constructing objects, the <code>placement new expression</code> is more flexible than the allocator::construct member. There are some cases where placement new must be used. 因为allocator::construct只能使用拷贝构造函数来构造对象。</p>
<h2 id="2-_The_allocator_Class">2. The allocator Class</h2><table>
<thead>
<tr>
<th>Class allocator</th>
<th>&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>allocator<t> a;</t></td>
<td>Defines an allocator object named a that can allocate memory or construct objects of type T.</td>
</tr>
<tr>
<td>a.allocate(n)</td>
<td>Allocates raw, unconstructed memory to hold n objects of type T.</td>
</tr>
<tr>
<td>a.deallocate(p, n)</td>
<td>Deallocates memory that held n objects of type T starting at address contained in the T* pointer named p. It is the user’s responsibility to run destroy on any objects that were constructed in this memory before calling deallocate.</td>
</tr>
<tr>
<td>a.construct(p, t)</td>
<td>Constructs a new element in the memory pointed to by the T* pointer p. The copy constructor of type T is run to initialize the object from t.</td>
</tr>
<tr>
<td>a.destroy(p)</td>
<td>Runs the destructor on the object pointed to by the T* pointer p.</td>
</tr>
<tr>
<td>uninitialized_copy(b, e, b2)</td>
<td>Copies elements from the input range denoted by iterators b and e into unconstructed, raw memory beginning at iterator b2. The function constructs elements in the destination, rather than assigning them. The destination denoted by b2 is assumed large enough to hold a copy of the elements in the input range.</td>
</tr>
<tr>
<td>uninitialized_fill(b, e, t)</td>
<td>Initializes objects in the range denoted by iterators b and e as a copy of t. The range is assumed to be unconstructed, raw memory. The objects are constructed using the copy constructor.</td>
</tr>
<tr>
<td>uninitialized_fill_n(b, e, t, n)</td>
<td>Initializes at most an integral number n objects in the range denoted by iterators b and e as a copy of t. The range is assumed to be at least n elements in size. The objects are constructed using the copy constructor.</td>
</tr>
</tbody>
</table>
<p>The allocator class separates allocation and object construction. When an allocator object allocates memory, it allocates space that is appropriately sized and aligned to hold objects of the given type. However, the memory it allocates is unconstructed. Users of allocator must separately construct and destroy objects placed in the memory it allocates.</p>
<h2 id="3-_Using_allocator_to_Manage_Class_Member_Data">3. Using allocator to Manage Class Member Data</h2><p>To understand how we might use a preallocation strategy and the  allocator class to manage the internal data needs of a class, let’s think a bit more about how memory allocation in the vector class might work.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// pseudo-implementation <span class="keyword">of</span> memory allocation strategy <span class="keyword">for</span> a vector-like class</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; class <span class="type">Vector</span> &#123;</span><br><span class="line">    public:</span><br><span class="line">        <span class="type">Vector</span>(): elements(<span class="number">0</span>), first_free(<span class="number">0</span>), <span class="keyword">end</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        <span class="type">void</span> push_back(<span class="keyword">const</span> T&amp;);</span><br><span class="line">        // ...</span><br><span class="line">    private:</span><br><span class="line">        <span class="keyword">static</span> std::allocator&lt;T&gt; alloc; // <span class="keyword">object</span> to get raw memory</span><br><span class="line">        <span class="type">void</span> reallocate();  // get more space <span class="keyword">and</span> copy existing elements</span><br><span class="line">        T* elements; // <span class="type">pointer</span> to first element <span class="keyword">in</span> the <span class="type">array</span></span><br><span class="line">        T* first_free; // <span class="type">pointer</span> to first free element <span class="keyword">in</span> the <span class="type">array</span></span><br><span class="line">        T* <span class="keyword">end</span>; // <span class="type">pointer</span> to one past the <span class="keyword">end</span> <span class="keyword">of</span> the <span class="type">array</span></span><br><span class="line">        // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Vector</span>&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(first_free == <span class="keyword">end</span>)</span><br><span class="line">        reallocate();</span><br><span class="line">    alloc.construct(first_free, t);</span><br><span class="line">    ++first_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Vector</span>&lt;T&gt;::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">    ptrdiff_t size = first_free - elements;</span><br><span class="line">    ptrdiff_t newcapacity = max(size, <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    T *new_elements = alloc.allocate(newcapacity);</span><br><span class="line">    uninitialized_copy(elements, <span class="keyword">end</span>, new_elements);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(T *p = elements; p != <span class="keyword">end</span>; ++p)</span><br><span class="line">        alloc.destroy(p);</span><br><span class="line"></span><br><span class="line">    // deallocate cannot be called on a <span class="number">0</span> <span class="type">pointer</span></span><br><span class="line">    <span class="keyword">if</span> (elements)</span><br><span class="line">        alloc.deallocate(elements, size);</span><br><span class="line"></span><br><span class="line">    elements = new_elements;</span><br><span class="line">    first_free = elements + size;</span><br><span class="line">    <span class="keyword">end</span> = elements + newcapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意静态成员alloc在实现文件中的定义</span><br><span class="line"><span class="keyword">template</span>&lt;class T&gt;</span><br><span class="line">allocator&lt;T&gt; <span class="type">Vector</span>&lt;T&gt;::alloc;</span><br></pre></td></tr></table></figure></p>
<p>Each Vector<t> type defines a static data member of type allocator<t> to allocate and construct the elements in Vectors of the given type. deallocate expects a pointer that points to space that was allocated by allocate. It is not legal to pass deallocate a zero pointer.</t></t></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/20/c-primer笔记23-Optimizing-Memory-Allocation/" data-id="cinvexiwm001vtw3ah04ighlc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记22-multiple-inheritance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/19/c-primer笔记22-multiple-inheritance/" class="article-date">
  <time datetime="2016-03-19T07:25:38.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/c-primer笔记22-multiple-inheritance/">c++ primer笔记22: multiple inheritance</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Multiple_Inheritance">1. Multiple Inheritance</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> : <span class="typename">public ZooAnimal &#123; &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> : <span class="typename">public Bear</span>, <span class="typename">public Endangered &#123; &#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>The constructor initializer controls only the values that are used to initialize the base classes, not the order in which the base classes are constructed. The base-class constructors are invoked in the order in which they appear in the class derivation list. For  Panda , the order of base-class initialization is:</p>
<ul>
<li>ZooAnimal, the ultimate base class up the hierarchy from  Panda ‘s immediate base clas  Bear.</li>
<li>Bear, the first immediate base class.</li>
<li>Endangered, the second immediate base, which itself has no base class.</li>
<li>Panda, the members of  Panda itself are initialized, and then the body of its constructor is run. </li>
</ul>
<p>Destructors are always invoked in the reverse order from which the constructors are run. In our example, the order in which the destructors are called is  ~Panda, ~Endangered, ~Bear, ~ZooAnimal.<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="typename">public A &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="typename">private B &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="typename">public X</span>, <span class="typename">public C &#123; ... &#125;;</span></span></span><br><span class="line"></span><br><span class="line">which, <span class="keyword">if</span> any, of the following conversions are not permitted?</span><br><span class="line">D *pd = new D;</span><br><span class="line">(a) X *px = pd; (c) B *pb = pd;</span><br><span class="line">(b) A *pa = pd; (d) C *pc = pd;</span><br></pre></td></tr></table></figure></p>
<p>b和c是错误的，因为C对B是私有继承的，对于C的子类而言，它完全不知道有B的存在，所有无法转化为B和A。</p>
<p>As is the case for single inheritance, if a class with multiple bases defines its own destructor, that destructor is responsible only for cleaning up the derived class. If the derived class defines its own copy constructor or assignment operator, then the class is responsible for copying (assigning) all the base class subparts. The base parts are automatically copied or assigned only if the derived class uses the synthesized versions of these members.</p>
<p>As usual, name lookup for a name used in a member function starts in the function itself. If the name is not found locally, then lookup continues in the member’s class and then searches each base class in turn. Under multiple inheritance, the search simultaneously examines all the base-class inheritance subtreesin our example, both the  Endangered and the  Bear / ZooAnimal subtrees are examined in parallel. If the name is found in more than one subtree, then the use of that name must explicitly specify which base class to use. Otherwise, the use of the name is ambiguous.</p>
<h2 id="2-_Multiple_Base_Classes_Can_Lead_to_Ambiguities">2. Multiple Base Classes Can Lead to Ambiguities</h2><p>Assume both  Bear and  Endangered define a member named  print . If  Panda does not define that member, then a statement such as the following <code>ying_yang.print(cout);</code>results in a compile-time error. Although the ambiguity of the two inherited  print members is reasonably obvious, it might be more surprising to learn that an error would be generated even if the two inherited functions had<br>different parameter lists. Similarly, it would be an error even if the  print function were private in one class and public or protected in the other. Finally, if  print were defined in ZooAnimal and not Bear, the call would still be in error. It’s because name lookup happens first. As always, name lookup happens in two steps: First the compiler finds a matching declaration (or, in this case, two matching declarations, which causes the ambiguity). Only then does the compiler decide whether the declaration it found is legal.</p>
<p>We could resolve the  print ambiguity by specifying which class to use:<code>ying_yang.Endangered::print(cout);</code>. The best way to avoid potential ambiguities is to define a version of the function in the derived class that resolves the ambiguity. </p>
<h2 id="3-_Virtual_Inheritance">3. Virtual Inheritance</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span> : <span class="typename">public virtual ios &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> : <span class="typename">virtual public ios &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span>: <span class="typename">public istream</span>, <span class="typename">public ostream &#123; ... &#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>Members in the shared virtual base can be accessed unambiguously and directly. Similarly, if a member from the virtual base is redefined along only one derivation path, then that redefined member can be accessed directly. Under a nonvirtual derivation, both kinds of access would be ambiguous. Assume a member named  X is inherited through more than one derivation path. There are three<br>possibilities:</p>
<ul>
<li>If in each path X represents the same virtual base class member, then there is no ambiguity because a single instance of the member is shared.</li>
<li>If in one path X is a member of the virtual base class member and in another path X is a member of a subsequently derived class, there is also no ambiguitythe specialized derived class instance is given precedence over the shared virtual base class instance.</li>
<li>If along each inheritance path  X represents a different member of a subsequently derived class, then the direct access of the member is ambiguous.</li>
</ul>
<h2 id="4-_Special_Initialization_Semantics">4. Special Initialization Semantics</h2><p>To solve the duplicate-initialization problem, classes that inherit from a class that has a virtual base have special handling for initialization. In a virtual derivation, the virtual base is initialized by the most derived constructor. Although the virtual base is initialized by the most derived class, any classes that inherit immediately or indirectly from the virtual base usually also have to provide their own initializers for that base. As long as we can create independent objects of a type derived from a virtual base, that class must initialize its virtual base. These initializers are used only when we create objects of the intermediate type.<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">Panda</span><span class="pseudo">::Panda</span>(<span class="attribute">std</span>::string name, bool onExhibit) : <span class="tag">ZooAnimal</span>(name, onExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">                                    <span class="tag">Bear</span>(name, onExhibit),</span><br><span class="line">                                    <span class="tag">Raccoon</span>(name, onExhibit),</span><br><span class="line">                                    <span class="tag">Endangered</span>(<span class="attribute">Endangered</span>::critical),</span><br><span class="line">                                    <span class="tag">sleeping_flag</span>(false) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>When a  Panda object is created:</p>
<ul>
<li>The ZooAnimal part is constructed first, using the initializers specified in the Panda constructor initializer list.</li>
<li>Next, the Bear part is constructed. The initializers for ZooAnimal Bear’s constructor initializer list are ignored.</li>
<li>Then the Raccoon part is constructed, again ignoring the ZooAnimal initializers. </li>
<li>Finally, the Panda part is constructed.</li>
</ul>
<p>If the Panda constructor does not explicitly initialize the  ZooAnimal base class, then the  ZooAnimal default constructor is used. If ZooAnimal doesn’t have a default constructor, then the code is in error. </p>
<h2 id="5-_Constructor_and_Destructor_Order">5. Constructor and Destructor Order</h2><p>Virtual base classes are always constructed prior to nonvirtual base classes regardless of where they appear in the inheritance hierarchy.<br><img src="/img/virtual_inheritance.PNG" alt=""><br>The immediate base classes are examined in declaration order to determine whether there are any virtual base classes. In our example, the inheritance subtree of BookCharacter is examined first, then that of  Bear , and finally that of ToyAnimal. Each subtree is examined starting at the root class down to the most derived class.</p>
<p>The order in which the virtual base classes are constructed for TeddyBear is ZooAnimal followed by ToyAnimal. Once the virtual base classes are constructed, the nonvirtual base-class constructors are invoked in declaration order:  BookCharacter, which causes the Character constructor to be invoked, and then  Bear. Thus, to create a TeddyBear, the constructors are invoked in the following order:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="constant">ZooAnimal</span>(); <span class="regexp">//</span> <span class="constant">Bear</span><span class="string">'s virtual base class</span><br><span class="line">ToyAnimal(); // immediate virtual base class</span><br><span class="line">Character(); // BookCharacter'</span>s nonvirtual base <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="constant">BookCharacter</span>(); <span class="regexp">//</span> immediate nonvirtual base <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="constant">Bear</span>(); <span class="regexp">//</span> immediate nonvirtual base <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="constant">TeddyBear</span>(); <span class="regexp">//</span> most derived <span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure></p>
<p>where the initializers used for ZooAnimal and ToyAnimal are specified by the most derived class TeddyBear. The same construction order is used in the synthesized copy constructor; the base classes also are assigned in this order in the synthesized assignment operator. The order of base-class destructor calls is guaranteed to be the reverse order of constructor invocation.</p>
<h2 id="6-_example1">6. example1</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> : <span class="typename">public Class &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> : <span class="typename">virtual public Base &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> : <span class="typename">virtual public Base &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> : <span class="typename">public Derived1</span>, <span class="typename">public Derived2 &#123; ... &#125;;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span> : <span class="typename">public MI</span>, <span class="typename">public Class &#123; ... &#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>What is the order of constructor and destructor for the definition of a Final object?<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Class</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Derived1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Derived2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">MI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Class</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Final</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>将首先调用虚基类Base的构造函数(导致调用Class())。</p>
<h2 id="7-_example2">7. example2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base(<span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Base有上面的构造函数，则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derived1 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Derived1(<span class="built_in">std</span>::<span class="built_in">string</span> s) : Base(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derived2 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Derived2(<span class="built_in">std</span>::<span class="built_in">string</span> s) : Base(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MI : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MI(<span class="built_in">std</span>::<span class="built_in">string</span> s) : Base(s), Derived1(s), Derived2(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Final : <span class="keyword">public</span> MI, <span class="keyword">public</span> Class</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Final(<span class="built_in">std</span>::<span class="built_in">string</span> s) : Base(s), MI(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，任何直接或间接继承虚基类Base的类都要必须为Base类提供显示初始化式(例如MI、Final)，否则将无法创建相应类的对象。而且编译的时候还会有警告<code>warning: direct base ‘Class’ inaccessible in ‘Final’ due to ambiguity</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/19/c-primer笔记22-multiple-inheritance/" data-id="cinvexiwv001xtw3amzxyleaq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记21-namespace" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/19/c-primer笔记21-namespace/" class="article-date">
  <time datetime="2016-03-19T06:52:01.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/c-primer笔记21-namespace/">c++ primer笔记21: namespace</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Classes,_Namespaces,_and_Scope">1.Classes, Namespaces, and Scope</h2><p>When a name is used in a class scope, we look first in the member itself, then in the class, including any base classes. Only after exhausting the class(es) do we examine the enclosing scopes.<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">namespace A &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            C1(): i(0), j(0) &#123; &#125; <span class="comment">// ok: initializes C1::i and C1::j</span></span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> k; <span class="comment">// returns A::k</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> h; <span class="comment">// error: h is not defined</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> i; <span class="comment">// hides A::i within C1</span></span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = i; <span class="comment">// initialized from A::i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// member f3 is defined outside class C1 and outside namespace A</span></span><br><span class="line"><span class="keyword">int</span> A::C1::f3()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// ok: returns A::h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_Argument-Dependent_Lookup_and_Class_Type_Parameters">2. Argument-Dependent Lookup and Class Type Parameters</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">std:</span><span class="symbol">:string</span> s;</span><br><span class="line"><span class="regexp">//</span> <span class="symbol">ok:</span> calls <span class="symbol">std:</span><span class="symbol">:getline</span>(<span class="symbol">std:</span><span class="symbol">:istream&amp;</span>, const <span class="symbol">std:</span><span class="symbol">:string&amp;</span>)</span><br><span class="line">getline(<span class="symbol">std:</span><span class="symbol">:cin</span>, s);</span><br></pre></td></tr></table></figure>
<p>It looks for a matching function in the current scope, the scopes enclosing the call to  getline, and in the namespace(s) in which the type of cin and the string type are defined. Hence, it looks in the namespace std and finds the getline function defined by the string type.</p>
<h2 id="3-_Implicit_Friend_Declarations_and_Namespaces">3. Implicit Friend Declarations and Namespaces</h2><p>Recall that when a class declares a friend function, a declaration for the function need not be visible. If there isn’t a declaration already visible, then the friend declaration has the effect of putting a declaration for that function or class into the surrounding scope. If a class is defined inside a namespace, then an otherwise undeclared friend function is declared in the same namespace:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">class</span> C &#123;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>; <span class="comment">// makes f a member of namespace A</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    A::C cobj;</span><br><span class="line">    f(cobj); <span class="comment">// calls A::f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_Candidate_Functions_and_Namespaces">4. Candidate Functions and Namespaces</h2><p>Namespaces can have two impacts on function matching. One of these should be obvious: A using declaration or directive can add functions to the candidate set. The other is much more subtle. As we saw in the previous section, name lookup for functions that have one or more class-type parameters includes the namespace in which each parameter’s class is defined. This rule also impacts how we determine the candidate set. Each namespace that defines a class used as a parameter (and those that define its base class(es)) is searched for candidate functions. Any functions in those namespaces that have the same name as the called function are added to the candidate set. These functions are added even though they otherwise are not visible at the point of the call. Functions with the matching name in those namespaces are added to the candidate set:<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">NS</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Item_base</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span>(<span class="params"><span class="keyword">const</span> Item_base&amp;</span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bulk_item's base class is declared in namespace NS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Bulk_item</span> : <span class="title">public</span> <span class="title">NS</span>::<span class="title">Item_base</span> &#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Bulk_item book1;</span><br><span class="line">    display(book1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-_Overloading_and_using_Declarations">5. Overloading and using Declarations</h2><p>There is no way to write a using declaration to refer to a specific function declaration:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> NS::print(<span class="keyword">int</span>); <span class="comment">// error: cannot specify parameter list</span></span><br><span class="line"><span class="keyword">using</span> NS::print; <span class="comment">// ok: using declarations specify names only</span></span><br></pre></td></tr></table></figure></p>
<p>If a function is overloaded within a namespace, then a using declaration for the name of that function declares all the functions with that name. If there are print functions for int and double in the namespace NS, then a using declaration for NS::print makes both functions visible in the current scope.</p>
<p>If the using declaration introduces a function in a scope that already has a function of the same name with the same parameter list, then the  using declaration is in error. Otherwise, the using declaration defines additional overloaded instances of the given name. The effect is to increase the set of candidate functions.</p>
<h2 id="6-_Namespaces_and_Templates">6.  Namespaces and Templates</h2><p>Declaring a template within a namespace impacts how template specializations are declared: An explicit specialization of a template must be declared in the namespace in which the generic template is defined. Otherwise, the specialization would have a different name than the template it specialized.</p>
<p>There are two ways to define a specialization: One is to reopen the namespace and add the definition of the specialization, which we can do because namespace definitions are discontiguous. Alternatively, we could define the specialization in the same way that we can define any namespace member outside its namespace definition: by defining the specialization using the template name qualified by the name of the namespace.</p>
<p>To provide our own specializations of templates defined in a namespace, we must ensure that the specialization definition is defined as being in the namespace containing the original template definition.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/19/c-primer笔记21-namespace/" data-id="cinvexiwx001ztw3a7xq7k43l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记20-namespace" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/19/c-primer笔记20-namespace/" class="article-date">
  <time datetime="2016-03-19T05:16:54.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/c-primer笔记20-namespace/">c++ primer笔记20: namespace</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Namespaces">1. Namespaces</h2><p>Unlike other scopes, a namespace can be defined in several parts. A namespace is made up of the sum of its separately defined parts; a namespace is cumulative. The separate parts of a namespace can be spread over multiple files. The fact that namespace definitions can be discontiguous means that we can compose a namespace from separate interface and implementation files. Thus, a namespace can be organized in the same way that we manage our own class and function definitions:</p>
<ul>
<li>Namespace members that define classes and declarations for the functions and objects that are part of the class interface can be put into header files. These headers can be included by files that use namespace members.</li>
<li>The definitions of namepsace members can be put in separate source files. </li>
</ul>
<p>Namespaces that define multiple, unrelated types should use separate files to represent each type that the namespace defines.<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---- Sales_item.h ----</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">cplusplus_primer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Sales_item</span> &#123; <span class="comment">/* ... */</span>&#125;;</span><br><span class="line">    Sales_item <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_item&amp;, <span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- Sales_item.cc ----</span></span><br><span class="line"><span class="preprocessor">#include "Sales_item.h"</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">cplusplus_primer</span> &#123;</span><br><span class="line">    <span class="comment">// definitions for Sales_item members and overloaded operators</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>It is also possible to define a namespace member outside its namespace definition. This definition should look similar to class member functions defined outside a class. The return type and function name are qualified by the namespace name. Once the fully qualified function name is seen, we are in the scope of the namespace. Thus, references to namespace members in the parameter list and the function body can use unqualified names to reference Sales_item.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cplusplus_primer::Sales_item</span><br><span class="line">cplusplus_primer::<span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_item&amp; lhs, <span class="keyword">const</span> Sales_item&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Sales_item <span class="title">ret</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Although a namespace member can be defined outside its namespace definition, there are restrictions on where this definition can appear. Only namespaces enclosing the member declaration can contain its definition. For example,  operator+ could be defined in either the cplusplus_primer namespace or at global scope. It may not be defined in an unrelated namespace.</p>
<h2 id="2-_Unnamed_Namespaces">2. Unnamed Namespaces</h2><p>Unnamed namespaces are not like other namespaces; the definition of an unnamed namespace is local to a particular file and never<br>spans multiple text files. An unnamed namespace may be discontiguous within a given file but does not span files. Each file has its own unnamed namespace. Names defined in an unnamed namespace are used directly; after all, there is no namespace name with which to qualify them. It is not possible to use the scope operator to refer to members of unnamed namespaces.</p>
<p>Names defined in an unnamed namespace are found in the same scope as the scope at which the namespace is defined. If an unnamed namespace is defined at the outermost scope in the file, then names in the unnamed namespace must differ from names defined at global scope:<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">// global declaration for i</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: ambiguous defined globally and in an unnested, unnamed namespace</span></span><br><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>The use of file static declarations is deprecated by the C++ standard. File statics should be avoided and unnamed namespaces used instead.</p>
<h2 id="3-_Using_Namespace_Members">3. Using Namespace Members</h2><p>Referring to namespace members as namespace_name::member_name is admittedly cumbersome, especially if the namespace name is long. Fortunately, there are ways to make it easier to use namespace members: using declarations、namespace aliases and using directives.</p>
<p>Header files should not contain using directives or using declarations except inside functions or other scopes. A header that includes a using directive or declaration at its top level scope has the effect of injecting that name into the file that includes the header. Headers should define only the names that are part of its interface, not names used in its own implementation. </p>
<p>A namespace alias can be used to associate a shorter synonym with a namespace name. For example<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cplusplus_primer:</span><span class="symbol">:QueryLib</span><span class="symbol">:</span><span class="symbol">:Query</span> tq;</span><br><span class="line"><span class="regexp">//</span> we could define <span class="keyword">and</span> <span class="keyword">use</span> an <span class="keyword">alias</span> <span class="keyword">for</span> <span class="symbol">cplusplus_primer:</span><span class="symbol">:QueryLib</span></span><br><span class="line">namespace <span class="constant">Qlib </span>= <span class="symbol">cplusplus_primer:</span><span class="symbol">:QueryLib</span>;</span><br><span class="line"><span class="constant">Qlib:</span><span class="symbol">:Query</span> tq;</span><br></pre></td></tr></table></figure></p>
<p>It can be tempting to write programs with  using directives, but doing so reintroduces all the problems inherent in name collisions<br>when using multiple libraries.</p>
<p>The scope of names introduced by a using directive is more complicated than those for using declarations. A using declaration puts the name directly in the same scope in which the using declaration itself appears. It is as if the using declaration is a local alias for the namespace member.</p>
<p>A using directive does not declare local aliases for the namespace member names. Rather, <code>it has the effect of lifting the namespace
members into the nearest scope that contains both the namespace itself and the using directive</code>. One place where using directives are useful is in the implementation files for the namespace itself.<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">namespace</span> <span class="keyword">blip </span>&#123;</span><br><span class="line">    int <span class="keyword">bi </span>= <span class="number">16</span>, <span class="keyword">bj </span>= <span class="number">15</span>, <span class="keyword">bk </span>= <span class="number">23</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="label">int</span> <span class="keyword">bj </span>= <span class="number">0</span><span class="comment">; // ok: bj inside blip is hidden inside a namespace</span></span><br><span class="line"><span class="label">void</span> manip()</span><br><span class="line">&#123;</span><br><span class="line">    // using directive - names in <span class="keyword">blip </span><span class="string">"added"</span> to <span class="preprocessor">global</span> scope</span><br><span class="line">    using namespace <span class="keyword">blip;</span><br><span class="line"></span>                    // clash <span class="keyword">between </span>::<span class="keyword">bj </span><span class="keyword">and </span><span class="keyword">blip::bj</span><br><span class="line"></span>                    // detected only <span class="preprocessor">if</span> <span class="keyword">bj </span>is used</span><br><span class="line">    ++<span class="keyword">bi; </span>          // <span class="preprocessor">sets</span> <span class="keyword">blip::bi </span>to <span class="number">17</span></span><br><span class="line">    ++<span class="keyword">bj; </span>          // error: ambiguous</span><br><span class="line">                    // <span class="preprocessor">global</span> <span class="keyword">bj </span>or <span class="keyword">blip::bj?</span><br><span class="line"></span>    ++::<span class="keyword">bj; </span>        // ok: <span class="preprocessor">sets</span> <span class="preprocessor">global</span> <span class="keyword">bj </span>to <span class="number">1</span></span><br><span class="line">    ++<span class="keyword">blip::bj; </span>    // ok: <span class="preprocessor">sets</span> <span class="keyword">blip::bj </span>to <span class="number">16</span></span><br><span class="line">    int <span class="keyword">bk </span>= <span class="number">97</span><span class="comment">;    // local bk hides blip::bk</span></span><br><span class="line">    ++<span class="keyword">bk; </span>          // <span class="preprocessor">sets</span> local <span class="keyword">bk </span>to <span class="number">98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>It is possible for names in the namespace to conflict with other names defined in the enclosing scope. For example, the blip member bj appears to manip as if it were declared at global scope. However, there is another object named bj in global scope. Such conflicts are permitted; but to use the name, we must explicitly indicate which version is wanted. Therefore, the use of bj within manip is ambiguous: The name refers both to the global variable and to the member of namespace blip.</p>
<h2 id="4-_Example">4. Example</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Exercise &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> dvar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> limit = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ivar = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// position 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// position 2</span></span><br><span class="line">    <span class="keyword">double</span> dvar = <span class="number">3.1416</span>;</span><br><span class="line">    <span class="keyword">int</span> iobj = limit + <span class="number">1</span>;</span><br><span class="line">    ++ivar;</span><br><span class="line">    ++::ivar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What are the effects of the declarations and expressions in this code sample if  using declarations for all the members of namespace Exercise are located at the location labeled position 1? At position 2 instead? Now answer the same question but replace the using declarations with a using directive for namespace Exercise.<br>解答:如果Exercise的所有成员使用using声明放在position 1，则 using Exercise::ivar导致重复定义的错误。manip中的dvar会屏蔽Exercise::dvar。如果Exercise的所有成员使用using声明放在position 2，manip中的dvar会出现重复定义的错误。++ivar访问到的是Exercise::ivar，++::ivar访问的是全部变量ivar。如果Exercise的所有成员使用using指示放在position 1，则 ++ivar;会导致二义性错误。如果Exercise的所有成员使用using指示放在position 2， ++ivar;依然会导致二义性错误。</p>
<h2 id="5-_Caution:_Avoid_Using_Directives">5. Caution: Avoid Using Directives</h2><p>using directives, which inject all the names from a namespace, are deceptively simple to use: With only a single statement, all the member names of a namespace are suddenly visible. Although this approach may seem simple, it can introduce its own problems. If an application uses many libraries, and if the names within these libraries are made visible with using directives, then we are back to square one, and the global namespace pollution problem reappears.</p>
<p>Moreover, it is possible that a working program will fail to compile when a new version of the library is introduced. This problem can arise if a new version introduces a name that conflicts with a name that the application is using.</p>
<p>Another problem is that ambiguity errors caused by using directives are detected only at the point of use. This late detection means that conflicts can arise long after introducing a particular library. If the program begins using a new part of the library, previously undetected collisions may arise.</p>
<p>Rather than relying on a using directive, it is better to use a  using declaration for each namespace name used in the program. Doing so reduces the number of names injected into the namespace. Ambiguity errors caused by using declarations are detected at the point of declaration, not use, and so are easier to find and fix.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/19/c-primer笔记20-namespace/" data-id="cinvexix00021tw3aq5hefepn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记19-exception" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/c-primer笔记19-exception/" class="article-date">
  <time datetime="2016-03-18T14:38:16.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/c-primer笔记19-exception/">c++ primer笔记19: exception</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Exception_Specifications">1. Exception Specifications</h2><p>An exception specification specifies that if the function throws an exception, the exception it throws will be one of the exceptions included in the specification, or it will be a type derived from one of the listed exceptions. An exception specification follows the function parameter list. An exception specification is the keyword throw followed by a (possibly empty) list of exception types enclosed in parentheses: <code>void recoup(int) throw(runtime_error);</code> An empty specification list says that the function does not throw any exception:<code>void no_problem() throw();</code> An exception specification is part of the function’s interface. The function definition and any declarations of the function must have the same specification. If a function declaration does not specify an exception specification, the function can throw exceptions of any type.</p>
<p>Unfortunately, it is not possible to know at compile time whether or which exceptions a program will throw. Violations of a function’s exception specification can be detected only at run time. If a function throws an exception not listed in its specification, the library function  unexpected is invoked. By default,  unexpected calls  terminate , which ordinarily aborts the program.</p>
<p>Specifying that a function will not  throw any exceptions can be helpful both to users of the function and to the compiler: Knowing that a function will not throw simplifies the task of writing exception-safe code that calls that function. We can know that we need not worry about exceptions when calling it. Moreover, if the compiler knows that no exceptions will be thrown, it can perform optimizations that are suppressed for code that might throw.</p>
<h2 id="2-_Exception_Specifications_and_Member_Functions">2. Exception Specifications and Member Functions</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> bad_alloc : <span class="keyword">public</span> exception &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        bad_alloc() <span class="keyword">throw</span>();</span><br><span class="line">        bad_alloc(<span class="keyword">const</span> bad_alloc &amp;) <span class="keyword">throw</span>();</span><br><span class="line">        bad_alloc &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> bad_alloc &amp;) <span class="keyword">throw</span>();</span><br><span class="line">        <span class="keyword">virtual</span> ~bad_alloc() <span class="keyword">throw</span>();</span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* what() <span class="function"><span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Notice that the exception specification follows the const qualifier in const member function declarations.</p>
<h2 id="3-_Exception_Specifications_and_Destructors">3. Exception Specifications and Destructors</h2><p>The above isbn_mismatch class defines its destructor as<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> isbn_mismatch: <span class="keyword">public</span> <span class="built_in">std</span>::logic_error &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~isbn_mismatch() <span class="keyword">throw</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The isbn_mismatch class inherits from logic_error , which is one of the standard exception classes. The destructors for the standard exception classes include an empty throw() specifier; they promise that they will not throw any exceptions. When we inherit from one of these classes, then our destructor must also promise not to throw any exceptions.</p>
<p>Our out_of_stock class had no members, and so its synthesized destructor does nothing that might throw an exception. Hence, the compiler can know that the synthesized destructor will abide by the promise not to throw.</p>
<p>The isbn_mismatch class has two members of class string, which means that the synthesized destructor for isbn_mismatch calls the string destructor. The C++ standard stipulates that string destructor, like any other library class destructor, will not throw an exception. However, the library destructors do not define exception specifications. In this case, we know, but the compiler doesn’t, that the string destructor won’t throw. We must define our own destructor to reinstate the promise that the destructor will not throw.</p>
<h2 id="4-_Exception_Specifications_and_Virtual_Functions">4. Exception Specifications and Virtual Functions</h2><p>A virtual function in a base class may have an exception specification that differs from the exception specification of the corresponding virtual in a derived class. However, the exception specification of a derived-class virtual function must be either equally or more restrictive than the exception specification of the corresponding base-class virtual function.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span> <span class="title">throw</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span> <span class="params">(<span class="built_in">std</span>::logic_error)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">f3</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(<span class="built_in">std</span>::logic_error, <span class="built_in">std</span>::runtime_error)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// error: exception specification is less restrictive than Base::f1's</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span> <span class="title">throw</span> <span class="params">(<span class="built_in">std</span>::underflow_error)</span></span>;</span><br><span class="line">        <span class="comment">// ok: same exception specification as Base::f2</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span> <span class="params">(<span class="built_in">std</span>::logic_error)</span></span>;</span><br><span class="line">        <span class="comment">// ok: Derived f3 is more restrictive</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">f3</span><span class="params">()</span> <span class="title">throw</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>By restricting which exceptions the derived classes will throw to those listed by the base class, we can write our code knowing what exceptions we must handle.</p>
<h2 id="5-_Function_Pointer_Exception_Specifications">5. Function Pointer Exception Specifications</h2><p>An exception specification is part of a function type. As such, exception specifications can be provided in the definition of a pointer to function:<code>void (*pf)(int) throw(runtime_error);</code> When a pointer to function with an exception specification is initialized from (or assigned to) another pointer (or to the address of a function), the exception specifications of both pointers do not have to be identical. However, the specification of the source pointer must be at least as restrictive as the specification of the destination pointer.<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> recoup(<span class="keyword">int</span>) <span class="keyword">throw</span>(runtime_error);</span><br><span class="line"><span class="comment">// ok: recoup is as restrictive as pf1</span></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>) <span class="keyword">throw</span>(runtime_error) = recoup;</span><br><span class="line"><span class="comment">// ok: recoup is more restrictive than pf2</span></span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) <span class="keyword">throw</span>(runtime_error, logic_error) = recoup;</span><br><span class="line"><span class="comment">// error: recoup is less restrictive than pf3</span></span><br><span class="line"><span class="keyword">void</span> (*pf3)(<span class="keyword">int</span>) <span class="keyword">throw</span>() = recoup;</span><br><span class="line"><span class="comment">// ok: recoup is more restrictive than pf4</span></span><br><span class="line"><span class="keyword">void</span> (*pf4)(<span class="keyword">int</span>) = recoup;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/18/c-primer笔记19-exception/" data-id="cinvexix90025tw3a1sfrfdlt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记18-exception" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/c-primer笔记18-exception/" class="article-date">
  <time datetime="2016-03-18T10:57:33.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/c-primer笔记18-exception/">c++ primer笔记18: exception</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Standard_exception_Class_Hierarchy">1. Standard  exception Class Hierarchy</h2><p><img src="/img/exception.PNG" alt=""></p>
<h2 id="2-_User-Defined_Exception_Types">2. User-Defined Exception Types</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> out_of_stock: <span class="keyword">public</span> <span class="built_in">std</span>::runtime_error &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">out_of_stock</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>:<span class="built_in">std</span>::<span class="title">runtime_error</span><span class="params">(s)</span> </span><br><span class="line">    </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> isbn_mismatch: <span class="keyword">public</span> <span class="built_in">std</span>::logic_error &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">isbn_mismatch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>: <span class="built_in">std</span>::<span class="title">logic_error</span><span class="params">(s)</span> </span><br><span class="line">        </span>&#123; &#125;</span><br><span class="line">        isbn_mismatch(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;rhs):</span><br><span class="line">                                        <span class="built_in">std</span>::logic_error(s), left(lhs), right(rhs) &#123; &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> left, right;</span><br><span class="line">        <span class="keyword">virtual</span> ~isbn_mismatch() <span class="keyword">throw</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-_Automatic_Resource_Deallocation">3. Automatic Resource Deallocation</h2><p>We know that local objects are automatically destroyed when an exception occurs. The fact that destructors are run has important implication for the design of applications.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v; <span class="comment">// local vector</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">        v.push_back(s); <span class="comment">// populate the vector</span></span><br><span class="line">        <span class="built_in">string</span> *p = <span class="keyword">new</span> <span class="built_in">string</span>[v.size()]; <span class="comment">// dynamic array</span></span><br><span class="line">        <span class="comment">// remaining processing</span></span><br><span class="line">        <span class="comment">// it is possible that an exception occurs in this code</span></span><br><span class="line">        <span class="comment">// function cleanup is bypassed if an exception occurs</span></span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125; <span class="comment">// v destroyed automatically when the function exits</span></span><br></pre></td></tr></table></figure></p>
<p>If an exception occurs inside the function, then the vector will be destroyed but the array will not be freed. The problem is that the array is not freed automatically. No matter when an exception occurs, we are guaranteed that the  vector destructor is run.</p>
<h2 id="4-_Using_Classes_to_Manage_Resource_Allocation">4. Using Classes to Manage Resource Allocation</h2><p>The fact that destructors are run leads to an important programming technique that makes programs more exception safe . By exception safe, we mean that the programs operate correctly even if an exception occurs. In this case, the “safety” comes from ensuring that any resouce that is allocated is properly freed if an exception occurs. We can guarantee that resources are properly freed by defining a class to encapsulate the acquisition and release of a resource.</p>
<h2 id="5-_The_auto_ptr_Class">5. The auto_ptr Class</h2><p>The standard-library auto_ptr class is an example of the exception-safe “resource allocation is initialization” technique. The aut_ptr class is a template that takes a single type parameter. It provides exception safety for dynamically allocated<br>objects. The auto_ptr class is defined in the  memory header. auto_ptr can be used only to manage single objects returned from<br>new. It does not manage dynamically allocated arrays. As we’ll see, auto_ptr has unusual behavior when copied or assigned. As a result, auto_ptrs may not be stored in the library container types.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">// dynamically allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">    <span class="keyword">delete</span> ip; <span class="comment">// return the memory before exiting</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// allocate a new object</span></span><br><span class="line"><span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auto_ptr freed automatically when function ends</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Class auto_ptr</th>
<th>&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>auto_ptr&lt;T&gt;     ap</code></td>
<td>Create an unbound  auto_ptr named ap.</td>
</tr>
<tr>
<td><code>auto_ptr&lt;T&gt; ap(p)</code></td>
<td>Create an  auto_ptr named ap that owns the object pointed to by the pointer  p. This constructor is explicit.</td>
</tr>
<tr>
<td><code>auto_ptr&lt;T&gt; ap1(ap2)</code></td>
<td>Create an  auto_ptr named ap1 that holds the pointer originally stored in ap2. Transfers ownership to ap1;  ap2 becomes an unbound auto_ptr.</td>
</tr>
<tr>
<td>ap1 = ap2</td>
<td>Transfers ownership from ap2 to ap1. Deletes the object to which ap1 points and makes ap1 point to the object to which  ap2 points, making ap2 unbound.</td>
</tr>
<tr>
<td>~ap</td>
<td>Destructor. Deletes the object to which ap points.</td>
</tr>
<tr>
<td>*ap</td>
<td>Returns a reference to the object to which ap is bound.</td>
</tr>
<tr>
<td>ap-&gt;</td>
<td>Returns the pointer that ap holds.</td>
</tr>
<tr>
<td>ap.reset(p)</td>
<td>If the pointer p is not the same value as ap holds, then it deletes the object to which ap points and binds ap to p.</td>
</tr>
<tr>
<td>ap.release()</td>
<td>Returns the pointer that ap had held and makes ap unbound.</td>
</tr>
<tr>
<td>ap.get()</td>
<td>Returns the pointer that ap holds.</td>
</tr>
</tbody>
</table>
<p>To determine whether the auto_ptr object refers to an object, we can compare the return from <code>get</code> with 0. get should be used only to interrogate an auto_ptr or to use the returned pointer value.  get should not be used as an argument to create another auto_ptr. Using get member to initialize another auto_ptr violates the class design principle that only one auto_ptr holds a given pointer at any one time. If two auto_ptrs hold the same pointer, then the pointer will be  deleted twice.</p>
<h2 id="6-_Copy_and_Assignment_on_auto_ptr_Are_Destructive_Operations">6. Copy and Assignment on auto_ptr Are Destructive Operations</h2><p>When we copy an auto_ptr or assign its value to another auto_ptr, ownership of the underlying object is transferred from the original to the copy. The original auto_ptr is reset to an unbound state. Unlike other copy or assignment operations,  auto_ptr copy and assignment change the right-hand operand. As a result, both the left- and right-hand operands to assignment must be<br>modifiable lvalues. Because copy and assignment are destructive operations, auto_ptrs cannot be stored in the standard containers. The library container classes require that two objects be equal after a copy or assignment. This requirement is not met by auto_ptr. If we assign ap2 to ap1, then after the assignment  ap1 != ap2.</p>
<h2 id="7-_Caution:_Auto_ptr_Pitfalls">7. Caution:  Auto_ptr Pitfalls</h2><p>The auto_ptr class template provides a measure of safety and convenience for handling dynamically allocated memory. To use auto_ptr correctly, we must adhere to the restrictions that the class imposes:</p>
<ul>
<li>Do not use an auto_ptr to hold a pointer to a statically allocated object. Otherwise, when the auto_ptr itself is destroyed, it will attempt to delete a pointer to a nondynamically allocated object, resulting in undefined behavior.</li>
<li>Never use two auto_ptrs to refer to the same object. One obvious way to make this mistake is to use the same pointer to initialize or to reset two different auto_ptr objects. A more subtle way to make this mistake would be to use the result from  get on one auto_ptr to initialize or reset another.</li>
<li>Do not use an auto_ptr to hold a pointer to a dynamically allocated array. When the auto_ptr is destroyed, it frees only a single objectit uses the plain delete operator, not the array delete [] operator.</li>
<li>Do not store an auto_ptr in a container. Containers require that the types they hold define copy and assignment to behave similarly to how those operations behave on the built-in types: After the copy (or assignment), the two objects must have the same value. auto_ptr does not meet this requirement.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/18/c-primer笔记18-exception/" data-id="cinvexixb0027tw3a5fuup3ps" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记17-exception" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/c-primer笔记17-exception/" class="article-date">
  <time datetime="2016-03-18T08:12:04.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/c-primer笔记17-exception/">c++ primer笔记17: exception</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Exception_Handling">1. Exception Handling</h2><p>Exception handling relies on the problem-detecting part throwing an object to a handler. The type and contents of that object allow the two parts to communicate about what went wrong.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_item <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_item&amp; lhs, <span class="keyword">const</span> Sales_item&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs.same_isbn(rhs))</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="function">Sales_item <span class="title">ret</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    ret += rhs;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_item item1, item2, sum;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sum = item1 + item2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> runtime_error &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">" Try again.\n"</span></span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_Throwing_an_Exception_of_Class_Type">2. Throwing an Exception of Class Type</h2><p>An exception is raised by throwing an object. The type of that object determines which handler will be invoked. The selected handler is the one nearest in the call chain that matches the type of the object.</p>
<p>Exceptions are thrown and caught in ways that are similar to how arguments are passed to functions. An exception can be an object of any type that can be passed to a nonreference parameter, meaning that it must be possible to copy objects of that type. Recall that when we pass an argument of array or function type, that argument is automatically converted to an pointer. The same automatic conversion happens for objects that are thrown. As a consequence, there are no exceptions of array or function types. Instead, if we  throw an array, the thrown object is converted to a pointer to the first element in the array. Similarly, if we throw a function, the function is converted to a pointer to the function. The fact that control passes from one location to another has two important implications:</p>
<ul>
<li>Functions along the call chain are prematurely exited. Following section discusses what happens when functions are exited due to an exception.</li>
<li>In general, the storage that is local to a block that throws an exception is not around when the exception is handled.</li>
</ul>
<p>Because local storage is freed while handling an exception, the object that is thrown is not stored locally. Instead, the  throw expression is used to initialize a special object referred to as the exception object . The exception object is managed by the compiler and is guaranteed to reside in space that will be accessible to whatever  catch is invoked. This object is created by a<br>throw , and is initialized as a copy of the expression that is thrown. The exception object is passed to the corresponding  catch and is destroyed after the exception is completely handled. The exception object is created by copying the result of the thrown<br>expression; that result must be of a type that can be copied. What’s important to know is how the form of the throw expression interacts with types related by inheritance. When an exception is thrown, the static, compile-time type of the thrown object determines the type of the exception object.</p>
<p>The one case where it matters that a throw expression throws the static type is if we dereference a pointer in a throw. The result of dereferencing a pointer is an object whose type matches the type of the pointer. If the pointer points to a type from an inheritance hierarchy, it is possible that the type of the object to which the pointer points is different from the type of<br>the pointer. Regardless of the object’s actual type, the type of the exception object matches the static type of the pointer. If that pointer is a base-class type pointer that points to a derived-type object, then that object is sliced down; only the base-class part is thrown.</p>
<p>In particular, it is always an error to throw a pointer to a local object for the same reasons as it is an error to return a pointer to a local object from a function. It is usually a bad idea to  tHRow a pointer: Throwing a pointer requires that the object to which the pointer points exist wherever the corresponding handler resides.</p>
<h2 id="3-_Stack_Unwinding">3. Stack Unwinding</h2><p>When an exception is thrown, execution of the current function is suspended and the search begins for a matching  catch clause. The search starts by checking whether the  tHRow itself is located inside a try block. If so, the catch clauses associated with that try are examined to see if one of them matches the thrown object. If a matching  catch is found, the exception is<br>handled. If no catch is found, the current function is exitedits memory is freed and local objects are destroyed and the search continues in the calling function.</p>
<p>If the call to the function that threw is in a  try block, then the  catch clauses associated with that try are examined. If a matching  catch is found, the exception is handled. If no matching catch is found, the calling function is also exited, and the search continues in the function that called this one.</p>
<p>This process, known as stack unwinding, continues up the chain of nested function calls until a catch clause for the exception is found. As soon as a catch clause that can handle the exception is found, that  catch is entered, and execution continues within this handler. When the catch completes, execution continues at the point immediately after the last  catch clause associated with that try block.</p>
<p>When a function is exited due to an exception, the compiler guarantees that the local objects are properly destroyed. During stack unwinding, the memory used by local objects is freed and destructors for local objects of class type are run.</p>
<p>Destructors are often executed during stack unwinding. When destructors are executing, the exception has been raised but not yet handled. While stack unwinding is in progress for an exception, a destructor that throws another exception of its own that it does not also handle, causes the library  terminate function is called. Ordinarily,  terminate calls  abort , forcing an abnormal exit from the entire program. Because terminate ends the program, it is usually a very bad idea for a destructor to do anything that might cause an exception. The standard library types all guarantee that their destructors will not raise an exception.</p>
<p>Unlike destructors, it is often the case that something done inside a constructor might throw an exception. If an exception occurs while constructing an object, then the object might be only partially constructed. Some of its members might have been initialized, and others might not have been initialized before the exception occurs. Even if the object is only partially constructed, we are guaranteed that the constructed members will be properly destroyed. Similarly, an exception might occur when initializing the elements of an array or other container type. Again, we are guaranteed that the constructed elements will be destroyed.</p>
<p>uncaught exceptions terminate the program.</p>
<h2 id="3-_Catching_an_Exception">3. Catching an Exception</h2><p>The exception specifier in a catch clause looks like a parameter list that contains exactly one parameter. The exception specifier is a type name followed by an optional parameter name. During the search for a matching  catch , the catch that is found is not necessarily the one that matches the exception best. Instead, the  catch that is selected is the first  catch found that can<br>handle the exception. As a consequence, in a list of  catch clauses, the most specialized  catch must appear first. Most conversions are not allowed the types of the exception and the catch specifier must match exactly with only a few possible differences:</p>
<ul>
<li>Conversions from non const to  const are allowed. That is, a  throw of a non const object can match a catch specified to take a  const reference.</li>
<li>Conversions from derived type to base type are allowed.</li>
<li>An array is converted to a pointer to the type of the array; a function is converted to the appropriate pointer to function type.</li>
</ul>
<p>In particular, neither the standard arithmetic conversions nor conversions defined for class types are permitted.</p>
<p>When a catch is entered, the  catch parameter is initialized from the exception object. As with a function parameter, the exception-specifier type might be a reference. The exception object itself is a copy of the object that was thrown. Whether the exception object is copied again into the catch site depends on the exception-specifier type. Like a parameter declaration, an exception specifier for a base class can be used to  catch an exception object of a derived type. Usually, a catch clause that handles an exception of a type related by inheritance ought to define its parameter as a reference. Because objects (as opposed to references) are not polymorphic.</p>
<p>Because catch clauses are matched in the order in which they appear, programs that use exceptions from an inheritance hierarchy must order their  catch clauses so that handlers for a derived type occurs before a  catch for its base type.</p>
<h2 id="4-_Rethrow">4. Rethrow</h2><p>A catch can pass the exception out to another  catch further up the list of function calls by rethrowing the exception. A rethrow is a  throw that is not followed by a type or an expression: throw; An empty throw can appear only in a catch or in a function called (directly or indirectly) from a  catch. If an empty throw is encountered when a handler is not active,  terminate is called.</p>
<p>The exception that is thrown is the original exception object, not the catch parameter. When a  catch parameter is a base type, then we cannot know the actual type thrown by a rethrow expression. That type depends on the dynamic type of the exception object, not the static type of the catch parameter. In general, a  catch might change its parameter. If, after changing its parameter, the  catch rethrows the exception, then those changes will be propagated only if the exception specifier is a reference:<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (my_error &amp;eObj) &#123; <span class="comment">// specifier is a reference type</span></span><br><span class="line">    eObj.status = severeErr; <span class="comment">// modifies the exception object</span></span><br><span class="line">    <span class="keyword">throw</span>; <span class="comment">// the status member of the exception object is severeErr</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (other_error eObj) &#123; <span class="comment">// specifier is a nonreference type</span></span><br><span class="line">    eObj.status = badErr; <span class="comment">// modifies local copy only</span></span><br><span class="line">    <span class="keyword">throw</span>; <span class="comment">// the status member of the exception rethrown is unchanged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-_The_Catch-All_Handler">5.  The Catch-All Handler</h2><p>A  catch(…) is often used in combination with a rethrow expression. The  catch does whatever local work can be done and then rethrows the exception:<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// actions that cause an exception to be thrown</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// work to partially handle the exception</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-_Function_Try_Blocks_and_Constructors">6. Function Try Blocks and Constructors</h2><p>Constructor initializers are processed before the constructor body is entered. A catch clause inside the constructor body cannot handle an exception that might occur while processing a constructor initializer. To handle an exception from a constructor initializer, we must write the constructor as a function try block.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="type">Handle</span>&lt;T&gt;::<span class="type">Handle</span>(T *p)</span><br><span class="line"><span class="keyword">try</span> : <span class="keyword">ptr</span>(p), use(new size_t(<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    // empty function body</span><br><span class="line">&#125; </span><br><span class="line">catch(<span class="keyword">const</span> std::bad_alloc &amp;e)</span><br><span class="line">&#123; </span><br><span class="line">    handle_out_of_memory(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/18/c-primer笔记17-exception/" data-id="cinvexixe0029tw3ag8824yyl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记16-pointer-to-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/16/c-primer笔记16-pointer-to-function/" class="article-date">
  <time datetime="2016-03-16T06:04:22.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/c-primer笔记16-pointer-to-function/">c++ primer笔记16: pointer to function</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Pointers_to_Functions">1. Pointers to Functions</h2><p>A function’s type is determined by its return type and its parameter list. A function’s name is not part of its type:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pf points to function returning bool that takes two const string references</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parentheses around  *pf are necessary</span></span><br><span class="line"><span class="comment">// declares a function named pf that returns a bool*</span></span><br><span class="line"><span class="keyword">bool</span> *pf(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_Initializing_and_Assigning_Pointers_to_Functions">2. Initializing and Assigning Pointers to Functions</h2><p>When we use a function name without calling it, the name is automatically treated as a pointer to a function.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cmpFcn pf1 = lengthCompare;  \\  automatically converted to a function pointer</span><br><span class="line">cmpFcn pf2 = &amp;lengthCompare;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::<span class="keyword">size_t</span><span class="function">ype <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cstringCompare</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="comment">// pointer to function returning bool taking two const string&amp;</span></span><br><span class="line">cmpFcn pf;</span><br><span class="line">pf = sumLength; <span class="comment">// error: return type differs</span></span><br></pre></td></tr></table></figure></p>
<p>A pointer to a function can be used to call the function to which it refers. We can use the pointer directly there is no need to use the dereference operator to call the function<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line">cmpFcn pf = lengthCompare;</span><br><span class="line">lengthCompare<span class="params">(<span class="string">"hi"</span>, <span class="string">"bye"</span>)</span>; <span class="comment">// direct call</span></span><br><span class="line">pf<span class="params">(<span class="string">"hi"</span>, <span class="string">"bye"</span>)</span>; <span class="comment">// equivalent call: pf1 implicitly dereferenced</span></span><br><span class="line"><span class="params">(*pf)</span><span class="params">(<span class="string">"hi"</span>, <span class="string">"bye"</span>)</span>; <span class="comment">// equivalent call: pf1 explicitly dereferenced</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-_Function_Pointer_Parameters">3. Function Pointer Parameters</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;,</span><br><span class="line">                        <span class="keyword">bool</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;,</span><br><span class="line">                        <span class="keyword">bool</span> (*)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="4-_Returning_a_Pointer_to_Function">4. Returning a Pointer to Function</h2><p><code>int (*ff(int))(int*, int)</code>, The best way to read function pointer declarations is from the inside out, starting with the name being declared. Typedefs can make such declarations considerably easier to read:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PF is a pointer to a function returning an int, taking an int* and an int</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// ff returns a pointer to function</span></span><br></pre></td></tr></table></figure></p>
<p>We can define a parameter as a function type. A function return type must be a pointer to function; it cannot be a function. An argument to a parameter that has a function type is automatically converted to the corresponding pointer to function type. The same conversion does not happen when returning a function:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">// func is a <span class="function"><span class="keyword">function</span></span> <span class="keyword">type</span>, not a <span class="type">pointer</span> to <span class="function"><span class="keyword">function</span></span><span class="comment">!</span></span><br><span class="line">typedef <span class="built_in">int</span> func(<span class="built_in">int</span>*, <span class="built_in">int</span>);</span><br><span class="line">void f1(func); // ok: f1 has a <span class="type">parameter</span> of <span class="function"><span class="keyword">function</span></span> <span class="keyword">type</span></span><br><span class="line">func f2(<span class="built_in">int</span>); // error: f2 has a <span class="keyword">return</span> <span class="keyword">type</span> of <span class="function"><span class="keyword">function</span></span> <span class="keyword">type</span></span><br><span class="line">func *f3(<span class="built_in">int</span>); // ok: f3 returns a <span class="type">pointer</span> to <span class="function"><span class="keyword">function</span></span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/16/c-primer笔记16-pointer-to-function/" data-id="cinvexixh002btw3a2shhua8w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/c-primer笔记15/" class="article-date">
  <time datetime="2016-03-15T13:11:38.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/c-primer笔记15/">c++ primer笔记15</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_***_Overloading_and_Function_Templates_***">1. *** Overloading and Function Templates ***</h2><p>A function template can be overloaded: We can define multiple function templates with the same name but differing numbers or types of parameters. We also can define ordinary nontemplate functions with the same name as a function template. However, overloaded function templates may lead to ambiguities. The steps used to resolve a call to an overloaded function in which there are both ordinary functions and function templates are as follows:</p>
<ul>
<li>Build the set of candidate functions for this function name, including:<br>  a. Any ordinary function with the same name as the called function.<br>  b. Any function-template instantiation for which template argument deduction finds template arguments that match the function arguments used in the call.</li>
<li>Determine which, if any, of the ordinary functions are viable. Each template instance in the candidate set is viable, because template argument deduction ensures that the function could be called.</li>
<li>Rank the viable functions by the kinds of conversions, if any, required to make the call, remembering that the conversions allowed to call an instance of a template function are limited.<br>  a. If only one function is selected, call this function.<br>  b. If the call is ambiguous, remove any function template instances from the set of viable functions.</li>
<li>Rerank the viable functions excluding the function template instantiations.<br>  a. If only one function is selected, call this function.<br>  b. Otherwise, the call is ambiguous.</li>
</ul>
<h2 id="2-_An_Example_of_Function-Template_Matching">2. An Example of Function-Template Matching</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt; <span class="type">int</span> compare(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;class U, class V&gt; <span class="type">int</span> compare(U, U, V);</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> <span class="type">char</span>*, <span class="keyword">const</span> <span class="type">char</span>*);</span><br><span class="line"></span><br><span class="line">// calls compare(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;) <span class="keyword">with</span> T bound to <span class="type">int</span></span><br><span class="line">compare(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">// calls compare(U, U, V), <span class="keyword">with</span> U <span class="keyword">and</span> V bound to vector&lt;<span class="type">int</span>&gt;::<span class="keyword">iterator</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec1(<span class="number">10</span>), ivec2(<span class="number">20</span>);</span><br><span class="line">compare(ivec1.begin(), ivec1.<span class="keyword">end</span>(), ivec2.begin());</span><br><span class="line"><span class="type">int</span> ia1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">// calls compare(U, U, V) <span class="keyword">with</span> U bound to <span class="type">int</span>* <span class="keyword">and</span> V bound to vector&lt;<span class="type">int</span>&gt;::<span class="keyword">iterator</span></span><br><span class="line">compare(ia1, ia1 + <span class="number">10</span>, ivec1.begin());</span><br><span class="line"></span><br><span class="line">// calls the ordinary function taking <span class="keyword">const</span> <span class="type">char</span>* parameters</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> const_arr1[] = <span class="string">"world"</span>, const_arr2[] = <span class="string">"hi"</span>;</span><br><span class="line">compare(const_arr1, const_arr2);</span><br><span class="line"></span><br><span class="line">// calls the ordinary function taking <span class="keyword">const</span> <span class="type">char</span>* parameters</span><br><span class="line"><span class="type">char</span> ch_arr1[] = <span class="string">"world"</span>, ch_arr2[] = <span class="string">"hi"</span>;</span><br><span class="line">compare(ch_arr1, ch_arr2);</span><br></pre></td></tr></table></figure>
<p>再进行分析前，先看一个小例子：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">int <span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;v1)[3], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;v2)[3]);</span><br><span class="line">int <span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span> *v1, <span class="keyword">const</span> <span class="keyword">char</span> *v2);</span><br><span class="line">int main(int argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> array1[] = <span class="string">"wo"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> array2[] = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">compare</span>(array1, array2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">error</span>: call of overloaded ‘<span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span> [3], <span class="keyword">const</span> <span class="keyword">char</span> [3])’ is ambiguous</span><br><span class="line"><span class="keyword">note</span>: candidates are: int <span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[3], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[3])</span><br><span class="line"><span class="keyword">note</span>:                 int <span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span><br><span class="line"><span class="comment">// 即编译器认为这个两个函数是同样好的。</span></span><br></pre></td></tr></table></figure></p>
<p>compare(const_arr1, const_arr2)：它的candidates只有<code>int compare(const char*, const char*)</code>. 因为模板函数<code>int compare(const T&amp;, const T&amp;)</code>中的参数类型是引用，const_arr1的类型是const char[6]，const_arr2的类型是const char[3]，两个实参的类型不同，所以不能使用模板进行实例化。<br>compare(const_arr1, const_arr1)：它的candidates有<code>int compare(const char*, const char*)</code>和<code>int compare(const char (&amp;)[6], const char (&amp;)[6]</code>，由前面的例子可知，它们两个是一样好的，但是依据匹配规则，如果出现ambiguous的情况，则剔除由函数模板实例化而来的函数。<br>compare(ch_arr1, ch_arr2): 与<code>compare(const_arr1, const_arr2)</code>类似。</p>
<h2 id="3-_Conversions_and_Overloaded_Function_Templates">3. Conversions and Overloaded Function Templates</h2><p>Let’s look at two examples of why it is hard to design overloaded functions that work properly when there are both template and nontemplate versions in the overload set. First, consider a call to compare using pointers instead of the arrays themselves:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">char</span> *<span class="literal">p1</span> = ch_arr1, *<span class="literal">p2</span> = ch_arr2<span class="comment">;</span></span><br><span class="line"><span class="label">compare</span>(<span class="literal">p1</span>, <span class="literal">p2</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>This call matches the template version! Ordinarily, we expect to get the same function whether we pass an array or a pointer to an element to that array. In this case, however, the function template is an exact match for the call, binding  char<em> to  T. The plain version still requires a conversion from  char</em> to  const char* , so the function template is preferred. 此处没有理解啊？？？</p>
<p>Another change that has surprising results is what happens if the template version of  compare has a parameter of type T instead of a const reference to  T:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt; <span class="type">int</span> compare2(T, T);</span><br><span class="line"></span><br><span class="line">// calls compare(T, T) <span class="keyword">with</span> T bound to <span class="type">char</span>*</span><br><span class="line">compare(ch_arr1, ch_arr2);</span><br><span class="line">// calls compare(T, T) <span class="keyword">with</span> T bound to <span class="type">char</span>*</span><br><span class="line">compare(p1, p2);</span><br><span class="line">// calls the ordinary function taking <span class="keyword">const</span> <span class="type">char</span>*</span><br><span class="line">parameters compare(const_arr1, const_arr2);</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *cp1 = const_arr1, *cp2 = const_arr2;</span><br><span class="line">// calls the ordinary function taking <span class="keyword">const</span> <span class="type">char</span>* parameters</span><br><span class="line">compare(cp1, cp2);</span><br></pre></td></tr></table></figure></p>
<p>In these cases, the plain function and the function template are exact matches. As always, when the match is equally good, the nontemplate version is preferred.</p>
<p>It is hard to design overloaded function sets involving both function templates and nontemplate functions. Because of the likelihood of surprise to users of the functions, it is almost always better to define a function-template specialization than to use a nontemplate version.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/15/c-primer笔记15/" data-id="cinvexixq002dtw3aqtsybhtw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记14" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/c-primer笔记14/" class="article-date">
  <time datetime="2016-03-14T14:42:25.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/c-primer笔记14/">c++ primer笔记14</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Specializing_a_Class_Template">1. Specializing a Class Template</h2><p>Our Queue class has a problem similar to the one in compare when used with C-style strings. In this case, the problem is in the  push function. That function copies the value it’s given to create a new element in the Queue. By default, copying a C-style character string copies only the pointer, not the characters.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; class <span class="type">Queue</span>&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        // no copy control: <span class="type">Synthesized</span> versions work <span class="keyword">for</span> this class</span><br><span class="line">        // similarly, no need <span class="keyword">for</span> explicit default constructor either</span><br><span class="line">        <span class="type">void</span> push(<span class="keyword">const</span> <span class="type">char</span>*);</span><br><span class="line">        <span class="type">void</span> pop() &#123;real_queue.pop();&#125;</span><br><span class="line">        <span class="type">bool</span> empty() <span class="keyword">const</span> &#123;<span class="keyword">return</span> real_queue.empty();&#125;</span><br><span class="line">        // <span class="type">Note</span>: <span class="keyword">return</span> <span class="keyword">type</span> does <span class="keyword">not</span> match <span class="keyword">template</span> parameter <span class="keyword">type</span></span><br><span class="line">        std::<span class="type">string</span> front() &#123;<span class="keyword">return</span> real_queue.front();&#125;</span><br><span class="line">        <span class="keyword">const</span> std::<span class="type">string</span> &amp;front() <span class="keyword">const</span></span><br><span class="line">        &#123;<span class="keyword">return</span> real_queue.front();&#125;</span><br><span class="line">    private:</span><br><span class="line">        <span class="type">Queue</span>&lt;std::<span class="type">string</span>&gt; real_queue; // forward calls to real_queue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>It is worth noting that a specialization may define completely different members than the template itself. If a specialization fails to define a member from the template, that member may not be used on objects of the specilization type. The member definitions of the class template are not used to create the definitions for the members of an explicit specialization.</p>
<p>A class template specialization ought to define the same interface as the template it specializes. Doing otherwise will surprise users when they attempt to use a member that is not defined.</p>
<h2 id="2-_Class_Specialization_Definition">2. Class Specialization Definition</h2><p>When a member is defined outside the class specialization, it is not preceded by the tokens  template&lt;&gt;.<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Queue&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::push(<span class="keyword">const</span> <span class="keyword">char</span>* val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> real_queue.<span class="title">push</span><span class="params">(val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-_Specializing_Members_but_Not_the_Class">3. Specializing Members but Not the Class</h2><p>If we look a bit more deeply at our class, we can see that we can simplify our code: Rather than specializing the whole template, we can specialize just the  push and  pop members. We’ll specialize  push to copy the character array and  pop to free the memory we used for that copy:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Queue&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::push(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocate a new character array and copy characters from val</span></span><br><span class="line">    <span class="keyword">char</span>* new_item = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(val) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(new_item, val, <span class="built_in">strlen</span>(val) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// store pointer to newly allocated and initialized element</span></span><br><span class="line">    QueueItem&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; *pt = <span class="keyword">new</span> QueueItem&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(new_item);</span><br><span class="line">    <span class="comment">// put item onto existing queue</span></span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">        head = tail = pt; <span class="comment">// queue has only one element</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tail-&gt;next = pt; <span class="comment">// add new element to end of queue</span></span><br><span class="line">        tail = pt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Queue&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// remember head so we can delete it</span></span><br><span class="line">    QueueItem&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; *p = head;</span><br><span class="line">    <span class="keyword">delete</span> head-&gt;item; <span class="comment">// delete the array allocated in push</span></span><br><span class="line">    head = head-&gt;next; <span class="comment">// head now points to next element</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// delete old head element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_Specialization_Declarations">4. Specialization Declarations</h2><p>Member specializations are declared just as any other function template specialization. They must start with an empty template parameter list:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// push <span class="keyword">and</span> pop specialized <span class="keyword">for</span> <span class="keyword">const</span> <span class="type">char</span>*</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Queue</span>&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::push(<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span> &amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="type">Queue</span>&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::pop();</span><br></pre></td></tr></table></figure></p>
<h2 id="5-_***_Class-Template_Partial_Specializations_***">5. *** Class-Template Partial Specializations ***</h2><p>If a class template has more than one template parameter, we might want to specialize some but not all of the template parameters. We can do so using a class template partial specialization:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">T1</span>, class <span class="type">T2</span>&gt;</span><br><span class="line">class some_template</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        <span class="type">void</span> print()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">"hello"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// partial specialization: fixes <span class="type">T2</span> <span class="keyword">as</span> <span class="type">int</span> <span class="keyword">and</span> allows <span class="type">T1</span> to vary</span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">T1</span>&gt;</span><br><span class="line">class some_template&lt;<span class="type">T1</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>As with any other class template, a partial specialization is instantiated implicitly when used in a program:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">some_template&lt;<span class="type">int</span>, <span class="type">string</span>&gt; foo; // uses <span class="keyword">template</span></span><br><span class="line">some_template&lt;<span class="type">string</span>, <span class="type">int</span>&gt; bar; // uses partial specialization</span><br></pre></td></tr></table></figure></p>
<p>The definition of a partial specialization is completely disjointed from the definition of the generic template. The partial specialization may have a completely different set of members from the generic class template. The generic definitions for the members of a class template are never used to instantiate the members of the class template partial specialization.<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Demo&lt;<span class="type">double</span>, <span class="built_in">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">// error: ‘<span class="keyword">class</span> Demo&lt;<span class="type">double</span>, <span class="built_in">int</span>&gt;’ has no member <span class="keyword">named</span> ‘<span class="built_in">print</span>’</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/14/c-primer笔记14/" data-id="cinvexixx002ftw3acfxynp3t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/c-primer笔记13/" class="article-date">
  <time datetime="2016-03-14T10:21:27.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/c-primer笔记13/">c++ primer笔记13</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Defining_the_Generic_Handle_Class">1. Defining the Generic Handle Class</h2><p>To create a  Handle , a user will be expected to pass the address of a dynamically allocated object of the type (or a type<br>derived from that type) managed by the  Handle . From that point on, the  Handle will “own” the given object. In particular, the  Handle class will assume responsibility for deleting that object once there are no longer any  Handle s attached to it. Once an object is bound to a Handle, the user must not delete that object.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Handle &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// unbound handle</span></span><br><span class="line">        Handle(T *p = <span class="number">0</span>): ptr(p), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125;</span><br><span class="line">        <span class="comment">// overloaded operators to support pointer behavior</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*();</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">const</span> T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">        <span class="comment">// copy control: normal pointer behavior, but last Handle deletes the object</span></span><br><span class="line">        Handle(<span class="keyword">const</span> Handle&amp; h): ptr(h.ptr), use(h.use)</span><br><span class="line">        &#123; ++*use; &#125;</span><br><span class="line">        Handle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Handle&amp;);</span><br><span class="line">        ~Handle() &#123; rem_ref(); &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* ptr; <span class="comment">// shared object</span></span><br><span class="line">        <span class="keyword">size_t</span> *use; <span class="comment">// count of how many Handle spointto *ptr</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rem_ref</span><span class="params">()</span></span><br><span class="line">        </span>&#123; <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="keyword">delete</span> ptr; <span class="keyword">delete</span> use; &#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Handle&lt;T&gt;&amp; Handle&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Handle &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use; <span class="comment">// protect against self-assignment</span></span><br><span class="line">    rem_ref(); <span class="comment">// decrement use count and delete pointers if needed</span></span><br><span class="line">    ptr = rhs.ptr;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_Using_the_Handle">2. Using the Handle</h2><p>We intend this class to be used by other classes in their internal implementations. However, as an aid to understanding how the  Handle class works, we’ll look at a simpler example first. This example illustrates the behavior of the  Handle by allocating an  int and binding a Handle to that newly allocated object:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// new scope</span></span><br><span class="line">    <span class="comment">// user allocates but must not delete the object to which the Handle is attached</span></span><br><span class="line">    Handle&lt;<span class="keyword">int</span>&gt; hp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</span><br><span class="line">    &#123; <span class="comment">// new scope</span></span><br><span class="line">        Handle&lt;<span class="keyword">int</span>&gt; hp2 = hp; <span class="comment">// copies pointer; use count incremented</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *hp &lt;&lt; <span class="string">" "</span> &lt;&lt; *hp2 &lt;&lt; endl; <span class="comment">// prints 42 42</span></span><br><span class="line">        *hp2 = <span class="number">10</span>; <span class="comment">// changes value of shared underlying int</span></span><br><span class="line">    &#125; <span class="comment">// hp2 goes out of scope; use count is decremented</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *hp &lt;&lt; endl; <span class="comment">// prints 10</span></span><br><span class="line">&#125; <span class="comment">// hp goes out of scope; its destructor deletes the int</span></span><br></pre></td></tr></table></figure></p>
<p>As an example of using  Handle in a class implementation, we might reimplement our Sales_item class. This version of the class defines the same interface, but we can eliminate the copy-control members by replacing the pointer to Item_base by a Handle<item\_base>:<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        // <span class="keyword">default</span> constructor: unbound handle</span><br><span class="line">        Sales_item(): h() &#123; &#125;</span><br><span class="line">        <span class="comment">// copy item and attach handle to the copy</span></span><br><span class="line">        Sales_item(<span class="keyword">const</span> Item_base &amp;item): h(item.clone()) &#123; &#125;</span><br><span class="line">        <span class="comment">// no copy control members: synthesized versions work</span></span><br><span class="line">        <span class="comment">// member access operators: forward their work to the Handle class</span></span><br><span class="line">        <span class="keyword">const</span> Item_base&amp; operator*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *h; &#125;</span><br><span class="line">        <span class="keyword">const</span> Item_base* operator-&gt;() <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> h.operator-&gt;(); &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Handle&lt;Item_base&gt; h; <span class="comment">// use-counted handle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></item\_base></p>
<h2 id="3-_***_Template_Specializations_***">3. *** Template Specializations ***</h2><p>It is not always possible to write a single template that is best suited for every possible template argument with which the template might be instantiated. In some cases, the general template definition is simply wrong for a type. The general definition might not compile or might do the wrong thing. At other times, we may be able to take advantage of some specific knowledge<br>about a type to write a more efficient function than the one that is instantiated from the template. Let’s look again at our  compare function template. If we call this template definition on two  const char* arguments, the function compares the pointer values.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt;</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_Specializing_a_Function_Template">4. Specializing a Function Template</h2><p>A template spacialization is a separate definition in which the actual type(s) or value(s) of one or more template parameter(s) is (are) specified. The declaration for the specialization must match that of the corresponding template.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// special version <span class="keyword">of</span> compare to handle C-style character strings</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">int</span> compare&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;(<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span> &amp;v1,</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span> &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> strcmp(v1, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Now when we call  compare , passing it two character pointers, the compiler will call our specialized version. It will call the generic version for any other argument types (including plain char*,也就是说要完全匹配):<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp1 = <span class="string">"world"</span>, *cp2 = <span class="string">"hi"</span>;</span><br><span class="line">int i1, i2;</span><br><span class="line"><span class="keyword">compare</span>(cp1, cp2); <span class="comment">// calls the specialization</span></span><br><span class="line"><span class="keyword">compare</span>(i1, i2); <span class="comment">// calls the generic version instantiated with int</span></span><br></pre></td></tr></table></figure></p>
<p>As with any function, we can declare a function template specialization without defining it. A template specialization declaration looks like the definition but omits the function body. If the template arguments can be inferred from the function parameter<br>list, there is no need to explicitly specify the template arguments:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// error: invalid specialization declarations</span><br><span class="line">// missing <span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> compare&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;(<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp;, <span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">// error: function parameter list missing</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">int</span> compare&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;;</span><br><span class="line"></span><br><span class="line">// ok: explicit <span class="keyword">template</span> argument <span class="keyword">const</span> <span class="type">char</span>* deduced <span class="keyword">from</span> parameter types</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">int</span> compare(<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp;, <span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<h2 id="5-_Function_Overloading_versus_Template_Specializations">5. Function Overloading versus Template Specializations</h2><p>Omitting the empty template parameter list,  template&lt;&gt; , on a specialization may have surprising effects. If the specialization syntax is missing, then the effect is to declare an overloaded nontemplate version of the function:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">generic</span> <span class="keyword">template</span> definition</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> T&amp; t1, <span class="keyword">const</span> T&amp; t2) &#123; /* ... */ &#125;</span><br><span class="line">// <span class="type">OK</span>: ordinary function declaration</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp;, <span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>The definition of compare does not define a template specialization. Instead, it declares an ordinary function with a return type and a parameter list that could match those of a template instantiation.</p>
<p>We’ll look at the interaction of overloading and templates in more detail in the next section. For now, what’s important to know is that when we define a nontemplate function, normal conversions are applied to the arguments. When we specialize a template, conversions are not applied to the argument types. In a call to a specialized version of a template, the argument type(s) in the call must match the specialized version function parameter type(s) exactly. If they don’t, then the compiler will instantiate an instantiation for the argument(s) from the template definition.</p>
<p>If a program consists of more than one file, the declaration for a template specialization must be visible in every file in which the specialization is used. As with other function declarations, declarations for template specializations should be included in a header file. That header should then be included in every source file that uses the specialization.</p>
<h2 id="6-_Ordinary_Scope_Rules_Apply_to_Specializations">6. Ordinary Scope Rules Apply to Specializations</h2><p>Before we can declare or define a specialization, a declaration for the template that it specializes must be in scope. Similarly, a declaration for the specialization must be in scope before that version of the template is called:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// define the general compare <span class="keyword">template</span></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> T&amp; t1, <span class="keyword">const</span> T&amp; t2) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">// uses the <span class="keyword">generic</span> <span class="keyword">template</span> definition</span><br><span class="line"><span class="type">int</span> i = compare(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// invalid program: explicit specialization after call</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> compare&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;(<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp; s1, <span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>&amp; s2)</span><br><span class="line">&#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/14/c-primer笔记13/" data-id="cinvexixz002htw3a9g1klwwj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/c-primer笔记12/" class="article-date">
  <time datetime="2016-03-14T09:10:40.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/c-primer笔记12/">c++ primer笔记12</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Member_Templates">1. Member Templates</h2><p>Any class (template or otherwise) may have a member that is itself a class or function template. Such members are referred to as member templates. One example of a member template is the assign member of the standard containers. The version  assign that takes two iterators uses a template parameter to represent the type of its iterator parameters. Another member template example is the container constructor that takes two iterators. This constructor and the assign member allow containers to be built from sequences of different but compatible element types and/or different container types.</p>
<p>Consider the Queue copy constructor: It takes a single parameter that is a reference to a Queue<type> . If we wanted to create a  Queue by copying elements from a vector, we could not do so; there is no conversion from  vector to  Queue . Similarly, if we wanted to copy elements from a Queue<short> into a  Queue<int>, we could not do so. Again, even though we can convert a  short<br>to an  int , there is no conversion from  Queue<short> to  Queue<int>. The same logic applies to the Queue assignment operator, which also takes a parameter of type  Queue<type>&amp;.</type></int></short></int></short></type></p>
<p>The problem is that the copy constructor and assignment operator fix both the container and element type. We’d like to define a constructor and an  assign member that allow both the container and element type to vary. When we need a parameter type to vary, we need to define a function template. In this case, we’ll define the constructor and  assign member to take a pair ofiterators that denote a range in some other sequence. These functions will have a single template type parameter that represents an iterator type.</p>
<h2 id="2-_Defining_a_Member_Template">2. Defining a Member Template</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Queue</span> &#123;</span><br><span class="line">    public:</span><br><span class="line">        // construct a <span class="type">Queue</span> <span class="keyword">from</span> a pair <span class="keyword">of</span> iterators on some sequence</span><br><span class="line">        <span class="keyword">template</span> &lt;class <span class="type">It</span>&gt;</span><br><span class="line">        <span class="type">Queue</span>(<span class="type">It</span> beg, <span class="type">It</span> <span class="keyword">end</span>):</span><br><span class="line">        head(<span class="number">0</span>), tail(<span class="number">0</span>) &#123; copy_elems(beg, <span class="keyword">end</span>); &#125;</span><br><span class="line">        // replace current <span class="type">Queue</span> by contents delimited by a pair <span class="keyword">of</span> iterators</span><br><span class="line">        <span class="keyword">template</span> &lt;class <span class="type">Iter</span>&gt; <span class="type">void</span> assign(<span class="type">Iter</span>, <span class="type">Iter</span>);</span><br><span class="line">        // rest <span class="keyword">of</span> <span class="type">Queue</span> class <span class="keyword">as</span> before</span><br><span class="line">    private:</span><br><span class="line">        // version <span class="keyword">of</span> copy to be used by assign to copy elements <span class="keyword">from</span> <span class="keyword">iterator</span> <span class="type">range</span></span><br><span class="line">        <span class="keyword">template</span> &lt;class <span class="type">Iter</span>&gt; <span class="type">void</span> copy_elems(<span class="type">Iter</span>, <span class="type">Iter</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When we define a member template outside the scope of a class template, we must include both template parameter lists:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="keyword">template</span> &lt;class <span class="type">Iter</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Queue</span>&lt;T&gt;::assign(<span class="type">Iter</span> beg, <span class="type">Iter</span> <span class="keyword">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">    destroy(); // remove existing elements <span class="keyword">in</span> this <span class="type">Queue</span></span><br><span class="line">    copy_elems(beg, <span class="keyword">end</span>); // copy elements <span class="keyword">from</span> the input <span class="type">range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>When a member template is a member of a class template, then its definition must include the class-template parameters as well as its own template parameters. The class-template parameter list comes first, followed by the member’s own template parameter list. The definition of assign starts with <code>template &lt;class T&gt; template &lt;class Iter&gt;</code>.</p>
<h2 id="3-_Member_Templates_and_Instantiation">3. Member Templates and Instantiation</h2><p>Like any other member, a member template is instantiated only when it is used in a program. Member templates have two kinds of<br>template parameters: Those that are defined by the class and those defined by the member template itself. The class template parameters are fixed by the type of the object through which the function is called. The template parameters defined by the member act like parameters of ordinary function templates. These parameters are resolved through normal template argument deduction.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">short a[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">// instantiates <span class="type">Queue</span>&lt;<span class="type">int</span>&gt;::<span class="type">Queue</span>(short *, short *)</span><br><span class="line"><span class="type">Queue</span>&lt;<span class="type">int</span>&gt; qi(a, a + <span class="number">4</span>); // copies elements <span class="keyword">from</span> a into qi</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi(a, a + <span class="number">4</span>);</span><br><span class="line">// instantiates <span class="type">Queue</span>&lt;<span class="type">int</span>&gt;::assign(vector&lt;<span class="type">int</span>&gt;::<span class="keyword">iterator</span>,</span><br><span class="line">//                                          vector&lt;<span class="type">int</span>&gt;::<span class="keyword">iterator</span>)</span><br><span class="line">qi.assign(vi.begin(), vi.<span class="keyword">end</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_The_Complete_Queue_Class">4. The Complete Queue Class</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// declaration that <span class="type">Queue</span> <span class="keyword">is</span> a <span class="keyword">template</span> needed <span class="keyword">for</span> friend declaration <span class="keyword">in</span> <span class="type">QueueItem</span></span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Queue</span>;</span><br><span class="line">// function <span class="keyword">template</span> declaration must precede friend declaration <span class="keyword">in</span> <span class="type">QueueItem</span></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">    std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, <span class="keyword">const</span> <span class="type">Queue</span>&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">QueueItem</span> &#123;</span><br><span class="line">    friend class <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;;</span><br><span class="line">    // needs access to item <span class="keyword">and</span> next</span><br><span class="line">    friend std::ostream&amp; // defined on page <span class="number">659</span></span><br><span class="line">    operator&lt;&lt; &lt;<span class="type">Type</span>&gt; (std::ostream&amp;, <span class="keyword">const</span> <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;&amp;);</span><br><span class="line">    // private class: no public section</span><br><span class="line">    <span class="type">QueueItem</span>(<span class="keyword">const</span> <span class="type">Type</span> &amp;t): item(t), next(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="type">Type</span> item; // value stored <span class="keyword">in</span> this element</span><br><span class="line">    <span class="type">QueueItem</span> *next; // <span class="type">pointer</span> to next element <span class="keyword">in</span> the <span class="type">Queue</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Queue</span> &#123;</span><br><span class="line">    // needs access to head</span><br><span class="line">    friend std::ostream&amp; // defined on page <span class="number">659</span></span><br><span class="line">                operator&lt;&lt; &lt;<span class="type">Type</span>&gt; (std::ostream&amp;, <span class="keyword">const</span> <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;&amp;);</span><br><span class="line">    public:</span><br><span class="line">        // empty <span class="type">Queue</span></span><br><span class="line">        <span class="type">Queue</span>(): head(<span class="number">0</span>), tail(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        // construct a <span class="type">Queue</span> <span class="keyword">from</span> a pair <span class="keyword">of</span> iterators on some sequence</span><br><span class="line">        <span class="keyword">template</span> &lt;class <span class="type">It</span>&gt;</span><br><span class="line">        <span class="type">Queue</span>(<span class="type">It</span> beg, <span class="type">It</span> <span class="keyword">end</span>):</span><br><span class="line">                head(<span class="number">0</span>), tail(<span class="number">0</span>) &#123; copy_elems(beg, <span class="keyword">end</span>); &#125;</span><br><span class="line">        // copy control to manage pointers to <span class="type">QueueItems</span> <span class="keyword">in</span> the <span class="type">Queue</span></span><br><span class="line">        <span class="type">Queue</span>(<span class="keyword">const</span> <span class="type">Queue</span> &amp;Q): head(<span class="number">0</span>), tail(<span class="number">0</span>)</span><br><span class="line">        &#123; copy_elems(Q); &#125;</span><br><span class="line">        <span class="type">Queue</span>&amp; operator=(<span class="keyword">const</span> <span class="type">Queue</span>&amp;); // left <span class="keyword">as</span> exercise <span class="keyword">for</span> the reader</span><br><span class="line">        ~<span class="type">Queue</span>() &#123; destroy(); &#125;</span><br><span class="line">        // replace current <span class="type">Queue</span> by contents delimited by a pair <span class="keyword">of</span> iterators</span><br><span class="line">        <span class="keyword">template</span> &lt;class <span class="type">Iter</span>&gt; <span class="type">void</span> assign(<span class="type">Iter</span>, <span class="type">Iter</span>);</span><br><span class="line">        // <span class="keyword">return</span> element <span class="keyword">from</span> head <span class="keyword">of</span> <span class="type">Queue</span></span><br><span class="line">        // unchecked operation: front on an empty <span class="type">Queue</span> <span class="keyword">is</span> undefined</span><br><span class="line">        <span class="type">Type</span>&amp; front() &#123; <span class="keyword">return</span> head-&gt;item; &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">Type</span> &amp;front() <span class="keyword">const</span> &#123; <span class="keyword">return</span> head-&gt;item; &#125;</span><br><span class="line">        <span class="type">void</span> push(<span class="keyword">const</span> <span class="type">Type</span> &amp;);// defined on page <span class="number">652</span></span><br><span class="line">        <span class="type">void</span> pop(); // defined on page <span class="number">651</span></span><br><span class="line">        <span class="type">bool</span> empty() <span class="keyword">const</span> &#123; // <span class="literal">true</span> <span class="keyword">if</span> no elements <span class="keyword">in</span> the <span class="type">Queue</span></span><br><span class="line">        <span class="keyword">return</span> head == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        <span class="type">QueueItem</span>&lt;<span class="type">Type</span>&gt; *head; // <span class="type">pointer</span> to first element <span class="keyword">in</span> <span class="type">Queue</span></span><br><span class="line">        <span class="type">QueueItem</span>&lt;<span class="type">Type</span>&gt; *tail; // <span class="type">pointer</span> to last element <span class="keyword">in</span> <span class="type">Queue</span></span><br><span class="line">        // utility functions used by copy constructor, assignment, <span class="keyword">and</span> destructor</span><br><span class="line">        <span class="type">void</span> destroy(); // defined on page <span class="number">651</span></span><br><span class="line">        <span class="type">void</span> copy_elems(<span class="keyword">const</span> <span class="type">Queue</span>&amp;); // defined on page <span class="number">652</span></span><br><span class="line">        // version <span class="keyword">of</span> copy to be used by assign to copy elements <span class="keyword">from</span> <span class="keyword">iterator</span> <span class="type">range</span></span><br><span class="line">        // defined on page <span class="number">662</span></span><br><span class="line">        <span class="keyword">template</span> &lt;class <span class="type">Iter</span>&gt; <span class="type">void</span> copy_elems(<span class="type">Iter</span>, <span class="type">Iter</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// <span class="type">Inclusion</span> <span class="type">Compilation</span> <span class="type">Model</span>: <span class="keyword">include</span> member function definitions <span class="keyword">as</span> well</span><br><span class="line"><span class="comment">#include "Queue.cc"</span></span><br></pre></td></tr></table></figure>
<h2 id="5-_static_Members_of_Class_Templates">5. static Members of Class Templates</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; class <span class="type">Foo</span> &#123;</span><br><span class="line">    public:</span><br><span class="line">        <span class="keyword">static</span> std::size_t count() &#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">        // other <span class="keyword">interface</span> members</span><br><span class="line">    private:</span><br><span class="line">        <span class="keyword">static</span> std::size_t ctr;</span><br><span class="line">        // other implementation members</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// <span class="type">Each</span> <span class="keyword">object</span> shares the same <span class="type">Foo</span>&lt;<span class="type">int</span>&gt;::ctrand <span class="type">Foo</span>&lt;<span class="type">int</span>&gt;::count members</span><br><span class="line"><span class="type">Foo</span>&lt;<span class="type">int</span>&gt; fi, fi2, fi3;</span><br><span class="line"></span><br><span class="line">// has <span class="keyword">static</span> members <span class="type">Foo</span>&lt;<span class="type">string</span>&gt;::ctrand <span class="type">Foo</span>&lt;<span class="type">string</span>&gt;::count</span><br><span class="line"><span class="type">Foo</span>&lt;<span class="type">string</span>&gt; fs;</span><br><span class="line"></span><br><span class="line"><span class="type">Foo</span>&lt;<span class="type">int</span>&gt; fi, fi2; // instantiates <span class="type">Foo</span>&lt;<span class="type">int</span>&gt; class</span><br><span class="line">size_t ct = <span class="type">Foo</span>&lt;<span class="type">int</span>&gt;::count(); // instantiates <span class="type">Foo</span>&lt;<span class="type">int</span>&gt;::count</span><br><span class="line">ct = fi.count(); // ok: uses <span class="type">Foo</span>&lt;<span class="type">int</span>&gt;::count</span><br><span class="line">ct = fi2.count(); // ok: uses <span class="type">Foo</span>&lt;<span class="type">int</span>&gt;::count</span><br><span class="line">ct = <span class="type">Foo</span>::count(); // error: which <span class="keyword">template</span> instantiation?</span><br></pre></td></tr></table></figure>
<p>As with any other  static data member, there must be a definition for the data member that appears outside the class. In the case of a class template  static , the member definition must inidicate that it is for a class template:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">size_t <span class="type">Foo</span>&lt;T&gt;::ctr = <span class="number">0</span>; // define <span class="keyword">and</span> initialize ctr</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/14/c-primer笔记12/" data-id="cinvexiy2002jtw3alxy5371s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/c-primer笔记11/" class="article-date">
  <time datetime="2016-03-14T07:20:05.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/c-primer笔记11/">c++ primer笔记11</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Class-Template_Member_Functions">1. Class-Template Member Functions</h2><p>The definition of a member function of a class template has the following form:</p>
<ul>
<li>It must start with the keyword template followed by the template parameter list for the class.</li>
<li>It must indicate the class of which it is a member.</li>
<li>The class name must include its template parameters.</li>
</ul>
<p><code>template &lt;class T&gt; ret-type Queue&lt;T&gt;::member-name</code><br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;::copy_elems(<span class="keyword">const</span> <span class="type">Queue</span> &amp;orig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">QueueItem</span>&lt;<span class="type">Type</span>&gt; *pt = orig.head; pt; pt = pt-&gt;next)</span><br><span class="line">        push(pt-&gt;item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Member functions of class templates are themselves function templates. Like any other function template, a member function of a class template is used to generate instantiations of that member. Unlike other function templates, the compiler does not perform template-argument deduction when instantiating class template member functions. Instead, the template parameters of a class template member function are determined by the type of the object on which the call is made. For example, when we call the  push member of an object of type Queue<int> , the push function that is instantiated is <code>void Queue&lt;int&gt;::push(const int &amp;val)</code>.<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>&gt; qi; <span class="regexp">//</span> instantiates class Queue&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">short <span class="keyword">s</span> = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="regexp">//</span> ok: <span class="keyword">s</span> converted to <span class="keyword">int</span> <span class="keyword">and</span> passed to <span class="keyword">push</span></span><br><span class="line">qi.<span class="keyword">push</span>(<span class="keyword">s</span>); <span class="regexp">//</span> instantiates Queue&lt;<span class="keyword">int</span>&gt;::<span class="keyword">push</span>(const <span class="keyword">int</span>&amp;)</span><br><span class="line">qi.<span class="keyword">push</span>(i); <span class="regexp">//</span> uses Queue&lt;<span class="keyword">int</span>&gt;::<span class="keyword">push</span>(const <span class="keyword">int</span>&amp;)</span><br><span class="line">f(<span class="keyword">s</span>); <span class="regexp">//</span> instantiates f(const short&amp;)</span><br><span class="line">f(i); <span class="regexp">//</span> instantiates f(const <span class="keyword">int</span>&amp;)</span><br></pre></td></tr></table></figure></int></p>
<p>Member functions of a class template are instantiated only for functions that are used by the program. <code>If a function is never used, then that member function is never instantiated</code>. This behavior implies that types used to instantiate a template need to meet only the requirements of the operations that are actually used. When we define an object of a template type, that definition causes the class template to be instantiated. Defining an object also instantiates whichever constructor was used to initialize the object, along with any members called by that constructor:<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instantiates Queue&lt;string&gt; class and Queue&lt;string&gt;::Queue()</span></span><br><span class="line"><span class="built_in">Queue</span><span class="subst">&lt;</span><span class="built_in">string</span><span class="subst">&gt;</span> qs;</span><br><span class="line">qs<span class="built_in">.</span>push(<span class="string">"hello"</span>); <span class="comment">// instantiates Queue&lt;string&gt;::push</span></span><br><span class="line"></span><br><span class="line">template <span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span> <span class="literal">void</span> <span class="built_in">Queue</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::push</span>(const <span class="keyword">Type</span> <span class="subst">&amp;</span>val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocate a new QueueItem object</span></span><br><span class="line">    QueueItem<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">*</span>pt <span class="subst">=</span> <span class="literal">new</span> QueueItem<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(val);</span><br><span class="line">    <span class="comment">// put item onto existing queue</span></span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">        head <span class="subst">=</span> tail <span class="subst">=</span> pt; <span class="comment">// the queue now has only one element</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tail<span class="subst">-&gt;</span>next <span class="subst">=</span> pt; <span class="comment">// add new element to end of the queue</span></span><br><span class="line">        tail <span class="subst">=</span> pt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>in turn instantiates the companion  QueueItem<string> class and its constructor. The QueueItem members in Queue are pointers. Defining a pointer to a class template doesn’t instantiate the class; the class is instantiated only when we use such a pointer. Thus, QueueItem is not instantiated when we create a Queue object. Instead, the QueueItem class is instanatiated when a Queue member such as front, push, or pop is used.</string></p>
<h2 id="2-_Template_Arguments_for_Nontype_Parameters">2. Template Arguments for Nontype Parameters</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> hi, <span class="type">int</span> wid&gt;</span><br><span class="line">class <span class="type">Screen</span> &#123;</span><br><span class="line">    public:</span><br><span class="line">        // <span class="keyword">template</span> nontype parameters used to initialize data members</span><br><span class="line">        <span class="type">Screen</span>(): screen(hi * wid, '<span class="comment">#'), cursor (0),</span></span><br><span class="line">                                height(hi), width(wid) &#123; &#125;</span><br><span class="line">    // ...</span><br><span class="line">    private:</span><br><span class="line">        std::<span class="type">string</span> screen;</span><br><span class="line">        std::<span class="type">string</span>::size_type cursor;</span><br><span class="line">        std::<span class="type">string</span>::size_type height, width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// define <span class="type">Screen</span>() outside the class</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> hi, <span class="type">int</span> wid&gt;</span><br><span class="line"><span class="type">Screen</span>&lt;hi, wid&gt;::<span class="type">Screen</span>&lt;hi, wid&gt;() : screen(hi * wid, '<span class="comment">#'), cursor (0),</span></span><br><span class="line">                                                height(hi), width(wid) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Screen</span>&lt;<span class="number">24</span>,<span class="number">80</span>&gt; hp2621;</span><br></pre></td></tr></table></figure>
<p>Nontype template arguments must be compile-time constant expressions.</p>
<h2 id="3-_Friend_Declarations_in_Class_Templates">3. Friend Declarations in Class Templates</h2><p>(1) A friend declaration for an ordinary nontemplate class or function, which grants friendship to the specific named class or function.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Bar</span> &#123;</span><br><span class="line">    // grants access to ordinary, nontemplate class <span class="keyword">and</span> function</span><br><span class="line">    friend class <span class="type">FooBar</span>;</span><br><span class="line">    friend <span class="type">void</span> fcn();</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(2) A friend declaration for a class template or function template, which grants access to all instances of the friend.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Bar</span> &#123;</span><br><span class="line">    // grants access to <span class="type">Foo1</span> <span class="keyword">or</span> templ_fcn1 parameterized by <span class="type">any</span> <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">template</span> &lt;class T&gt; friend class <span class="type">Foo1</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;class T&gt; friend <span class="type">void</span> templ_fcn1(<span class="keyword">const</span> T&amp;);</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(3) A friend declaration that grants access only to a specific instance of a class or function template.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; class <span class="type">Foo2</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="type">void</span> templ_fcn2(<span class="keyword">const</span> T&amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Bar</span> &#123;</span><br><span class="line">    // grants access to a single specific instance parameterized by <span class="type">char</span>*</span><br><span class="line">    friend class <span class="type">Foo2</span>&lt;<span class="type">char</span>*&gt;;</span><br><span class="line">    friend <span class="type">void</span> templ_fcn2&lt;<span class="type">char</span>*&gt;(<span class="type">char</span>* <span class="keyword">const</span> &amp;);</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>More common are friend declarations of the following form:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; class <span class="type">Foo3</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="type">void</span> templ_fcn3(<span class="keyword">const</span> T&amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Bar</span> &#123;</span><br><span class="line">    // each instantiation <span class="keyword">of</span> <span class="type">Bar</span> grants access to the</span><br><span class="line">    // version <span class="keyword">of</span> <span class="type">Foo3</span> <span class="keyword">or</span> templ_fcn3 instantiated <span class="keyword">with</span> the same <span class="keyword">type</span></span><br><span class="line">    friend class <span class="type">Foo3</span>&lt;<span class="type">Type</span>&gt;;</span><br><span class="line">    friend <span class="type">void</span> templ_fcn3&lt;<span class="type">Type</span>&gt;(<span class="keyword">const</span> <span class="type">Type</span>&amp;);</span><br><span class="line">    // ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_Declaration_Dependencies">4. Declaration Dependencies</h2><p>When we grant access to all instances of a given template, there need not be a declaration for that class or function template in scope. Essentially, the compiler treats the friend declaration as a declaration of the class or function as well. When we want to restrict friendship to a specific instantiation, then the class or function must have been declared before it can be used in a friend declaration:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt; class A;</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; class B &#123;</span><br><span class="line">    public:</span><br><span class="line">        friend class A&lt;T&gt;; // ok: A <span class="keyword">is</span> known to be a <span class="keyword">template</span></span><br><span class="line">        friend class C; // ok: C must be an ordinary, nontemplate class</span><br><span class="line">        <span class="keyword">template</span> &lt;class S&gt; friend class D; // ok: D <span class="keyword">is</span> a <span class="keyword">template</span></span><br><span class="line">        friend class E&lt;T&gt;; // error: E wasn't declared <span class="keyword">as</span> a <span class="keyword">template</span></span><br><span class="line">        friend class F&lt;<span class="type">int</span>&gt;; // error: F wasn't declared <span class="keyword">as</span> a <span class="keyword">template</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-_Making_a_Function_Template_a_Friend">5. Making a Function Template a Friend</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// function <span class="keyword">template</span> declaration must precede friend declaration <span class="keyword">in</span> <span class="type">QueueItem</span></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, <span class="keyword">const</span> <span class="type">Queue</span>&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; class <span class="type">Queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">QueueItem</span> &#123;</span><br><span class="line">    friend class <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;;</span><br><span class="line">    // needs access to item <span class="keyword">and</span> next</span><br><span class="line">    friend std::ostream&amp;</span><br><span class="line">        operator&lt;&lt; &lt;<span class="type">Type</span>&gt; (std::ostream&amp;, <span class="keyword">const</span> <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;&amp;);</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Queue</span> &#123;</span><br><span class="line">    // needs access to head</span><br><span class="line">    friend std::ostream&amp;</span><br><span class="line">        operator&lt;&lt; &lt;<span class="type">Type</span>&gt; (std::ostream&amp;, <span class="keyword">const</span> <span class="type">Queue</span>&lt;<span class="type">Type</span>&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/14/c-primer笔记11/" data-id="cinvexiy5002ltw3auc7klp0i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/c-primer笔记10/" class="article-date">
  <time datetime="2016-03-12T10:27:48.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/c-primer笔记10/">c++ primer笔记10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Template_Compilation_Models">1. Template Compilation Models</h2><p>When the compiler sees a template definition, it does not generate code immediately. The compiler produces type-specific instances of the template only when it sees a use of the template, such as when a function template is called or an object of a class template is defined.</p>
<p>Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarly, when we define an object of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class definitions and function declarations in header files and definitions of ordinary and class-member functions in source files.</p>
<p>Templates are different: To generate an instantiation, the compiler must have access to the source code that defines the template. When we call a function template or a member function of a class template, the compiler needs the function definition. It needs the code we normally put in the source files.</p>
<p>Standard C++ defines two models for compiling template code: inclusion compilation model and separate compilation model . Class definitions and function declarations go in header files, and function and member definitions go in source files. The two models differ in how the definitions from the source files are made available to the compiler.</p>
<h2 id="2-_Inclusion_Compilation_Model">2. Inclusion Compilation Model</h2><p>In the inclusion compilation model , the compiler must see the definition for any template that is used. Typically, we make the definitions available by adding a  #include directive to the headers that declare function or class templates. That  #include brings in the source file(s) that contain the associated definitions:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// header file utlities.h</span><br><span class="line"><span class="comment">#ifndef UTLITIES_H</span></span><br><span class="line"><span class="comment">#define UTLITIES_H</span></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="type">int</span> compare(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br><span class="line"><span class="comment">#include "utilities.cc" // get the definitions for compare etc.</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// implemenatation file utlities.cc</span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; <span class="type">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Some, especially older, compilers that use the inclusion model may generate multiple instantiations. If two or more separately compiled source files use the same template, these compilers will generate an instantiation for the template in each file. Ordinarily, this approach implies that a given template will be instantiated more than once. At link time, or during a prelink<br>phase, the compiler selects one instantiation, discarding the others. In such cases, compile-time performance can be significantly degraded if there are a lot of files that instantiate the same template. Such compilers often support mechanisms that avoid the compile-time overhead implicit in multiple instantiations of the same template. If compile time for programs using templates is too burdensome, consult your compiler’s user’s guide to see what support your compiler offers to avoid redundant instantiations.</p>
<h2 id="3-_Separate_Compilation_Model">3. Separate Compilation Model</h2><p>In the separate compilation model , the compiler keeps track of the associated template definitions for us. However, we must tell the compiler to remember a given template definition. We use the  export keyword to do so. A template may be defined as exported only once in a program. The declaration for this function template, should, as usual, be put in a header. The declaration must not specify export.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// **.h</span><br><span class="line"><span class="keyword">template</span>&lt;typename <span class="type">Type</span>&gt; <span class="type">Type</span> sum(<span class="type">Type</span> t1, <span class="type">Type</span> t2);</span><br><span class="line"></span><br><span class="line">// **.cpp</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">template</span> &lt;typename <span class="type">Type</span>&gt;</span><br><span class="line"><span class="type">Type</span> sum(<span class="type">Type</span> t1, <span class="type">Type</span> t2) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Using export on a class template is a bit more complicated. As usual, the class declaration must go in a header file. The class body in the header should not use the  export keyword. If we used  export in the header, then that header could be used by only one source file in the program.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// class <span class="keyword">template</span> header goes <span class="keyword">in</span> <span class="literal">shared</span> header file</span><br><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Queue</span> &#123; ... &#125;;</span><br><span class="line">// <span class="type">Queue</span>.ccimplementation file declares <span class="type">Queue</span> <span class="keyword">as</span> exported</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">template</span> &lt;class <span class="type">Type</span>&gt; class <span class="type">Queue</span>;</span><br><span class="line"><span class="comment">#include "Queue.h"</span></span><br><span class="line">// <span class="type">Queue</span> member definitions</span><br></pre></td></tr></table></figure></p>
<p>The members of an exported class are automatically declared as exported. It is also possible to declare individual members of a class template as exported. In this case, the keyword export is not specified on the class template itself. It is specified only on the specific member definitions to be exported. The definition of exported member functions need not be visible when the member is used. The definitions of any nonexported member must be treated as in the inclusion model: The definition should be placed inside the header that defines the class template.</p>
<h2 id="4-_Class_Template_Members">4. Class Template Members</h2><p><img src="/img/queue-impl.PNG" alt=""><br>Class QueueItem is a private classit has no public interface. We intend this class to be used to implement  Queue and have not built it for general use. Hence, it has no public members. We’ll need to make class  Queue a friend of  QueueItem so that its members can access the members of QueueItem. </p>
<p>Inside the scope of a class template, we may refer to the class using its unqualified name.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt; <span class="keyword">class</span> QueueItem &#123;</span><br><span class="line">    <span class="comment">// private class: no public section</span></span><br><span class="line">    QueueItem(<span class="keyword">const</span> Type &amp;t): item(t), next(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    Type item; <span class="comment">// value stored in this element</span></span><br><span class="line">    QueueItem *next; <span class="comment">// pointer to next element in the Queue</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt; </span><br><span class="line"><span class="keyword">class</span> Queue </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// empty Queue</span></span><br><span class="line">        Queue(): head(<span class="number">0</span>), tail(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        <span class="comment">// copy control to manage pointers to QueueItems in the Queue</span></span><br><span class="line">        Queue(<span class="keyword">const</span> Queue &amp;Q): head(<span class="number">0</span>), tail(<span class="number">0</span>)</span><br><span class="line">        &#123; copy_elems(Q); &#125;</span><br><span class="line">        Queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Queue&amp;);</span><br><span class="line">        ~Queue() &#123; destroy(); &#125;</span><br><span class="line">        <span class="comment">// return element from head of Queue</span></span><br><span class="line">        <span class="comment">// unchecked operation: front on an empty Queue is undefined</span></span><br><span class="line">        Type&amp; front() &#123; <span class="keyword">return</span> head-&gt;item; &#125;</span><br><span class="line">        <span class="keyword">const</span> Type &amp;front() <span class="keyword">const</span> &#123; <span class="keyword">return</span> head-&gt;item; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Type &amp;)</span></span>; <span class="comment">// add element to back of Queue</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span> <span class="params">()</span></span>; <span class="comment">// remove element from head of Queue</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// true if no elements in the Queue</span></span><br><span class="line">            <span class="keyword">return</span> head == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        QueueItem&lt;Type&gt; *head; <span class="comment">// pointer to first element in Queue</span></span><br><span class="line">        QueueItem&lt;Type&gt; *tail; <span class="comment">// pointer to last element in Queue</span></span><br><span class="line">        <span class="comment">// utility functions used by copy constructor, assignment, and destructor</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>; <span class="comment">// delete all the elements</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">copy_elems</span><span class="params">(<span class="keyword">const</span> Queue&amp;)</span></span>; <span class="comment">// copy elements from parameter</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Ordinarily, when we use the name of a class template, we must specify the template parameters. There is one exception to this rule: Inside the scope of the class itself, we may use the unqualified name of the class template. For example, in the declarations of the default and copy constructor the name Queue is a shorthand notation that stands for  Queue<type>. Hence,<br>the copy constructor definition is really equivalent to writing:<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Queue&lt;Type&gt;<span class="comment">(const Queue&lt;Type&gt; &amp;Q)</span>: head<span class="comment">(0)</span>, tail<span class="comment">(0)</span></span><br><span class="line">    &#123; copy_elems<span class="comment">(Q)</span>; &#125;</span><br></pre></td></tr></table></figure></type></p>
<p>The compiler performs no such inference for the template parameter(s) for other templates used within the class. Hence, we must specify the type parameter when declaring pointers to the companion  QueueItem class:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">QueueItem&lt;<span class="keyword">Type</span>&gt; *head; // <span class="type">pointer</span> to first element <span class="type">in</span> Queue</span><br><span class="line">QueueItem&lt;<span class="keyword">Type</span>&gt; *tail; // <span class="type">pointer</span> to last element <span class="type">in</span> Queue</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/12/c-primer笔记10/" data-id="cinvexiyh002ntw3a35atgbfm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/c-primer笔记9/" class="article-date">
  <time datetime="2016-03-12T09:20:28.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/c-primer笔记9/">c++ primer笔记9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Instantiation">1. Instantiation</h2><p>A template is a blueprint; it is not itself a class or a function. The compiler uses the template to generate type-specific versions of the specified class or function. The process of generatng a type-specific instance of a template is known as instantiation. The term reflects the notion that a new “instance” of the template type or function is created.</p>
<p>A template is instantiated when we use it. A class template is instantiated when we refer to the an actual template class type, and a function template is instantiated when we call it or use it to initialize or assign to a pointer to function.</p>
<p>When we want to use a class template, we must always specify the template arguments explicitly. When we use a function template, the compiler will usually infer the template arguments for us.</p>
<h2 id="2-Template_Argument_Deduction">2.Template Argument Deduction</h2><p>To determine which functions to instantiate, the compiler looks at each argument. If the corresponding parameter was declared with a type that is a type parameter, then the compiler infers the type of the parameter from the type of the argument. The process of determining the types and values of the template arguments from the type of the function arguments is called template argument deduction. note: Multiple Type Parameter Arguments Must Match Exactly.</p>
<h2 id="3-Limited_Conversions_on_Type_Parameter_Arguments">3.Limited Conversions on Type Parameter Arguments</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">short</span> <span class="literal">s1</span>, <span class="literal">s2</span><span class="comment">;</span></span><br><span class="line"><span class="label">int</span> i1, i2<span class="comment">;</span></span><br><span class="line"><span class="label">compare</span>(i1, i2)<span class="comment">; // ok: instantiate compare(int, int)</span></span><br><span class="line"><span class="label">compare</span>(<span class="literal">s1</span>, <span class="literal">s2</span>)<span class="comment">; // ok: instantiate compare(short, short)</span></span><br></pre></td></tr></table></figure>
<p>In general, arguments are not converted to match an existing instantiation; instead, a new instance is generated. There are only two kinds of conversions that the compiler will perform rather than generating a new instantiation:</p>
<ul>
<li>const conversions: A function that takes a reference or pointer to a  const can be called with a reference or pointer to non const object, respectively, without generating a new instantiation. If the function takes a nonreference type, then  const is ignored on either the parameter type or the argument. That is, the same instantiation will be used whether we pass a const or non const object to a function defined to take a nonreference type.</li>
<li>array or function to pointer conversions: If the template parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be treated as a pointer to its first element, and a function argument will be treated as a pointer to the function’s type.</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt; T fobj(T, T); // arguments are copied</span><br><span class="line"><span class="keyword">template</span> &lt;typename T&gt;</span><br><span class="line">T fref(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;); // reference arguments</span><br><span class="line"><span class="type">string</span> s1(<span class="string">"a value"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="type">string</span> s2(<span class="string">"another value"</span>);</span><br><span class="line">fobj(s1, s2); // ok: calls f(<span class="type">string</span>, <span class="type">string</span>), <span class="keyword">const</span> <span class="keyword">is</span> ignored</span><br><span class="line">fref(s1, s2); // ok: non <span class="keyword">const</span> <span class="keyword">object</span> s1 converted to <span class="keyword">const</span> reference</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], b[<span class="number">42</span>];</span><br><span class="line">fobj(a, b); // ok: calls f(<span class="type">int</span>*, <span class="type">int</span>*)</span><br><span class="line">fref(a, b); // error: <span class="type">array</span> types don't match; arguments aren't converted to pointers</span><br></pre></td></tr></table></figure>
<h2 id="4-Template_Argument_Deduction_and_Function_Pointers">4.Template Argument Deduction and Function Pointers</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt; <span class="type">int</span> compare(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br><span class="line">// pf1 points to the instantiation <span class="type">int</span> compare (<span class="keyword">const</span> <span class="type">int</span>&amp;, <span class="keyword">const</span> <span class="type">int</span>&amp;)</span><br><span class="line"><span class="type">int</span> (*pf1) (<span class="keyword">const</span> <span class="type">int</span>&amp;, <span class="keyword">const</span> <span class="type">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<p>It is an error if the template arguments cannot be determined from the function pointer type.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span>)</span>;</span><br><span class="line">func(compare); <span class="comment">// error: which instantiation of compare?</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-Function-Template_Explicit_Arguments">5.Function-Template Explicit Arguments</h2><p>In some situations, it is not possible to deduce the types of the template arguments.  In such situations, it is necessary to override the template argument deduction mechanism and explicitly specify the types or values to be used for the template<br>parameters.</p>
<p>Consider the following problem. We wish to define a function template called  sum that takes arguments of two differnt types. We’d like the return type to be large enough to contain the sum of two values of any two types passed in any order. How can we do that? How should we specify sum’s return type?<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// T <span class="keyword">or</span> U <span class="keyword">as</span> the returntype?</span><br><span class="line"><span class="keyword">template</span> &lt;class T, class U&gt; ??? sum(T, U);</span><br><span class="line"></span><br><span class="line">// neither T nor U works <span class="keyword">as</span> <span class="keyword">return</span> typ</span><br><span class="line">sum(<span class="number">3</span>, <span class="number">4</span>L); // second <span class="keyword">type</span> <span class="keyword">is</span> larger; want U sum(T, U)</span><br><span class="line">sum(<span class="number">3</span>L, <span class="number">4</span>); // first <span class="keyword">type</span> <span class="keyword">is</span> larger; want T sum(T, U)</span><br></pre></td></tr></table></figure></p>
<p>An alternative way to specify the return type is to introduce a third template parameter that must be explicitly specified by our caller. We supply an explicit template argument to a call in much the same way that we define an instance of a class template.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">T1</span>, class <span class="type">T2</span>, class <span class="type">T3</span>&gt;</span><br><span class="line"><span class="type">T1</span> sum(<span class="type">T2</span>, <span class="type">T3</span>);</span><br><span class="line"></span><br><span class="line">// ok <span class="type">T1</span> explicitly specified; <span class="type">T2</span> <span class="keyword">and</span> <span class="type">T3</span> inferred <span class="keyword">from</span> argument types</span><br><span class="line">long val3 = sum&lt;long&gt;(i, lng); // ok: calls long sum(<span class="type">int</span>, long)</span><br></pre></td></tr></table></figure></p>
<p>Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; the first template argument is matched to the first template parameter. An explicit template argument may be omitted only for the trailing (rightmost) parameters, assuming these can be deduced from the function parameters. If our  sum function had been written as<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">T1</span>, class <span class="type">T2</span>, class <span class="type">T3</span>&gt;</span><br><span class="line"><span class="type">T3</span> alternative_sum(<span class="type">T2</span>, <span class="type">T1</span>);</span><br><span class="line"></span><br><span class="line">// error: can't infer initial <span class="keyword">template</span> parameters</span><br><span class="line">long val3 = alternative_sum&lt;long&gt;(i, lng);</span><br><span class="line">// ok: <span class="type">All</span> three parameters explicitly specified</span><br><span class="line">long val2 = alternative_sum&lt;long, <span class="type">int</span>, long&gt;(i, lng);</span><br></pre></td></tr></table></figure></p>
<p>Another example where explicit template arguments would be useful is the ambiguous program<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// overloaded versions of func; each take a different function pointer type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span>)</span>;</span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// ok: explicitly specify which version of compare</span></span><br></pre></td></tr></table></figure></p>
<p>We saw that the arguments to the version of compare that has a single template type parameter must match exactly. If we wanted to call the function with compatible types, such as  int and  short, we could use an explicit template argument to specify either  int or short as the parameter type. Write a program that uses the version of compare that has one template parameter. Call  compare using an explicit template argument that will let you pass arguments of type int and short.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> sval = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">2</span>;</span><br><span class="line">compare(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sval), ival);</span><br><span class="line">compare(<span class="keyword">static_cast</span>&lt;<span class="keyword">short</span>&gt;(ival), sval);</span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(sval, ival);</span><br><span class="line">compare&lt;<span class="keyword">short</span>&gt;(sval, ival);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/12/c-primer笔记9/" data-id="cinvexis20016tw3awucrqn91" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/c-primer笔记8/" class="article-date">
  <time datetime="2016-03-12T08:33:09.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/c-primer笔记8/">c++ primer笔记8: template</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Template_Parameter_List">1.Template Parameter List</h2><p>A template parameter can be a type parameter, which represents a type, or a nontype parameter , which represents a constant expression. A nontype parameter is declared following a type specifier. A type parameter is defined following the keyword class or  typename. </p>
<p>The only meaning we can ascribe to a template parameter is to distinguish whether the parameter is a type parameter or a nontype parameter. If it is a type parameter, then we know that the parameter represents an as yet unknown type. If it is a nontype parameter, we know it is an as yet unknown value.</p>
<h2 id="2-inline_Function_Templates">2.inline Function Templates</h2><p>A function template can be declared  inline in the same way as a nontemplate function. The specifier is placed following the template parameter list and before the return type. It is not placed in front of the  template keyword.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// ok: inline specifier follows <span class="keyword">template</span> parameter list</span><br><span class="line"><span class="keyword">template</span> &lt;typename T&gt; inline T min(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br><span class="line">// error: incorrect placement <span class="keyword">of</span> inline specifier</span><br><span class="line">inline <span class="keyword">template</span> &lt;typename T&gt; T min(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Using_a_Function_Template">3.Using a Function Template</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt;</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When we called  compare on two  string s, we passed two string objects, which we initialized from string literals<br>What would happen if we wrote: <code>compare (&quot;hi&quot;, &quot;world&quot;)</code>.该代码会出现编译错误。因为引用的缘故，根据”hi”可将模板形参推断为char[3]，根据”world”可将模板形参推断为char[6]，T被推断为不同的类型。、</p>
<h2 id="4-Designating_Types_inside_the_Template_Definition">4.Designating Types inside the Template Definition</h2><p>In addition to defining data or function members, a class may define type members. When we want to use such types inside a<br>function template, we must tell the compiler that the name we are using refers to a type. We must be explicit because the compiler (and a reader of our program) cannot tell by inspection when a name defined by a type parameter is a type or a value. As an example, consider the following function:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Parm</span>, class U&gt;</span><br><span class="line"><span class="type">Parm</span> fcn(<span class="type">Parm</span>* <span class="type">array</span>, U value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Parm</span>: :size_type * p;   // <span class="type">If</span> <span class="type">Parm</span>::size_type <span class="keyword">is</span> a <span class="keyword">type</span>, then a declaration</span><br><span class="line">                            // <span class="type">If</span> <span class="type">Parm</span>::size_type <span class="keyword">is</span> an <span class="keyword">object</span>, then multiplication</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>We know that size_type must be a member of the type bound to Parm , but we do not know whether size_type is the name of a type or a data member. By default, the compiler assumes that such names name data members, not types. If we want the compiler to treat  size_type as a type, then we must explicitly tell the compiler to do so:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Parm</span>, class U&gt;</span><br><span class="line"><span class="type">Parm</span> fcn(<span class="type">Parm</span>* <span class="type">array</span>, U value)</span><br><span class="line">&#123;</span><br><span class="line">    typename <span class="type">Parm</span>::size_type * p; // ok: declares p to be a <span class="type">pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Question">5.Question</h2><p>Write a function template that takes a pair of values that represent iterators of unknown type. Find the value that occurs most frequently in the sequence.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="keyword">value_t</span><span class="function">ype <span class="title">find_most</span><span class="params">(T begin, T end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T most_iter;</span><br><span class="line">    <span class="keyword">size_t</span> max_num, num;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">typename</span> T::<span class="keyword">value_t</span>ype, <span class="keyword">size_t</span>&gt; container;</span><br><span class="line"></span><br><span class="line">    max_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        num = ++container[*begin];</span><br><span class="line">        <span class="keyword">if</span>(num &gt; max_num)</span><br><span class="line">        &#123;</span><br><span class="line">            max_num = num;</span><br><span class="line">            most_iter = begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *most_iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-_Nontype_Template_Parameters">6. Nontype Template Parameters</h2><p>The function itself takes a single parameter, which is a reference to an array<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T, size_t N&gt; <span class="type">void</span> array_init(T (&amp;parm)[N])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i != N; ++i) &#123;</span><br><span class="line">        parm[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x[<span class="number">42</span>];</span><br><span class="line">double y[<span class="number">10</span>];</span><br><span class="line">array_init(x); // instantiates array_init(<span class="type">int</span>(&amp;)[<span class="number">42</span>])</span><br><span class="line">array_init(y); // instantiates array_init(double(&amp;)[<span class="number">10</span>])</span><br></pre></td></tr></table></figure></p>
<p>A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are required.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// <span class="type">Another</span> example: <span class="type">Write</span> a function <span class="keyword">template</span> that can determine the size <span class="keyword">of</span> an <span class="type">array</span>.</span><br><span class="line"><span class="keyword">template</span>&lt;typename T, size_t N&gt;</span><br><span class="line">size_t size(T (&amp;<span class="type">array</span>)[N])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-_Writing_Generic_Programs">7. Writing Generic Programs</h2><p>The operations performed inside a function template constrains the types that can be used to instantiate the function. It is up to the programmer to guarantee that the types used as the function arguments actually support any operations that are used, and that<br>those operations behave correctly in the context in which the template uses them.</p>
<p>When writing template code, it is useful to keep the number of requirements placed on the argument types as small as possible.Simple though it is, our  compare function illustrates two important principles for writing generic code:</p>
<ul>
<li>The parameters to the template are  const references.</li>
<li>The tests in the body use only  &lt; comparisons.</li>
</ul>
<p>By making the parameters  const references, we allow types that do not allow copying. Moreover, if  compare is called with large objects, then this design will also make the function run faster. we reduce the requirements on types that can be used with our  compare function. Those types must support  &lt; , but they need not also support  &gt; .</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/12/c-primer笔记8/" data-id="cinvexis40019tw3ay8tnf1re" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记8-template" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/c-primer笔记8-template/" class="article-date">
  <time datetime="2016-03-12T08:33:09.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/c-primer笔记8-template/">c++ primer笔记8: template</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Template_Parameter_List">1.Template Parameter List</h2><p>A template parameter can be a type parameter, which represents a type, or a nontype parameter , which represents a constant expression. A nontype parameter is declared following a type specifier. A type parameter is defined following the keyword class or  typename. </p>
<p>The only meaning we can ascribe to a template parameter is to distinguish whether the parameter is a type parameter or a nontype parameter. If it is a type parameter, then we know that the parameter represents an as yet unknown type. If it is a nontype parameter, we know it is an as yet unknown value.</p>
<h2 id="2-inline_Function_Templates">2.inline Function Templates</h2><p>A function template can be declared  inline in the same way as a nontemplate function. The specifier is placed following the template parameter list and before the return type. It is not placed in front of the  template keyword.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// ok: inline specifier follows <span class="keyword">template</span> parameter list</span><br><span class="line"><span class="keyword">template</span> &lt;typename T&gt; inline T min(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br><span class="line">// error: incorrect placement <span class="keyword">of</span> inline specifier</span><br><span class="line">inline <span class="keyword">template</span> &lt;typename T&gt; T min(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Using_a_Function_Template">3.Using a Function Template</h2><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt;</span><br><span class="line"><span class="type">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When we called  compare on two  string s, we passed two string objects, which we initialized from string literals<br>What would happen if we wrote: <code>compare (&quot;hi&quot;, &quot;world&quot;)</code>.该代码会出现编译错误。因为引用的缘故，根据”hi”可将模板形参推断为char[3]，根据”world”可将模板形参推断为char[6]，T被推断为不同的类型。、</p>
<h2 id="4-Designating_Types_inside_the_Template_Definition">4.Designating Types inside the Template Definition</h2><p>In addition to defining data or function members, a class may define type members. When we want to use such types inside a<br>function template, we must tell the compiler that the name we are using refers to a type. We must be explicit because the compiler (and a reader of our program) cannot tell by inspection when a name defined by a type parameter is a type or a value. As an example, consider the following function:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Parm</span>, class U&gt;</span><br><span class="line"><span class="type">Parm</span> fcn(<span class="type">Parm</span>* <span class="type">array</span>, U value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Parm</span>: :size_type * p;   // <span class="type">If</span> <span class="type">Parm</span>::size_type <span class="keyword">is</span> a <span class="keyword">type</span>, then a declaration</span><br><span class="line">                            // <span class="type">If</span> <span class="type">Parm</span>::size_type <span class="keyword">is</span> an <span class="keyword">object</span>, then multiplication</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>We know that size_type must be a member of the type bound to Parm , but we do not know whether size_type is the name of a type or a data member. By default, the compiler assumes that such names name data members, not types. If we want the compiler to treat  size_type as a type, then we must explicitly tell the compiler to do so:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">Parm</span>, class U&gt;</span><br><span class="line"><span class="type">Parm</span> fcn(<span class="type">Parm</span>* <span class="type">array</span>, U value)</span><br><span class="line">&#123;</span><br><span class="line">    typename <span class="type">Parm</span>::size_type * p; // ok: declares p to be a <span class="type">pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Question">5.Question</h2><p>Write a function template that takes a pair of values that represent iterators of unknown type. Find the value that occurs most frequently in the sequence.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="keyword">value_t</span><span class="function">ype <span class="title">find_most</span><span class="params">(T begin, T end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T most_iter;</span><br><span class="line">    <span class="keyword">size_t</span> max_num, num;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">typename</span> T::<span class="keyword">value_t</span>ype, <span class="keyword">size_t</span>&gt; container;</span><br><span class="line"></span><br><span class="line">    max_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        num = ++container[*begin];</span><br><span class="line">        <span class="keyword">if</span>(num &gt; max_num)</span><br><span class="line">        &#123;</span><br><span class="line">            max_num = num;</span><br><span class="line">            most_iter = begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *most_iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-_Nontype_Template_Parameters">6. Nontype Template Parameters</h2><p>The function itself takes a single parameter, which is a reference to an array<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T, size_t N&gt; <span class="type">void</span> array_init(T (&amp;parm)[N])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i != N; ++i) &#123;</span><br><span class="line">        parm[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x[<span class="number">42</span>];</span><br><span class="line">double y[<span class="number">10</span>];</span><br><span class="line">array_init(x); // instantiates array_init(<span class="type">int</span>(&amp;)[<span class="number">42</span>])</span><br><span class="line">array_init(y); // instantiates array_init(double(&amp;)[<span class="number">10</span>])</span><br></pre></td></tr></table></figure></p>
<p>A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are required.<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// <span class="type">Another</span> example: <span class="type">Write</span> a function <span class="keyword">template</span> that can determine the size <span class="keyword">of</span> an <span class="type">array</span>.</span><br><span class="line"><span class="keyword">template</span>&lt;typename T, size_t N&gt;</span><br><span class="line">size_t size(T (&amp;<span class="type">array</span>)[N])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-_Writing_Generic_Programs">7. Writing Generic Programs</h2><p>The operations performed inside a function template constrains the types that can be used to instantiate the function. It is up to the programmer to guarantee that the types used as the function arguments actually support any operations that are used, and that<br>those operations behave correctly in the context in which the template uses them.</p>
<p>When writing template code, it is useful to keep the number of requirements placed on the argument types as small as possible.Simple though it is, our  compare function illustrates two important principles for writing generic code:</p>
<ul>
<li>The parameters to the template are  const references.</li>
<li>The tests in the body use only  &lt; comparisons.</li>
</ul>
<p>By making the parameters  const references, we allow types that do not allow copying. Moreover, if  compare is called with large objects, then this design will also make the function run faster. we reduce the requirements on types that can be used with our  compare function. Those types must support  &lt; , but they need not also support  &gt; .</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/12/c-primer笔记8-template/" data-id="cinvexis6001btw3arjos7xid" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/11/c-primer笔记7/" class="article-date">
  <time datetime="2016-03-11T03:14:44.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/11/c-primer笔记7/">c++ primer笔记7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Containers_and_Inheritance">1. Containers and Inheritance</h2><p>We’d like to use containers (or built-in arrays) to hold objects that are related by inheritance. However, the fact that objects are not polymorphic affects how we can use containers with types in an inheritance hierarchy. Because derived objects are “sliced down” when assigned to a base object, containers and types related by inheritance do not mix well.</p>
<p>The only viable alternative would be to use the container to hold pointers to our objects. This strategy works, but at the cost of pushing onto our users the problem of managing the objects and pointers. The user must ensure that the objects pointed to stay around for as long as the container. If the objects are dynamically allocated, then the user must ensure that they are properly freed when the container goes away. </p>
<h2 id="2-_Handle_Classes_and_Inheritance">2. Handle Classes and Inheritance</h2><p>One of the ironies of object-oriented programming in C++ is that we cannot use objects to support polymorphism. Instead, we must use pointers and references, not objects. Unfortunately, using pointers or references puts a burden on the users of our classes.</p>
<p>A common technique in C++ is to define a so-called <code>handle</code> class . The handle class stores and manages a pointer to the base class. The type of the object to which that pointer points will vary; it can point at either a base- or a derived-type object. Users access the operations of the inheritance hierarchy through the handle. Because the handle uses its pointer to execute those operations, the behavior of virtual members will vary at run time depending on the kind of object to which the handle is actually bound. Users of the handle thus obtain dynamic behavior but do not themselves have to worry about managing the pointer.</p>
<h2 id="3-_A_Pointerlike_Handle">3. A Pointerlike Handle</h2><p>We’ll define a pointerlike handle class, named  Sales_item , to represent our Item_base hierarchy. Users of Sales_item will use it as if it were a pointer: Users will bind a Sales_item to an object of type Item_base and will then use the  * and  -&gt; operations to execute Item_base operations:<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind a handle to a Bulk_item object</span></span><br><span class="line">Sales_item item<span class="params">(Bulk_item<span class="params">(<span class="string">"0-201-82470-1"</span>, <span class="number">35</span>, <span class="number">3</span>, .<span class="number">20</span>)</span>)</span>;</span><br><span class="line">item-&gt;net_price<span class="params">()</span>; <span class="comment">// virtual call to net_price function</span></span><br></pre></td></tr></table></figure></p>
<p>However, users won’t have to manage the object to which the handle points; the Sales_item class will do that part of the job. When users call a function through a  Sales_item , they’ll get polymorphic behavior.</p>
<p>The use-counted classes we’ve used so far have used a companion class to store the pointer and associated use count. In this class, we’ll use a different design. The  Sales_item class will have two data members, both of which are pointers: One pointer will point to the  Item_base object and the other will point to the use count. The Item_base pointer might point to an  Item_base object or an object of a type derived from Item_base.<br><img src="/img/pointerlike-handle.PNG" alt=""><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// default constructor: unbound handle</span></span><br><span class="line">        Sales_item(): p(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125;</span><br><span class="line">        <span class="comment">// attaches a handle to a copy of the Item_base object</span></span><br><span class="line">        Sales_item(<span class="keyword">const</span> Item_base&amp;);</span><br><span class="line">        <span class="comment">// copy control members to manage the use count and pointers</span></span><br><span class="line">        Sales_item(<span class="keyword">const</span> Sales_item &amp;i):</span><br><span class="line">                        p(i.p), use(i.use) &#123; ++*use; &#125;</span><br><span class="line">        ~Sales_item() &#123; decr_use(); &#125;</span><br><span class="line">        Sales_item&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line">        <span class="comment">// member access operators</span></span><br><span class="line">        <span class="keyword">const</span> Item_base *<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">if</span> (p) <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"unbound Sales_item"</span>); &#125;</span><br><span class="line">        <span class="keyword">const</span> Item_base &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">if</span> (p) <span class="keyword">return</span> *p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"unbound Sales_item"</span>); &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Item_base *p; <span class="comment">// pointer to shared item</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> *use; <span class="comment">// pointer to shared use count</span></span><br><span class="line">        <span class="comment">// called by both destructor and assignment operator to free pointers</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">decr_use</span><span class="params">()</span></span><br><span class="line">        </span>&#123; <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="keyword">delete</span> p; <span class="keyword">delete</span> use; &#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_item&amp;</span><br><span class="line">Sales_item::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_item &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use;</span><br><span class="line">    decr_use();</span><br><span class="line">    p = rhs.p;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Sales_item(const Item_base&amp;);</code>The constructor will allocate a new object of the appropriate type and copy the parameter into that newly allocated object. That way the Sales_item class will own the object and can guarantee that the object is not deleted until the last Sales_item attached to the object goes away. To implement the constructor that takes an  Item_base , we must first solve a problem: We do not know the actual type of the object that the constructor is given. We know that it is an Item_base or an object of a type derived from Item_base. The common approach to solving this problem is to define a virtual operation to do the copy, which we’ll name  clone.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Item_base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> Item_base* clone() <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="keyword">new</span> Item_base(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Bulk_item : <span class="keyword">public</span> Item_base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Bulk_item* clone() <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="keyword">new</span> Bulk_item(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_item::Sales_item(<span class="keyword">const</span> Item_base &amp;item):</span><br><span class="line">        p(item.clone()), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>If the base instance of a virtual function returns a reference or pointer to a class type, the derived version of the virtual may return a class  publicly derived from the class returned by the base class instance (or a pointer or a reference to a class type).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/11/c-primer笔记7/" data-id="cinvexis8001dtw3aixboh630" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/10/c-primer笔记6/" class="article-date">
  <time datetime="2016-03-10T11:24:59.000Z" itemprop="datePublished">2016-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/10/c-primer笔记6/">c++ primer笔记6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Using_a_Derived_Object_to_Initialize_or_Assign_a_Base_Object">1. Using a Derived Object to Initialize or Assign a Base Object</h2><p>Because there is a conversion from reference to derived to reference to base, these copy-control members can be used to initialize or assign a base object from a derived object:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Item_base </span><span class="keyword">item; </span>// object of <span class="keyword">base </span>type</span><br><span class="line"><span class="keyword">Bulk_item </span><span class="keyword">bulk; </span>// object of derived type</span><br><span class="line">// ok: uses <span class="keyword">Item_base::Item_base(const </span><span class="keyword">Item_base&amp;) </span>constructor</span><br><span class="line"><span class="keyword">Item_base </span><span class="keyword">item(bulk); </span>// <span class="keyword">bulk </span>is <span class="string">"sliced down"</span> to <span class="keyword">its </span><span class="keyword">Item_base </span>portion</span><br><span class="line">// ok: calls <span class="keyword">Item_base::operator=(const </span><span class="keyword">Item_base&amp;)</span><br><span class="line"></span><span class="keyword">item </span>= <span class="keyword">bulk; </span>// <span class="keyword">bulk </span>is <span class="string">"sliced down"</span> to <span class="keyword">its </span><span class="keyword">Item_base </span>portion</span><br></pre></td></tr></table></figure></p>
<p>When we call the  Item_base copy constructor or assignment operator on an object of type Bulk_item , the following steps happen:</p>
<ul>
<li>The  Bulk_item object is converted to a reference to  Item_base, which means only that an Item_base reference is bound to the Bulk_item object.</li>
<li>That reference is passed as an argument to the copy constructor or assignment operator.</li>
<li>Those operators use the  Item_base part of  Bulk_item to initialize and assign, respectively, the members of the  Item_base on which the constructor or assignment was called.</li>
<li>Once the operator completes, the object is an  Item_base . It contains a copy of the Item_base part of the  Bulk_item from which it was initialized or assigned, but the  Bulk_item parts of the argument are ignored.</li>
</ul>
<h2 id="2-_Defining_a_Default_Constructor">2. Defining a Default Constructor</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">Item_base</span>(const <span class="attribute">std</span>::string &amp;book = <span class="string">""</span>, double sales_price = <span class="number">0.0</span>): </span><br><span class="line">                                    <span class="tag">isbn</span>(book), <span class="tag">price</span>(sales_price) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">class</span> <span class="tag">Bulk_item</span> : <span class="tag">public</span> <span class="tag">Item_base</span> &#123;</span><br><span class="line">    <span class="tag">public</span>:</span><br><span class="line">        <span class="tag">Bulk_item</span>(): <span class="tag">min_qty</span>(<span class="number">0</span>), <span class="tag">discount</span>(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line">        <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This constructor uses the constructor initializer list to initialize its min_qty and  discount members. The constructor initializer also implicitly invokes the  Item_base default constructor to initialize its base-class part. The effect of running this constructor is that first the  Item_base part is initialized using the Item_base default constructor. That constructor sets  isbn to the empty string and  price to zero. After the  Item_base constructor finishes, the members of the  Bulk_item part are initialized, and the (empty) body of the constructor is executed.<br>The constructor initializer list supplies initial values for a class’ base class and members. It does not specify the order in which those initializations are done. The base class is initialized first and then the members of the derived class are initialized in the order in which they are declared.<br>A class may initialize only its own immediate base class. An immediate base class is the class named in the derivation list. </p>
<h2 id="3-_Defining_a_Derived_Copy_Constructor">3. Defining a Derived Copy Constructor</h2><p>If a derived class explicitly defines its own copy constructor or assignment operator, that definition completely overrides the<br>defaults. The copy constructor and assignment operator for inherited classes are responsible for copying or assigning their base-<br>class components as well as the members in the class itself.<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>: <span class="title">public</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Base::Base(const Base&amp;) not invoked automatically</span></span><br><span class="line">        Derived(<span class="keyword">const</span> Derived&amp; d):</span><br><span class="line">            Base(d) <span class="comment">/* other member initialization */</span> &#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The initializer Base(d) converts the derived object, d , to a reference to its base part and invokes the base-class copy constructor. Had the initializer for the base class been omitted,<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Derived(const Derived&amp; d) /<span class="keyword">*</span> derived member initizations <span class="keyword">*</span>/</span><br><span class="line">&#123;/<span class="keyword">*</span> ... <span class="keyword">*</span>/ &#125;</span><br></pre></td></tr></table></figure></p>
<p>the effect would be to run the  Base default constructor to initialize the base part of the object. Assuming that the initialization of the Derived members copied the corresponding elements from d , then the newly constructed object would be oddly configured: Its Base part would hold default values, while its  Derived members would be copies of another object.</p>
<h2 id="4-_Derived-Class_Assignment_Operator">4. Derived-Class Assignment Operator</h2><p>If the derived class defines its own assignment operator, then that operator must assign the base part explicitly:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) not invoked automatically</span></span><br><span class="line">Derived &amp;Derived::<span class="keyword">operator</span>=(<span class="keyword">const</span> Derived &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// assigns the base part</span></span><br><span class="line">        <span class="comment">// do whatever needed to clean up the old value in the derived part</span></span><br><span class="line">        <span class="comment">// assign the members from the derived</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-_Derived-Class_Destructor">5. Derived-Class Destructor</h2><p>The destructor works differently from the copy constructor and assignment operator: The derived destructor is never responsible for destroying the members of its base objects. The compiler always implicitly invokes the destructor for the base part of a derived object. Objects are destroyed in the opposite order from which they are constructed: The derived destructor is run first, and then the base-class destructors are invoked, walking back up the inheritance hierarchy.<br>The root class of an inheritance hierarchy should define a virtual destructor even if the destructor has no work to do.</p>
<h2 id="6-_Virtuals_in_Constructors_and_Destructors">6. Virtuals in Constructors and Destructors</h2><p>A derived object is constructed by first running a base-class constructor to initialize the base part of the object. While the base-class constructor is executing, the derived part of the object is uninitialized. In effect, the object is not yet a derived object.</p>
<p>When a derived object is destroyed, its derived part is destroyed first, and then its base parts are destroyed in the reverse order of how they were constructed.</p>
<p>In both cases, while a constructor or destructor is running, the object is incomplete. To accommodate this incompleteness, the compiler treats the object as if its type changes during construction or destruction. Inside a base-class constructor or destructor, a derived object is treated as if it were an object of the base type.</p>
<p>If a virtual is called from inside a constructor or destructor, then the version that is run is the one defined for the type of the constructor or destructor itself.</p>
<h2 id="7-_Name_Collisions_and_Inheritance">7. Name Collisions and Inheritance</h2><p>A derived-class member with the same name as a member of the base class hides direct access to the base-class member. We can access a hidden base-class member by using the scope operator. The derived-class member hides the base-class member within the scope of the derived class. The base member is hidden, even if the prototypes of the functions differ :<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Derived : Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// hides memfcn in the base</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn(); <span class="comment">// calls Base::memfcn</span></span><br><span class="line">d.memfcn(<span class="number">10</span>); <span class="comment">// calls Derived::memfcn</span></span><br><span class="line">d.memfcn(); <span class="comment">// error: memfcn with no arguments is hidden</span></span><br><span class="line">d.Base::memfcn(); <span class="comment">// ok: calls Base::memfcn</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-_Name_Lookup_and_Inheritance">8. Name Lookup and Inheritance</h2><p>Understanding how function calls are resolved is crucial to understanding inheritance hierarchies in C++. The following four steps are followed:</p>
<ul>
<li>Start by determining the static type of the object, reference, or pointer through which the function is called.</li>
<li>Look for the function in that class. If it is not found, look in the immediate base class and continue up the chain of classes until either the function is found or the last class is searched. If the name is not found in the class or its enclosing base classes, then the call is in error.</li>
<li>Once the name is found, do normal type-checking to see if this call is legal given the definition that was found.</li>
<li>Assuming the call is legal, the compiler generates code. If the function is virtual and the call is through a reference or pointer, then the compiler generates code to determine which version to run based on the dynamic type of the object. Otherwise, the compiler generates code to call the function directly.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/10/c-primer笔记6/" data-id="cinvexis9001ftw3a9or454x3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/10/c-primer笔记5/" class="article-date">
  <time datetime="2016-03-10T08:49:14.000Z" itemprop="datePublished">2016-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/10/c-primer笔记5/">c++ primer笔记5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_protected_Members">1.  protected Members</h2><p>protected has important property: A derived object may access the  protected members of its base class only through a derived<br>object. The derived class has no special access to the protected members of base type objects. 这里说的情况是在Bulk_item的成员函数里面。如果是在user code代码里面，protected属性的成员肯定是不能访问的。<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">void Bulk_item::memfcn(<span class="keyword">const</span> Bulk_item &amp;<span class="keyword">d</span>, <span class="keyword">const</span> Item_base &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// attempt to use protected member</span></span><br><span class="line">    double <span class="keyword">ret</span> = price; <span class="comment">// ok: uses this-&gt;price</span></span><br><span class="line">    <span class="keyword">ret</span> = <span class="keyword">d</span>.price; <span class="comment">// ok: uses price from a Bulk_item object</span></span><br><span class="line">    <span class="keyword">ret</span> = b.price; <span class="comment">// error: no access to price from an Item_base</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_Derived_Classes_and_virtual_Functions">2. Derived Classes and virtual Functions</h2><p>If a derived class does not redefine a virtual, then the version it uses is the one defined in its base class. A derived type must include a declaration for each inherited member it intends to redefine.<br>With one exception, the declaration of a virtual function in the derived class must exactly match the way the function is defined in the base. That exception applies to virtuals that return a reference (or pointer) to a type that is itself a base class. A virtual function in a derived class can return a reference (or pointer) to a class that is publicly derived from the type returned by the base-class function.</p>
<h2 id="3-_Overriding_the_Virtual_Mechanism">3. Overriding the Virtual Mechanism</h2><p>In some cases, we want to override the virtual mechanism and force a call to use a particular version of a virtual function. We can do so by using the scope operator:<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">Item_base *baseP = &amp;derived;</span><br><span class="line"><span class="comment">// calls version from the base class regardless of the dynamic type of baseP</span></span><br><span class="line"><span class="keyword">double</span> d = baseP-&gt;Item_base::net_price(42);</span><br></pre></td></tr></table></figure></p>
<p>This code forces the call to  net_price to be resolved to the version defined in Item_base . The call will be resolved at compile time. When a derived virtual calls the base-class version, it must do so explicitly using the scope operator. If the derived function neglected to do so, then the call would be resolved at run time and would be a call to itself, resulting in an infinite recursion.</p>
<h2 id="4-_无题">4. 无题</h2><p>A publicly derived class inherits the interface of its base class; it has the same interface as its base class. In well-designed class hierarchies, objects of a publicly derived class can be used wherever an object of the base class is expected. By far the most common form of inheritance is public.</p>
<h2 id="5-_restore_the_access_level_of_an_inherited_member">5. restore the access level of an inherited member</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">private</span> Base &#123; . . . &#125;;</span><br></pre></td></tr></table></figure>
<p>In this hierarchy, size is public in Base but private in Derived. To make size public in Derived we can add a using declaration for it to a public section in Derived. By changing the definition of Derived as follows, we can make the size member accessible to users and n accessible to classes subsequently derived from Derived:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// maintain access levels for members related to the size of the object</span></span><br><span class="line">        <span class="keyword">using</span> Base::size;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">using</span> Base::n;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The derived class can restore the access level of an inherited member. The access level cannot be made more or less restrictive than the level originally specified within the base class.</p>
<h2 id="6-_Default_Inheritance_Protection_Levels">6. Default Inheritance Protection Levels</h2><p> A derived class defined using the class keyword has private inheritance. A class is defined with the struct keyword, has public inheritance.The only differences between class and struct are the default protection level for members and the default protection level for a derivation.<br> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> : <span class="title">Base</span> </span>&#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">// public inheritance by default</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> : <span class="title">Base</span> </span>&#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">// private inheritance by default</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/03/10/c-primer笔记5/" data-id="cinvexisc001htw3a933lt4d1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-修改linux系统下的最大文件描述符限制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/修改linux系统下的最大文件描述符限制/" class="article-date">
  <time datetime="2016-02-28T13:12:41.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/修改linux系统下的最大文件描述符限制/">修改linux系统下的最大文件描述符限制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>linux下最大文件描述符的限制有两个方面，一个是进程级的限制，另外一个则是系统级限制。</p>
<h2 id="1-_系统级的限制">1. 系统级的限制</h2><p>/proc/sys/fs/file-max是系统中的所有进程总共可以同时打开的文件数量，可以通过修改内核参数来更改该限制：<code>sysctl -w fs.file-max=102400</code>。但是，使用sysctl命令更改是临时的，如果想永久更改需要在/etc/sysctl.conf添加<code>fs.file-max=102400</code>，保存退出后使用<code>sysctl -p</code> 命令使其生效。</p>
<p>/proc/sys/fs/file-max：This  file defines a system-wide limit on the number of open files for all processes.  (See also setrlimit(2), which can be used by a process to set the per-process limit, RLIMIT_NOFILE, on the number of files it may open.) If  you get lots of error messages about running out of file handles, try increasing this value: <code>echo 100000 &gt; /proc/sys/fs/file-max</code>. The kernel constant NR_OPEN imposes an upper limit on the value that may be placed in file-max. If you  increase /proc/sys/fs/file-max, be sure to increase /proc/sys/fs/inode-max to 3-4 times the new value of /proc/sys/fs/file-max, or you will run out of inodes.</p>
<h2 id="2-_进程级的限制">2. 进程级的限制</h2><p>修改一个进程能够同时打开的文件数量限制有两种方式：(1)通过bash的内置命令ulimit (2)在程序中调用setrlimit函数</p>
<p>(1)ulimit is a bash built_in command. It provides control over the resources available to the shell and to processes started by it.<br>执行<code>ulimit -n</code>命令可以看到本次登录的shell会话的文件描述符的限制，一般情况下是1024。当然可以通过<code>ulimit -SHn 102400</code> 命令来修改该限制。<br>(2) The getrlimit() and setrlimit() system calls get and set resource limits respectively. Each resource has an associated soft and hard limit, as defined by the rlimit structure:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> rlimit &#123;</span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The soft limit is the value that the kernel enforces for the corresponding resource. The hard limit acts as a ceiling for the soft limit: an unprivileged process may only set its soft limit to a value in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit. A privileged process may make arbitrary changes to either limit value. The value RLIM_INFINITY denotes no limit on a resource. </p>
<p>不管通过ulimit还是setrlimit来修改限制，都只能对当前进程及其子进程有效。而且它们都会受到/etc/security/limits.conf文件中的数量限制。如下所示，<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">vi /etc/security/limits<span class="class">.conf</span></span><br><span class="line">xiaohua hard nofile <span class="number">100</span></span><br><span class="line">xiaohua soft nofile <span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>则用户xiaohua的每个进程能够同时打开的文件数量的上限是100，通过ulimit和setrlimit的修改的上限值不能超过它。而且可以看出，其实/etc/security/limits.conf是用户级的限制，能够限制某个用户或者用户组的每个进程能够同时打开的文件数量的上限。修改该文件，保存退出后重新登录，里面设置的值才会生效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/28/修改linux系统下的最大文件描述符限制/" data-id="cinvexiqi0009tw3ag0r2xz8y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux点滴/">linux点滴</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux点滴-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/linux点滴-1/" class="article-date">
  <time datetime="2016-02-28T08:34:15.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/linux点滴-1/">linux点滴(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_查看linux内核版本">1. 查看linux内核版本</h2><p>方法一：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令： uname -a   // uname is short for unix name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用： 查看系统内核版本号及系统名称<br>方法二：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令： cat /proc/version<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用： 查看目录”/proc”下version的信息，也可以得到当前系统的内核版本号及系统名称 </p>
<p>补充说明：／proc文件系统，它不是普通的文件系统，而是系统内核的映像。The proc file system is a pseudo-file system which is used as an interface to kernel data structures. It is commonly mounted at /proc. Most of it is read-only, but some files allow kernel variables to be changed. 我们使用命令“uname -a”的信息就是从该文件获取的。</p>
<h2 id="2-_查看进程打开的所有文件描述符">2. 查看进程打开的所有文件描述符</h2><p>方法一：<code>ll /proc/&lt;进程PID&gt;/fd/</code><br>方法二：<code>lsof -p &lt;进程PID&gt;</code></p>
<h2 id="3-_设置和查看系统资源限制ulimit">3. 设置和查看系统资源限制ulimit</h2><p>ulimit(short for user limits): it provides control over the resources available to the shell and to processes started by it.<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">Syntax</span><br><span class="line">      ulimit [-acdfHlmnpsStuv] [limit]</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line"></span><br><span class="line">   -<span class="ruby"><span class="constant">S</span>   <span class="constant">Change</span> <span class="keyword">and</span> report the soft limit associated with a resource. </span><br><span class="line"></span>   -<span class="ruby"><span class="constant">H</span>   <span class="constant">Change</span> <span class="keyword">and</span> report the hard limit associated with a resource. </span><br><span class="line"></span></span><br><span class="line">   -<span class="ruby">a   <span class="constant">All</span> current limits are reported. </span><br><span class="line"></span>   -<span class="ruby">c   <span class="constant">The</span> maximum size of core files created. </span><br><span class="line"></span>   -<span class="ruby">d   <span class="constant">The</span> maximum size of a process<span class="string">'s data segment. </span><br><span class="line"></span></span>   -<span class="ruby">f   <span class="constant">The</span> maximum size of files created by the shell(default option) </span><br><span class="line"></span>   -<span class="ruby">l   <span class="constant">The</span> maximum size that can be locked into memory. </span><br><span class="line"></span>   -<span class="ruby">m   <span class="constant">The</span> maximum resident set size. </span><br><span class="line"></span>   -<span class="ruby">n   <span class="constant">The</span> maximum number of open file descriptors. </span><br><span class="line"></span>   -<span class="ruby">p   <span class="constant">The</span> pipe buffer size. </span><br><span class="line"></span>   -<span class="ruby">s   <span class="constant">The</span> maximum stack size. </span><br><span class="line"></span>   -<span class="ruby">t   <span class="constant">The</span> maximum amount of cpu time <span class="keyword">in</span> seconds. </span><br><span class="line"></span>   -<span class="ruby">u   <span class="constant">The</span> maximum number of processes available to a single user. </span><br><span class="line"></span>   -<span class="ruby">v   <span class="constant">The</span> maximum amount of virtual memory available to the process.</span></span><br></pre></td></tr></table></figure></p>
<p>ulimit 作为对资源使用限制的一种工作，是有其作用范围的。那么，它限制的对象是单个用户，单个进程，还是整个系统呢？事实上，ulimit 限制的是当前shell进程以及其派生的子进程。举例来说，如果用户同时运行了两个shell终端进程，只在其中一个环境中执行了ulimit –f 100，则该shell进程里创建文件的大小受到相应的限制，而同时另一个shell终端包括其上运行的子程序都不会受其影响。</p>
<p>那么，是否有针对某个具体用户的资源加以限制的方法呢？答案是有的，方法是通过修改系统的 /etc/security/limits 配置文件。该文件不仅能限制指定用户的资源使用，还能限制指定组的资源使用。该文件的每一行都是对限定的一个描述，格式如下：<br><code>&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;</code><br>domain 表示用户或者组的名字，还可以使用 * 作为通配符。type 可以有两个值，soft 和 hard。item 则表示需要限定的资源，可以有很多候选值，如 stack，cpu，nofile 等等，分别表示最大的堆栈大小，占用的 cpu 时间，以及打开的文件数。通过添加对应的一行描述，则可以产生相应的限制。例如：<br><code>* hard nofile 100</code><br>该行配置语句限定了任意用户所能创建的最大文件数是100。</p>
<p>现在已经可以对进程和用户分别做资源限制了，看似已经足够了，其实不然。很多应用需要对整个系统的资源使用做一个总的限制，这时候我们需要修改 /proc 下的配置文件。/proc 目录下包含了很多系统当前状态的参数，例如 /proc/sys/kernel/pid_max，/proc/sys/net/ipv4/ip_local_port_range 等等，从文件的名字大致可以猜出所限制的资源种类。由于该目录下涉及的文件众多，在此不一一介绍。</p>
<h2 id="4-_error_while_loading_shared_libraries">4. error while loading shared libraries</h2><p>库文件在链接(静态库和共享库)和运行(仅限于使用共享库的程序，因为静态库已经链接到可执行程序中了)时被使用，其搜索路径是在系统中进行设置的。一般linux系统把 /lib 和 /usr/lib 两个目录作为默认的库搜索路径，所以使用这两个目录中的库时不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到 库的搜索路径之中。设置库文件的搜索路径有下列两种方式，可任选其一使用：</p>
<p>(1) 修改环境变量LD_LIBRARY_PATH<br>在环境变量 LD_LIBRARY_PATH 中指明库的搜索路径。例如$export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH。并且LD_LIBRARY_PATH路径优先于系统默认路径之前查找<br>(2) 修改配置文件ld.so.conf<br>添加方法也极其简单，将库文件的绝对路径直接写进去就OK了，一行一个。例如：<br>/usr/X11R6/lib<br>/usr/local/lib<br>需要注意的是：第二种搜索路径的设置方式对于程序链接时的库(包括共享库和静态库)的定位已经足够了，但是对于使用了共享库的程序的执行还是不够的。这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件 /etc/ld.so.cache 从中进行搜索的。/etc/ld.so.cache 是一个非文本的数据文件，不能直接编辑，它是根据 /etc/ld.so.conf 中设置的搜索路径由 /sbin/ldconfig 命令将这些搜索路径下的共享库文件集中在一起而生成的（ldconfig 命令要以 root 权限执行）。</p>
<p>因此，为了保证程序执行时对库的定位，在 /etc/ld.so.conf 中进行了库搜索路径的设置之后，还必须要运行 /sbin/ldconfig 命令更新 /etc/ld.so.cache 文件之后才可以。ldconfig ,简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache 以供使用。因此当安装完一些库文件，(例如刚安装好glib)，或者修改ld.so.conf增加新的库路径后，需要运行一下 /sbin/ldconfig使所有的库文件都被缓存到ld.so.cache中，如果没做，即使库文件明明就在/usr/lib下的，也是不会被使用的，结果编译过程中报错，缺少xxx库，去查看发现明明就在那放着。</p>
<p>在程序链接时，对于库文件（静态库和共享库）的搜索路径，除了上面的设置方式之外，还可以通过 -L 参数显式指定。因为用 -L 设置的路径将被优先搜索，所以在链接的时候通常都会以这种方式直接指定要链接的库的路径。</p>
<p>现代链接器在处理动态库时将 链接时路径（Link-time path）和运行时路径（Run-time path）分开,用户可以通过-L指定链接时库的路径，通过-R（或-rpath）指定程序运行时库的路径，大大提高了库应用的灵活性和搜索库文件的效率。</p>
<h2 id="5-_墙上时钟时间，用户cpu时间，系统cpu时间">5. 墙上时钟时间，用户cpu时间，系统cpu时间</h2><p>时钟时间(墙上时钟时间wall clock time)：从进程从开始运行到结束，时钟走过的时间，这其中包含了进程在阻塞和等待状态的时间。<br>用户CPU时间：用户进程获得了CPU资源以后，在用户态执行的时间。<br>系统CPU时间：用户进程获得了CPU资源以后，在内核态的执行时间。</p>
<p>进程的三种状态为阻塞、就绪、运行。</p>
<p>时钟时间 = 阻塞时间 ＋ 就绪时间 ＋ 运行时间<br>用户CPU时间 = 运行状态下用户空间的时间<br>系统CPU时间 =  运行状态下内核空间的时间</p>
<p>用户CPU时间 + 系统CPU时间 = 运行时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/28/linux点滴-1/" data-id="cinvexirp000ttw3ask5tjul1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux点滴/">linux点滴</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-select" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/select/" class="article-date">
  <time datetime="2016-02-28T08:03:55.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/select/">select</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>We should set nonblocking mode on all network handles, and use select() or poll() to tell which network handle has data waiting. With this scheme, the kernel tells you whether a file descriptor is ready. It’s particularly important to remember that readiness notification from the kernel is only a hint; the file descriptor might not be ready anymore when you try to read from it. That’s why it’s important to use nonblocking mode when using readiness notification.</p>
<p>select的基本用法不再叙述。select uses descriptor sets, typically an array of integers, with each bit in each integer corresponding to a descriptor. For example, using 32-bit integers, the first element of the array corresponds to descriptors 0 through 31, the second element of the array corresponds to descriptors 32 through 63, and so on. All the implementation details are irrelevant to the application and are hidden in the fd_set datatype and the following four macros:<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn on the bit for fd in fdset */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn off the bit for fd in fdset */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* is the bit for fd on in fdset ? */</span></span><br></pre></td></tr></table></figure></p>
<p>We allocate a descriptor set of the fd_set datatype, we set and test the bits in the set using these macros, and we can also assign it to another descriptor set across an equals sign (=) in C. The constant FD_SETSIZE, defined by including <sys select.h="">, is the number of descriptors in the fd_set datatype. Its value is often 1024.</sys></p>
<p>也就是说，使用select有一个限制，那就是它支持的文件描述符的数量，一般是1024。Many implementations have declarations similar to the following, which are taken from the 4.4BSD <sys types.h=""> header:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="id">#ifndef</span> FD_SETSIZE</span><br><span class="line"><span class="hexcolor">#def</span>ine FD_SETSIZE      <span class="number">256</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></sys></p>
<p>This makes us think that we can just #define FD_SETSIZE to some larger value before including this header to increase the size of the descriptor sets used by select. Unfortunately, this normally does not work. To see what is wrong, notice that Figure 16.53 of TCPv2 declares three descriptor sets within the kernel and also uses the kernel’s definition of FD_SETSIZE as the upper limit. The only way to increase the size of the descriptor sets is to increase the value of FD_SETSIZE and then recompile the kernel. Changing the value without recompiling the kernel is inadequate.<br>但是自己在实验的时候，发现输出1024，这是为什么呢？难道编译的是否内核里的宏定义直接覆盖用户提供的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FD_SETSIZE 512</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, FD_SETSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/28/select/" data-id="cinvexirj000ptw3avxhmcv17" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/IO/" class="article-date">
  <time datetime="2016-02-27T13:35:41.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/IO/">IO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、水平触发 VS 边缘触发</p>
<p>水平触发(level-triggered，也被称为条件触发)LT: 只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)</p>
<p>边缘触发(edge-triggered)ET: 每当状态变化时，触发一个事件(仅当状态由not ready 到 ready时触发一个事件)<br>Eedge-triggered readiness notification means you give the kernel a file descriptor, and later, when that descriptor transitions from not ready to ready, the kernel notifies you somehow. It then assumes you know the file descriptor is ready, and will not send any more readiness notifications of that type for that file descriptor until you do something that causes the file descriptor to no longer be ready (e.g. until you receive the EWOULDBLOCK error on a send, recv, or accept call, or a send or recv transfers less than the requested number of bytes). epoll is the recommended edge-triggered poll replacement for the 2.6 Linux kernel.</p>
<p>举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个read ready notification通知应用程序可读。应用程序读了50个字节，然后重新调用api等待io事件。这时水平触发的api会因为还有50个字节可读从 而立即返回用户一个read ready notification。而边缘触发的api会因为可读这个状态没有发生变化而陷入长期等待。 因此在使用边缘触发的api时，要注意每次都要读到socket返回EWOULDBLOCK为止，否则这个socket就算废了。而使用条件触发的api 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。大家常用的select就是属于水平触发这一类，长期关注socket写事件会出现CPU 100%的毛病。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/27/IO/" data-id="cinvexiyu0032tw3aagkigny5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-非阻塞调用和EINTR" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/非阻塞调用和EINTR/" class="article-date">
  <time datetime="2016-02-27T08:51:16.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/非阻塞调用和EINTR/">非阻塞调用和EINTR</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>As is known, some blocking calls like read and write would return -1 and set errno to EINTR, and we need handle this. My question is: Does this apply for non-blocking calls, e.g, set socket to O_NONBLOCK?</p>
<p>答案是：对于非阻塞调用，它们不会返回EINTR错误。 If you take a look at the man pages of various systems for the following socket functions bind(), connect(), send(), and receive(), or look those up in the POSIX standard, you’ll notice something interesting: All these functions except one may return -1 and set errno to EINTR. The one function that is not documented to ever fail with EINTR is bind(). And bind() is also the only function of that list that will never block by default. So it seems that only blocking functions may fail because of EINTR, including read() and write(), yet if these functions never block, they also will never fail with EINTR and if you use O_NONBLOCK, those functions will never block.</p>
<p>Of course, even with non-blocking I/O, the read call may have temporarily interrupted by a signal but why would the system have to indicate that? Every function call, whether this is a system function or one written by the user, may be temporarily interrupted by a signal, really every single one, no exception. If the system would have to inform the user whenever that happens, all system functions could possibly fail because of EINTR. However, even if there was a signal interruption, the functions usually perform their task all the way to the end, that’s why this interruption is irrelevant. The error EINTR is used to tell the caller that the action he has requested was not performed because of a signal interruption, but in case of non-blocking I/O, there is no reason why the function should not perform the read or the write request, unless it cannot be performed right now, but then this can be indicated by an appropriate error(EAGAIN or EWOULDBLOCK ).</p>
<p>To confirm my theory, I took a look at the kernel of MacOS (10.8), which is still largely based on the FreeBSD kernel and it seems to confirm the suspicion. If a read call is currently not possible, as no data are available, the kernel checks for the O_NONBLOCK flag in the file descriptor flags. If this flag is set, it fails immediately with EAGAIN. If it is not set, it puts the current thread to sleep by calling a function named msleep(). This function causes the current thread to sleep until it is explicitly woken up (which is the case if data becomes ready for reading) or a timeout has been hit (e.g. you can set a receive timeout on sockets). Yet the thread is also woken up, if a signal is delivered, in which case msleep() itself returns EINTR and the next higher layer just passes this error through. So it is msleep() that produces the EINTR error, but if the O_NONBLOCK flag is set, msleep() is never called in the first place, hence this error cannot be returned.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/27/非阻塞调用和EINTR/" data-id="cinvexiph0001tw3ax59mq5ls" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP系列之SIGPIPE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/25/TCP系列之SIGPIPE/" class="article-date">
  <time datetime="2016-02-25T14:16:21.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/TCP系列之SIGPIPE/">TCP系列之SIGPIPE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> When a process writes to a socket that has received an RST, the SIGPIPE signal is sent to the process. 这是UNIX网络编程卷一(5.13章节)中的内容。但是在实际的编程中发现，当套接字收到RST报文段后，第一次read或者write会产生ECONNRESET错误，第二次read或者write时才会触发SIGPIPE信号。这与UNIX网络编程卷一中的描述“当套接字接收到RST后，我们再执行write操作则会触发SIGPIPE信号”不一样。</p>
<p>The default action of this signal is to terminate the process, so the process must catch the signal to avoid being involuntarily terminated. If the process either catches the signal and returns from the signal handler, or ignores the signal, the write operation returns EPIPE. If special actions are needed when the signal occurs (writing to a log file perhaps), then the signal should be caught and any desired actions can be performed in the signal handler. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/25/TCP系列之SIGPIPE/" data-id="cinvexiyr0030tw3ajinx86or" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP系列之connect" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/25/TCP系列之connect/" class="article-date">
  <time datetime="2016-02-25T02:33:39.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/TCP系列之connect/">TCP系列之connect</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当客户端进程(例如浏览器)需要同时发起多个连接的时候，如果使用阻塞connect，那么先发起第一个连接并等待它返回，然后第二个，第三……这样效率不高，在等待连接返回的时间内，可以做一些其他的任务处理。而且，如果某个连接因为超时才返回的话，那么客户端进程阻塞在这个连接上的时间将会更多。所以，这种情况下，我们更喜欢非阻塞connect。</p>
<p>在使用非阻塞connect的时候，有以下几点需要注意：<br>1、When a TCP socket is set to nonblocking and then connect is called, connect returns immediately with an error of EINPROGRESS but the TCP three-way handshake continues.<br>2、Even though the socket is nonblocking, if the server to which we are connecting is on the same host, the connection is normally established immediately when we call connect.<br>3、POSIX have the following two rules regarding select and nonblocking connects：(1) When the connection completes successfully, the descriptor becomes writable. (2) When the connection establishment encounters an error, the descriptor becomes both readable and writable.<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">// 省略 <span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">FD_ISSET(sockfd, &amp;wset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    socklen_t error_len = sizeof(error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="keyword">getsockopt</span>(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;error_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">printf</span>(<span class="string">"connection error: <span class="variable">%s</span>"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(error != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = error;</span><br><span class="line">            <span class="keyword">printf</span>(<span class="string">"connection error: <span class="variable">%s</span>"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">printf</span>(<span class="string">"connection success"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>There are portability problems with various socket implementations and nonblocking connects. If an error occurred, Berkeley-derived implementations of getsockopt return 0 with the pending error returned in our variable error. But Solaris causes getsockopt itself to return –1 with errno set to the pending error.</p>
<p>对于一个阻塞的套接字，当我们调用connect时被信号中断了，它会返回EINTR错误。但是要注意，我们不能对这个套接字再次调用connect，否则将返回EADDRINUSE错误。此时正确的做法是调用select，就像使用非阻塞connect一样。select returns when the connection completes successfully (making the socket writable) or when the connection fails (making the socket readable and writable).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/25/TCP系列之connect/" data-id="cinvexiyo002wtw3azljb2hku" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP系列之连接建立" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/24/TCP系列之连接建立/" class="article-date">
  <time datetime="2016-02-24T03:03:49.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/24/TCP系列之连接建立/">TCP系列之连接建立</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/tcp_connect.PNG" alt=""><br>这是正常的TCP连接的三次握手过程。但是，为什么需要三次握手呢？如果只有二次握手又会有什么问题呢？</p>
<p>1、The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.这主要是为了防止已经失效的连接请求报文段突然又传送到了B，从而产生错误。具体看下面的场景：A发出连接请求报文段，但是该连接请求报文段因网络原因暂时滞留在某网络结点。A因为没有收到确认，于是重传一次连接请求报文段，这个重传的连接请求报文段被B接收到了，并且A也收到了确认，于是连接建立成功。它们传输完数据之后，释放连接。但是，此时第一个连接请求报文段奇迹般地又到达了B。本来这是一个早已失效的报文段，但是B误认为是A又发出的一个新的连接请求。于是向A发送确认报文段，同意建立连接。如果不采用三次握手，对B而言，当它发出确认报文段后，新的连接就建立了，但这并不是一个真实的连接，造成资源浪费。</p>
<p>2、如果从更深层次的角度去考虑，我们看看TCP的三次握手到底做了些什么事情。在TCP中，通讯双方都会使用序列号(sequence number)来记录自己已经发送了哪些数据。而且，接收方也会使用对方的序列号对自己已经收到的数据进行确认。从安全角度考虑，序列号不会从0开始，而是一个随机值。因为TCP是双向通讯的，双方都可以发送数据，所以双方都必须产生一个随机数来作为自己的初始序列号。当然，通讯双方也必须把自己的初始序列号告知对方，这样双方才能正常通讯。Alice和Bob之间的TCP通话是这样开始的：<br>Alice —-&gt; Bob    &nbsp;&nbsp;// SYNchronize with my Initial Sequence Number of X<br>Alice &lt;—- Bob    &nbsp;&nbsp;// I received your syn, I ACKnowledge that I am ready for [X+1]<br>Alice &lt;—- Bob    &nbsp;&nbsp;// SYNchronize with my Initial Sequence Number of Y<br>Alice —-&gt; Bob    &nbsp;&nbsp;// I received your syn, I ACKnowledge that I am ready for [Y+1]<br>Alice将自己的初始序列号告知Bob，Bob对其进行确认；Bob将自己的初始序列号告知Alice，Alice对其进行确认。实际上，为了提高效率，第2步和第3步是在同一个报文段中完成的。<br>Alice —-&gt; Bob     &nbsp;&nbsp;// SYN<br>Alice &lt;—- Bob     &nbsp;&nbsp;// SYN ACK<br>Alice —-&gt; Bob     &nbsp;&nbsp;// ACK<br>所以，如果只有两次握手的话，所实现的只是Alice将自己的初始序列号告知了Bob，Bob也对其进行了确认。即只能Alice对Bob发送数据，但是Bob却不能对Alice发送数据。</p>
<p>3、下面的英文解释跟2是同样道理的。<br>To establish a connection, the three-way (or 3-step) handshake occurs:<br>(1) SYN: The active open is performed by the client sending a SYN to the server. The client sets the segment’s sequence number to a random value A.<br>(2) SYN-ACK: In response, the server replies with a SYN-ACK. The acknowledgment number is set to one more than the received sequence number i.e. A+1, and the sequence number that the server chooses for the packet is another random number, B.<br>(3) ACK: Finally, the client sends an ACK back to the server. The sequence number is set to the received acknowledgement value i.e. A+1, and the acknowledgement number is set to one more than the received sequence number i.e. B+1.</p>
<p>At this point, both the client and server have received an acknowledgment of the connection. The steps 1, 2 establish the connection parameter (sequence number) for one direction and it is acknowledged. The steps 2, 3 establish the connection parameter (sequence number) for the other direction and it is acknowledged. With these, a full-duplex communication is established.</p>
<p>4、两次握手更容易遭受DoS攻击<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Sender           Receiver</span><br><span class="line">           SYN</span><br><span class="line">------------------------&gt; <span class="list">(<span class="keyword">Connection</span> established at Receiver)</span></span><br><span class="line"></span><br><span class="line">        SYN + ACK</span><br><span class="line">&lt;------------------------ <span class="list">(<span class="keyword">Connection</span> established at Sender)</span></span><br></pre></td></tr></table></figure></p>
<p>The above sequence of steps shows what should happen ideally. Now, how easy it is to make DoS attack. Simply, send a SYN packet to the Receiver and it would open a connection at Receiver. Sender need not even care about (SYN + ACK) packet coming back from Receiver.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/24/TCP系列之连接建立/" data-id="cinvexiyk002rtw3a58h9dili" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP系列之连接关闭" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/24/TCP系列之连接关闭/" class="article-date">
  <time datetime="2016-02-24T03:02:08.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/24/TCP系列之连接关闭/">TCP系列之连接关闭</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/tcp_close.PNG" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是正常的TCP释放连接过程。其中，最不容易让人理解的地方就是时间等待(TIME-WAIT)状态。从上图可以看到，主动关闭连接的一方会经历时间等待状态，并且TIME-WAIT状态要持续2MSL(最长报文段寿命，Maximum Segment Life)，之后才能进入CLOSED状态。那为什么主动关闭连接的一方要处于TIME-WAIT状态并等待2MSL时间呢？</p>
<p>1、为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而是处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，那么A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后A和B都正常进入到CLOSED状态。</p>
<p>2、为了保证已经失效的重复报文段(old duplicate segments)都从网络中消失。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使在本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接(源IP、源端口、目的IP、目的端口完全一样)中不会出现这种旧的报文段。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To understand the second reason for the TIME_WAIT state, assume we have a TCP connection between 12.106.32.254 port 1500 and 206.168.112.219 port 21. This connection is closed and then sometime later, we establish another connection between the same IP addresses and ports: 12.106.32.254 port 1500 and 206.168.112.219 port 21. This latter connection is called an incarnation of the previous connection since the IP addresses and ports are the same. TCP must prevent old duplicates from a connection from reappearing at some later time and being misinterpreted as belonging to a new incarnation of the same connection. To do this, TCP will not initiate a new incarnation of a connection that is currently in the TIME_WAIT state. By enforcing this rule, we are guaranteed that when we successfully establish a TCP connection, all old duplicates from previous incarnations of the connection have expired in the network.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/24/TCP系列之连接关闭/" data-id="cinvexiym002utw3ame1jmuip" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP系列之accept" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/24/TCP系列之accept/" class="article-date">
  <time datetime="2016-02-24T02:52:56.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/24/TCP系列之accept/">TCP系列之accept</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/tcp_accept.PNG" alt=""></p>
<h2 id="0x01_描述">0x01 描述</h2><p>上图表示的是已经建立好TCP连接之后，在服务端还没有调用accept之前接收到了RST报文段的异常情况。但是，对这种异常终止的连接的处理是依赖于不同的实现的。源自Berkeley的实现完全在内核里处理这种异常终止的连接，内核不会将这个连接传递给服务器进程。然而，大多数的SVR4的实现在服务器进程调用accept的时候返回一个错误值，该错误值依赖于具体的实现。这些SVR4实现返回一个EPROTO (protocol error)错误，但是POSIX规定返回ECONNABORTED(“software caused connection abort”)错误。</p>
<h2 id="0x02_与select结合的问题">0x02 与select结合的问题</h2><p>我们知道，当有一个新的连接建立的时候，select会把监听套接字描述符标识为可读，然后我们可以调用accept去获得这个连接。那现在看下面的场景：<br>1、客户端与服务端建立连接<br>2、服务器进程的select标识监听套接字可读，但是它因为处理其他事情，并没有立即调用accept<br>3、客户端终止连接，并发送RST报文段<br>4、此时服务器进程调用accept，这时会有什么结果呢？如果监听套接字描述符是阻塞的，那么在源自Berkeley的实现上，该accept将会阻塞，直到有新的连接到来，在其他的实现上则会返回一个错误。如果监听套接字描述符是非阻塞的，那么在源自Berkeley的实现上，会返回EWOULDBLOCK错误，在其他的实现上则会返回ECONNABORTED或者EPROTO错误。</p>
<p>所以，针对这种情况的解决方案是：<br>1、将监听套接字描述符始终设置为非阻塞的。<br>2、当accpet返回-1时，检查errno的值是否是：EWOULDBLOCK(源自Berkeley的实现)、ECONNABORTED(POSIX实现)、EPROTO(SVR4实现)</p>
<p>一个小插曲：EAGAIN or EWOULDBLOCK, The socket is marked nonblocking and no connections are present to be accepted. POSIX.1-2001 and POSIX.1-2008 allow either error to be returned for this case, and do not require these constants to have the same value, so a portable application should check for both possibilities.</p>
<h2 id="0x03_SO_LINGER_Socket_Option">0x03 SO_LINGER Socket Option</h2><p>This option specifies how the close function operates for a connection-oriented protocol. By default, close returns immediately, but if there is any data still remaining in the socket send buffer, the system will try to deliver the data to the peer. The SO_LINGER socket option lets us change this default. This option requires the following structure to be passed between the user process and the kernel.<br><figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> </span>&#123;</span><br><span class="line">  int   l_onoff;        /* <span class="number">0</span>=off, nonzero=<span class="keyword">on</span> */</span><br><span class="line">  int   l_linger;       /* linger time, POSIX specifies units <span class="keyword">as</span> seconds */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Calling setsockopt leads to one of the following three scenarios:<br>1、If l_onoff is 0, the option is turned off. The value of l_linger is ignored and the previously discussed TCP default applies: close returns immediately.<br>2、If l_onoff is nonzero and l_linger is zero, TCP aborts the connection when it is closed. That is, TCP discards any data still remaining in the socket send buffer and sends an RST to the peer, not the normal four-packet connection termination sequence. This avoids TCP’s TIME_WAIT state, but in doing so, leaves open the possibility of another incarnation of this connection being created within 2MSL seconds and having old duplicate segments from the just-terminated connection being incorrectly delivered to the new incarnation.<br>3、If l_onoff is nonzero and l_linger is nonzero, then the kernel will linger when the socket is closed. That is, if there is any data still remaining in the socket send buffer, the process is put to sleep until either: (i) all the data is sent and acknowledged by the peer TCP, or (ii) the linger time expires. If the socket has been set to nonblocking, it will not wait for the close to complete, even if the linger time is nonzero. When using this feature of the SO_LINGER option, it is important for the application to check the return value from close, because if the linger time expires before the remaining data is sent and acknowledged, close returns EWOULDBLOCK and any remaining data in the send buffer is discarded.</p>
<p>当我们调用close，并从其返回之后，到底意味着什么呢？The basic principle here is that a successful return from close, with the SO_LINGER socket option set, only tells us that the data we sent (and our FIN) have been acknowledged by the peer TCP. This does not tell us whether the peer application has read the data. If we do not set the SO_LINGER socket option, we do not know whether the peer TCP has acknowledged the data. </p>
<p>One way for the client to know that the server has read its data is to call shutdown (with a second argument of SHUT_WR) instead of close and wait for the peer to close its end of the connection.<br><img src="/img/tcp_shutdown.PNG" alt=""></p>
<h2 id="0x04_发送RST报文段">0x04 发送RST报文段</h2><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">struct linger ling<span class="comment">;</span></span><br><span class="line">ling.l_onoff = 1<span class="comment">;          /* cause RST to be sent on close() */</span></span><br><span class="line">ling.l_linger = 0<span class="comment">;</span></span><br><span class="line">setsockopt(sockfd, SOL\_SOCKET, SO\_LINGER, &amp;ling, sizeof(ling))<span class="comment">;</span></span><br><span class="line">close(sockfd)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/02/24/TCP系列之accept/" data-id="cinvexiyq002ytw3aefjjguni" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/30/c-primer笔记4/" class="article-date">
  <time datetime="2016-01-30T03:39:57.000Z" itemprop="datePublished">2016-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/c-primer笔记4/">c++ primer笔记4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Conversion_Operators">1. Conversion Operators</h2><p>A conversion operator is a special kind of class member function. It defines a conversion that converts a value of a class type to a value of some other type. A conversion operator is declared in the class body by specifying the keyword  operator followed by the type that is the target type of the conversion.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> SmallInt </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt initializer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>A conversion function takes the general form <code>operator type()</code>.<br>A conversion function must be a member function. The function may not specify a return type, and the parameter list must be empty.<br>A class-type conversion may not be followed by another class-type conversion. If more than one class-type conversion is needed then the code is in error. 例如，A可以转换成B，B可以转换成C，那么在需要C的地方提供一个A是错误的。</p>
<h2 id="2-_Explicit_Conversion_Cast">2. Explicit Conversion Cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function">SmallInt <span class="title">si</span><span class="params">(18)</span></span>;</span><br><span class="line"><span class="keyword">int</span> sum1 = si + a; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> sum2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + a; <span class="comment">// ok, instruct compiler to cast si to int</span></span><br></pre></td></tr></table></figure>
<h2 id="3-_Ambiguities_When_Two_Classes_Define_Conversions">3. Ambiguities When Two Classes Define Conversions</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Integral</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SmallInt(Integral &amp;); <span class="comment">// convert from Integral to SmallInt</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Integral</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">SmallInt</span>(<span class="params"></span>) <span class="keyword">const</span></span>; <span class="comment">// convert from SmallInt to Integral</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span>(<span class="params">SmallInt</span>)</span>;</span><br><span class="line">Integral int_val;</span><br><span class="line">compute(int_val); <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure>
<p>In this case, we cannot use a cast to resolve the ambiguity, the cast itself could use either the conversion operation or the constructor. Instead, we would need to explicitly call the conversion operator or the constructor:<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">compute<span class="list">(<span class="keyword">int_val</span>.operator SmallInt<span class="list">()</span>)</span><span class="comment">; // ok: use conversion operator</span></span><br><span class="line">compute<span class="list">(<span class="keyword">SmallInt</span><span class="list">(<span class="keyword">int_val</span>)</span>)</span><span class="comment">; // ok: use SmallInt constructor</span></span><br></pre></td></tr></table></figure></p>
<p>The best way to avoid ambiguities or surprises is to avoid writing pairs of classes where each offers an implicit conversion to the other.</p>
<h2 id="4-_Multiple_Conversions_and_Overload_Resolution">4. Multiple Conversions and Overload Resolution</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> SmallInt &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Conversions to int or double from SmallInt</span></span><br><span class="line">        <span class="comment">// Usually it is unwise to define conversions to multiple arithmetic types</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">SmallInt si;</span><br><span class="line">compute(si); <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure>
<p>In this case we could use the operator int to convert si and call the version of compute that takes an int. Or we could use  operator double to convert si and call compute(double). The solutions is<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">compute(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si)); <span class="comment">// ok: convert and call compute(int)</span></span><br></pre></td></tr></table></figure></p>
<p>Let’s look at overload resolution when multiple conversion constructors exist:<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SmallInt(<span class="keyword">int</span> = 0);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Integral(<span class="keyword">int</span> = 0);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> Integral&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> SmallInt&amp;)</span></span>;</span><br><span class="line">manip(<span class="number">10</span>); <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure></p>
<p>The caller can disambiguate by explicitly constructing a value of the desired type:<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">manip<span class="list">(<span class="keyword">SmallInt</span><span class="list">(<span class="number">10</span>)</span>)</span><span class="comment">; // ok: call manip(SmallInt)</span></span><br><span class="line">manip<span class="list">(<span class="keyword">Integral</span><span class="list">(<span class="number">10</span>)</span>)</span><span class="comment">; // ok: call manip(Integral)</span></span><br></pre></td></tr></table></figure></p>
<p>Needing to use a constructor or a cast to convert an argument in a call to an overloaded function is a sign of bad design.</p>
<h2 id="5-_标准转换优于类类型转换">5. 标准转换优于类类型转换</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongDouble</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    LongDouble(<span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(LongDouble)</span></span>;</span><br><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line">calc(dval); <span class="comment">// which function?</span></span><br></pre></td></tr></table></figure>
<p>调用void calc(int)所需要的转换：将实参dval由double类型转换为int<br>调用void calc(LongDouble)需要的转换：将实参dval由double类型转换为LongDouble<br>因为标准转换优于类类型转换，所以void calc(int)为最佳可行函数</p>
<h2 id="6-_Caution:_Conversions_and_Operators">6. Caution: Conversions and Operators</h2><p>Correctly designing the overloaded operators, conversion constructors, and conversion functions for a class requires some care. In particular, ambiguities are easy to generate if a class defines both conversion operators and overloaded operators. A few rules of thumb can be helpful:</p>
<ol>
<li>Never define mutually converting classes, that is, if class Foo has a constructor that takes an object of class Bar, do not give class Bar a conversion operator to type Foo.</li>
<li>Avoid conversions to the built-in arithmetic types. In particular, if you do define a conversion to an arithmetic type, then<br> (1) Do not define overloaded versions of the operators that take arithmetic types. If users need to use these operators, the<br>conversion operation will convert objects of your type, and then the built-in operators can be used.<br> (2)Do not define a conversion to more than one arithmetic type. Let the standard conversions provide conversions to the other<br>arithmetic types.</li>
</ol>
<p>The easiest rule of all: Avoid defining conversion functions and limit nonexplicit constructors to those that are “obviously right.”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/01/30/c-primer笔记4/" data-id="cinvexise001jtw3a62tnf9or" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/25/c-primer笔记3/" class="article-date">
  <time datetime="2016-01-25T06:57:10.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/25/c-primer笔记3/">c++ primer笔记3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、数组元素和容器元素的初始化">1、数组元素和容器元素的初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>The compiler initializes  svec by first using the default  string constructor to create a temporary value. The copy constructor is then used to copy the temporary into each element of svec.<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span> strs[<span class="number">5</span>] = &#123;<span class="type">string</span>(<span class="string">"ff"</span>), <span class="type">string</span>(<span class="string">"22"</span>)&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一、二个元素用拷贝构造函数初始化，其余的用默认构造函数初始化</p>
<h2 id="2、禁止复制">2、禁止复制</h2><p>By declaring (but not defining) a  private copy constructor, we can forestall any attempt to copy an object of the class type: Attempts to make copies in user code will be flagged as an error at compile time, and attempts to make copies in member functions or friends will result in an error at link time.</p>
<h2 id="3、复制构造函数、赋值运算符、析构函数">3、复制构造函数、赋值运算符、析构函数</h2><p>A useful rule of thumb is that if a class needs a destructor, it will also need the assignment operator and a copy constructor.<br>This rule is often referred to as the Rule of Three.<br>An important difference between the destructor and the copy constructor or assignment operator is that even if we write our own destructor, the synthesized destructor is still run.<br>Best Practice：The assignment operator often does the same work as is needed in the copy constructor and destructor. In such cases, the common work should be put in  private utility functions.</p>
<h2 id="4-运算符重载">4.运算符重载</h2><p>An overloaded operator must have at least one operand of class or enumeration type. This rule enforces the requirement that an overloaded operator may not redefine the meaning of the operators when applied to objects of built-in type.<br>Overloaded operators make no guarantees about the order in which operands are evaluated. In particular, the operand-evaluation guarantees of the built-in logical AND, logical OR, and comma operators are not preserved. Both operands to an overloaded version of  &amp;&amp; or  || are always evaluated. The order in which those operands are evaluated is not stipulated. The order in which the operands to the comma are evaluated is also not defined. For this reason, it is usually a bad idea to overload  &amp;&amp;, || , or the comma operator.</p>
<h2 id="5-Overloading_the_Output_Operator_&lt;&lt;">5.Overloading the Output Operator  &lt;&lt;</h2><p>To be consistent with the IO library, the operator should take an ostream&amp; as its first parameter and a reference to a  const object of the class type as its second. The operator should return a reference to its  ostream parameter.<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> ClassType &amp;<span class="keyword">object</span>)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The ostream is non const because writing to the stream changes its state. The parameter is a reference because we cannot copy an  ostream object.</p>
<h2 id="6-_Overloading_the_Input_Operator_&gt;&gt;">6. Overloading the Input Operator &gt;&gt;</h2><p>A more important, and less obvious, difference between input and output operators is that input operators must deal with the<br>possibility of errors and end-of-file.<br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">istream&amp;<span class="function"> operator&gt;&gt;(</span>istream&amp; in, Sales_item&amp; s<span class="function">)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="instruction"> double </span>price;</span><br><span class="line">    in &gt;&gt; s.isbn &gt;&gt; s.units_sold &gt;&gt; price;</span><br><span class="line">    //<span class="instruction"> check </span>that the inputs succeeded</span><br><span class="line">   <span class="instruction"> if </span>(in<span class="function">)</span></span><br><span class="line">        s.revenue = s.units_sold * price;</span><br><span class="line">    else</span><br><span class="line">        s =<span class="function"> Sales_item(</span><span class="function">)</span>; // input failed: reset object to default state</span><br><span class="line">   <span class="instruction"> return </span>in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Our Sales_item input operator reads the expected values and checks whether an error occurred. The kinds of errors that might happen include:</p>
<ol>
<li>Any of the read operations could fail because an incorrect value was provided. For example, after reading  isbn , the input operator assumes that the next two items will be numeric data. If nonnumeric data is input, that read and any subsequent use of the stream will fail.</li>
<li>Any of the reads could hit end-of-file or some other error on the input stream. </li>
</ol>
<p>Rather than checking each read, we check once before using the data we read. If an input operator detects that the input failed, it is often a good idea to make sure that the object is in a usable and consistent state. Doing so is particularly important if the object might have been partially written before the error occurred.<br>In addition to handling any errors that might occur, an input operator might need to set the condition state of its input  istream parameter.Our input operator is quite simple, the only errors we care about are those that could happen during the reads. If the reads succeed, then our input operator is correct and has no need to do additional checking.<br>Some input operators do need to do additional checking. For example, our input operator might check that the  isbn we read is in an appropriate format. We might have read data successfully, but these data might not be suitable when interpreted as an ISBN. In such cases, the input operator might need to set the condition state to indicate failure, even though technically speaking the actual IO was successful. Usually an input operator needs to set only the failbit. Setting eofbit would imply that the file was exhausted, and setting badbit would indicate that the stream was corrupted. These errors are best left to the IO library itself to indicate.</p>
<h2 id="7-_Subscript_Operator">7. Subscript Operator</h2><p>One complication in defining the subscript operator is that we want it to do the right thing when used as either the left- or right-hand operand of an assignment. To appear on the left-handside, it must yield an lvalue, which we can achieve by specifying the return type as a reference. As long as subscript returns a reference, it can be used on either side of an assignment.<br>It is also a good idea to be able to subscript  const and non const objects. When applied to a const object, the return should be a const reference so that it is not usable as the target of an assignment.<br>Ordinarily, a class that defines subscript needs to define two versions: one that is a non const member and returns a reference and one that is a  const member and returns a const reference.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">size_t</span>) <span class="keyword">const</span>;</span><br><span class="line">        <span class="comment">// other interface members</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="comment">// other member data and private utility functions</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; Foo::<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> data[index]; <span class="comment">// no range checking on index</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; Foo::<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">size_t</span> index) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> data[index]; <span class="comment">// no range checking on index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-_Member_Access_Operators">8. Member Access Operators</h2><p>To support pointerlike classes, such as iterators, the language allows the dereference ( * ) and arrow ( -&gt;) operators to be overloaded. The dereference and arrow operators are often used in classes that implement smart pointers.<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private class for use by ScreenPtr only</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrPtr</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">ScreenPtr</span>;</span><br><span class="line">    <span class="title">Screen</span> *<span class="title">sp</span>;</span><br><span class="line">    <span class="title">size_t</span> <span class="title">use</span>;</span><br><span class="line">    <span class="title">ScrPtr</span>(<span class="title">Screen</span> *<span class="title">p</span>): <span class="title">sp</span>(<span class="title">p</span>), <span class="title">use</span>(1) </span>&#123; &#125;</span><br><span class="line">    ~ScrPtr() &#123; <span class="keyword">delete</span> sp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenPtr</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// no default constructor: ScreenPtrs must be bound to an object</span></span><br><span class="line">        ScreenPtr(Screen *p): ptr(<span class="keyword">new</span> ScrPtr(p)) &#123; &#125;</span><br><span class="line">        <span class="comment">// copy members and increment the use count</span></span><br><span class="line">        ScreenPtr(<span class="keyword">const</span> ScreenPtr &amp;orig):</span><br><span class="line">            ptr(orig.ptr) &#123; ++ptr-&gt;<span class="keyword">use</span>; &#125;</span><br><span class="line">        ScreenPtr&amp; operator=(<span class="keyword">const</span> ScreenPtr&amp; rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            ++rhs.ptr-&gt;<span class="keyword">use</span>; <span class="comment">// increment use count on rhs first</span></span><br><span class="line">            <span class="keyword">if</span> (--ptr-&gt;<span class="keyword">use</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">delete</span> ptr; <span class="comment">// if use count goes to 0 on this object, delete it</span></span><br><span class="line">            ptr = rhs.ptr;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~ScreenPtr() &#123; <span class="keyword">if</span> (--ptr-&gt;<span class="keyword">use</span> == <span class="number">0</span>) <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ScrPtr *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Among the fundamental operations a pointer supports are dereference and arrow. We can give our class these operations as follows:<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ScreenPtr</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// constructor and copy control members as before</span></span><br><span class="line">        Screen &amp;<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr-&gt;sp; &#125;</span><br><span class="line">        Screen *<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr-&gt;sp; &#125;</span><br><span class="line">        <span class="keyword">const</span> Screen &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr-&gt;sp; &#125;</span><br><span class="line">        <span class="keyword">const</span> Screen *<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr-&gt;sp; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ScrPtr *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Operator arrow is unusual. It may appear to be a binary operator that takes an object and a member name, dereferencing the object in order to fetch the member. Despite appearances, the arrow operator takes no explicit parameter.<br>There is no second parameter because the right-hand operand of  -&gt; is not an expression. Rather, the right-hand operand is an identifier that corresponds to a member of a class. There is no obvious, useful way to pass an identifier as a parameter to a function. Instead, the compiler handles the work of fetching the member. The overloaded arrow operator must return either a pointer to a class type or an object of a class type that defines its own operator arrow. When we write <code>point-&gt;action()</code>, the compiler evaluates this code as follows:</p>
<ol>
<li>If  point is a pointer to a class object that has a member named  action , then the compiler writes code to call the  action member of that object.</li>
<li>Otherwise, if  point is an object of a class that defines  operator-&gt; , then  point-&gt;action is the same as  point.operator-&gt;()-&gt;action. That is, we execute  operator-&gt;() on  point and then repeat these three steps, using the result of executing  operator-&gt; on point.</li>
<li>Otherwise, the code is in error.<h2 id="9-_Arithmetic_and_Relational_Operators">9. Arithmetic and Relational Operators</h2>最佳实践:将+、-、&lt;、&gt;等操作符定义为非成员函数，因为它们不改变对象的状态；将+=等定义为成员函数，因为它们改变了对象的状态。<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Sales_item  operator+(<span class="keyword">const</span> Sales_item&amp; lhs, <span class="keyword">const</span> Sales_item&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_item <span class="keyword">ret</span>(lhs); <span class="comment">// copy lhs into a local object that we'll return</span></span><br><span class="line">    <span class="keyword">ret</span> += rhs; <span class="comment">// add in the contents of rhs</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ret</span>; <span class="comment">// return ret by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意，+重载操作符调用了+=重载操作符。同样的，==和!=也应该只实现一套逻辑，让其中一个去调用另外一个。</p>
<h2 id="10-_Call_Operator_and_Function_Objects">10. Call Operator and Function Objects</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> GT_cls &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        GT_cls(<span class="keyword">size_t</span> val = <span class="number">0</span>): bound(val) &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span><br><span class="line">        </span>&#123; <span class="keyword">return</span> s.size() &gt;= bound; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="keyword">size_t</span>ype bound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">count_if(words.begin(), words.end(), GT_cls(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
<p>The standard library defines a set of arithmetic, relational, and logical function-object classes. The library also defines a set of function adaptors that allow us to specialize or extend the function-object classes defined by the library or those that we define ourselves. The library function-object types are defined in the functional header.<br>using a library function object with the algorithms:<br><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">sort(svec.<span class="keyword">begin</span><span class="literal">()</span>, svec.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">string</span>&gt;<span class="literal">()</span>);</span><br></pre></td></tr></table></figure></p>
<p>The standard library provides a set of function adaptors with which to specialize and extend both unary and binary function objects. The function adaptors are divided into the following two categories.</p>
<ol>
<li>Binders: A binder is a function adaptor that converts a binary function object into a unary function object by binding one of the operands to a given value.</li>
<li>Negators: A negator is a function adaptor that reverses the truth value of a predicate function object.</li>
</ol>
<p>The library defines two binder adaptors:  bind1st and  bind2nd . Each binder takes a function object and a value. As you might expect,  bind1st binds the given value to the first argument of the binary function object, and  bind2nd binds the value to the second. For example, to count all the elements within a container that are less than or equal to  10 , we would pass  count_if the<br>following:<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">count_if<span class="list">(<span class="keyword">vec</span>.begin<span class="list">()</span>, vec.end<span class="list">()</span>, bind2nd<span class="list">(<span class="keyword">less_equal&lt;int&gt;</span><span class="list">()</span>, <span class="number">10</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>The third argument to  count_if uses the  bind2nd function adaptor. That adaptor returns a function object that applies the  &lt;= operator using 10 as the right-hand operand. This call to count_if counts the number of elements in the input range that are less than or equal to 10.<br>The library also provides two negators:  not1 and  not2 . Again, as you might expect,  not1 reverses the truth value of a unary predicate function object, and  not2 reverses the truth value of a binary predicate function object.<br>To negate our binding of the  less_equal function object, we would write<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">count_if<span class="list">(<span class="keyword">vec</span>.begin<span class="list">()</span>, vec.end<span class="list">()</span>, not1<span class="list">(<span class="keyword">bind2nd</span><span class="list">(<span class="keyword">less_equal&lt;int&gt;</span><span class="list">()</span>, <span class="number">10</span>)</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>Here we first bind the second operand of the  less_equal object to  10 , effectively transforming that binary operation into a unary operation. We then negate the return from the operation using  not1 . The effect is that each element will be tested to see if it is  &lt;= to 10. Then, the truth value of that result will be negated. In effect, this call counts those elements that are not  &lt;= to 10.</p>
<h2 id="11-_Defining_the_Increment/Decrement_Operators">11. Defining the Increment/Decrement Operators</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CheckedPtr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CheckedPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// prefix operators</span></span><br><span class="line">        CheckedPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">        CheckedPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// postfix operators</span></span><br><span class="line">        CheckedPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/01/25/c-primer笔记3/" data-id="cinvexisg001ltw3ah6hm8bd7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/24/c-primer笔记2/" class="article-date">
  <time datetime="2016-01-24T07:51:15.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/24/c-primer笔记2/">c++ primer笔记2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、构造函数初始化列表">1、构造函数初始化列表</h2><p>Conceptually, we can think of a constructor as executing in two phases: (1) the initialization phase and (2) a general computation phase. The computation phase consists of all the statements within the body of the constructor. Data members of class type are always initialized in the initialization phase, regardless of whether the member is initialized explicitly in the constructor initializer list. Initialization happens before the computation phase begins.<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="label">    public:</span></span><br><span class="line">        // 调用<span class="keyword">string的复制构造函数</span><br><span class="line"></span>        A(const <span class="keyword">string </span>&amp;<span class="keyword">str) </span>: <span class="preprocessor">data</span>(<span class="keyword">str)</span><br><span class="line"></span></span><br><span class="line">        // 第一阶段调用<span class="keyword">string的默认构造函数，第二阶段调用string的赋值操作符</span><br><span class="line"></span>        A(const <span class="keyword">string </span>&amp;<span class="keyword">str)</span><br><span class="line"></span>        &#123;</span><br><span class="line">            <span class="preprocessor">data</span> = <span class="keyword">str;</span><br><span class="line"></span>        &#125;</span><br><span class="line"><span class="label"></span><br><span class="line">    private:</span></span><br><span class="line">        <span class="keyword">string </span><span class="preprocessor">data</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>Some members must be initialized in the constructor initializer. Members of a class type that do not have a default constructor and members that are  const or reference types must be initialized in the constructor initializer regardless of type.<br>The order in which members are initialized is the order in which the members are defined, not the order in which the initializer list provides.</p>
<h2 id="2、隐式类型转换函数">2、隐式类型转换函数</h2><p>A constructor that can be called with a single argument defines an implicit conversion from the parameter type to the class type.Ordinarily, single-parameter constructors should be explicit unless there is an obvious reason to want to define an implicit conversion. Making constructors explicit may avoid mistakes, and a user can explicitly construct an object when a conversion is useful.</p>
<h2 id="3、友元的声明和范围">3、友元的声明和范围</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window_Mgrmust be defined before class Screen</span></span><br><span class="line">    <span class="keyword">friend</span> Window_Mgr&amp; Window_Mgr::relocate(<span class="keyword">int</span>, <span class="keyword">int</span>, Screen&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Interdependencies among friend declarations and the definitions of the friends can require some care in order to structure the classes correctly. In the previous example, class  Window_Mgr must have been defined. Otherwise, class  Screen could not name a  Window_Mgr function as a friend. However, the  relocate function itself can’t be defined until class  Screen has been defined. After all, it was made a friend in order to access the members of class  Screen.<br>A friend declaration introduces the named class or nonmember function into the surrounding scope. Moreover, a friend function<br>may be defined inside the class. The scope of the function is exported to the scope enclosing the class definition.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">Y</span></span>;</span><br><span class="line">    <span class="function">friend <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* ok to define friend function in the class body */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    Y *ymem; <span class="comment">// ok: declaration for class Y introduced by friend in X</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ::f(); &#125; <span class="comment">// ok: declaration of f introduced by X</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4、静态成员">4、静态成员</h2><p>Because a static member is not part of any object,  static member functions may not be declared as const . After all, declaring a member function as const is a promise not to modify the object of which the function is a member. Finally, static member functions may also not be declared as virtual.<br>static data members must be defined (exactly once) outside the class body.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Account </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">applyint</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// sets a new rate</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> owner;</span><br><span class="line">        <span class="keyword">double</span> amount;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br><span class="line"><span class="keyword">void</span> Account::test()</span><br><span class="line">&#123;</span><br><span class="line">    initRate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Like other member definitions, the definition of a static member is in class scope once the member name is seen. 静态数据成员interestRate的定义和静态函数test的定义都是在class类作用域内，所以它们都可以使用类作用域内的成员，哪怕它们是private。As a result, we can use the static member function named initRate directly without qualification as the initializer for interestRate. Note that even though initRate is private, we can use this function to initialize interestRate. The definition of interestRate, like any other member definition, is in the scope of the class and hence has access to the  private members of the class. The static keyword, however, is used only on the declaration inside the class body. Definitions are not labeled static.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Account </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// sets a new rate</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> period = <span class="number">30</span>; <span class="comment">// interest posted every 30 days</span></span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">daily_t</span>bl[period]; <span class="comment">// ok: period is constant expression</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>A const static data member of integral type can be initialized within the class body.When a  const static data member is initialized in the class body, the data member must still be defined outside the class definition.<br><code>const int Account::period;</code></p>
<h2 id="5、静态成员不是类对象的一部分">5、静态成员不是类对象的一部分</h2><p>Because static data members are not part of any object, they can be used in ways that would be illegal for non static data members.<br>As an example, the type of a  static data member can be the class type of which it is a member. A non static data member is restricted to being declared as a pointer or a reference to an object of its class:<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> Bar mem1; <span class="comment">// ok</span></span><br><span class="line">        Bar *mem2; <span class="comment">// ok</span></span><br><span class="line">        Bar mem3; <span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>a static data member can be used as a default argument:<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Screen</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Screen&amp; clear(<span class="keyword">char</span> = bkground);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground = <span class="string">'#'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/01/24/c-primer笔记2/" data-id="cinvexix20023tw3a6ab1tg24" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer笔记1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/24/c-primer笔记1/" class="article-date">
  <time datetime="2016-01-24T02:11:17.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/24/c-primer笔记1/">c++ primer笔记1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_基本数据类型">1. 基本数据类型</h2><table>
<thead>
<tr>
<th>容器定义的类型别名</th>
<th>&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>Unsigned integral type large enough to hold size of largest possible container of this container type</td>
</tr>
<tr>
<td>iterator</td>
<td>Type of the iterator for this container type</td>
</tr>
<tr>
<td>const_iterator</td>
<td>Type of the iterator that can read but not write the elements</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>Iterator that addresses elements in reverse order</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>Reverse iterator that can read but not write the elements</td>
</tr>
<tr>
<td>difference_type</td>
<td>Signed integral type large enough to hold the difference, which might be negative, between two iterators</td>
</tr>
<tr>
<td>value_type</td>
<td>Element type</td>
</tr>
<tr>
<td>reference</td>
<td>Element’s lvalue type; synonym for value_type&amp;</td>
</tr>
<tr>
<td>const_reference</td>
<td>Element’s const lvalue type; same as  const value_type&amp;</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Types Defined by the map Class</th>
<th>&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v="">::key_type</k,></td>
<td>The type of the keys used to index the map.</td>
</tr>
<tr>
<td>map<k, v="">::mapped_type</k,></td>
<td>The type of the values associated with the keys in the map.</td>
</tr>
<tr>
<td>map<k, v="">::value_type</k,></td>
<td>A pair whose first element has type const map<k, v="">::key_type and  second has type map<k, v="">::mapped_type </k,></k,></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>iterator的类型成员</th>
<th>&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>value_type</td>
<td>该迭代器实际指向的数据的类型T</td>
</tr>
<tr>
<td>pointer</td>
<td>T *</td>
</tr>
<tr>
<td>reference</td>
<td>T&amp;</td>
</tr>
</tbody>
</table>
<h2 id="2、对迭代器解引用返回的是元素的引用">2、对迭代器解引用返回的是元素的引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ilist.empty()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// val and val2 refer to the same element</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reference val = *ilist.begin();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reference val2 = ilist.front();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// last and last2 refer to the same element</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reference last = *--ilist.end();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reference last2 = ilist.back(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、map的下标操作">3、map的下标操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count[<span class="string">"Anna"</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>word_count is searched for the element whose key is  Anna . The element is not found.</li>
<li>A new keyvalue pair is inserted into  word_count . The key is a  const string holding  Anna .<br>The value is value initialized, meaning in this case that the value is 0.</li>
<li>The new keyvalue pair is inserted into  word_count .</li>
<li>The newly inserted element is fetched and is given the value 1.</li>
</ol>
<p>For map , if the key is not already present, a new element is created and inserted into the  map for that key. </p>
<h2 id="4、Algorithms_Never_Execute_Container_Operations">4、Algorithms Never Execute Container Operations</h2><p>The generic algorithms do not themselves execute container operations. They operate solely in terms of iterators and iterator operations. The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: When used on “ordinary” iterators, algorithms never change the size of the underlying container. As we’ll see, algorithms may change the values of the elements stored in the container, and they may move elements around within the<br>container. They do not, however, ever add or remove elements directly.<br>There is a special class of iterator, the inserters, that do more than traverse the sequence to which they are bound. When we assign to these iterators, they execute insert operations on the underlying container. When an algorithm operates on one of these<br>iterators, the iterator may have the effect of adding elements to the container. The algorithm itself, however, never does so.</p>
<h2 id="5、类的前向声明">5、类的前向声明</h2><p>An incomplete type can be used only in limited ways. Objects of the type may not be defined. An incomplete type may be used to define only pointers or references to the type or to declare (but not define) functions that use the type as a paremeter or return type.</p>
<h2 id="6、Returning_*this_from_a_const_Member_Function">6、Returning  *this from a  const Member Function</h2><p>In an ordinary non const member function, the type of  this is a  const pointer to the class type. We may change the value to which  this points but cannot change the address that  this holds. In a  const member function, the type of  this is a  const pointer to a const class-type object. We may change neither the object to which  this points nor the address that  this holds.<br>We cannot return a plain reference to the class object from a  const member function. A  const member function may return  *this only as a const reference.<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">const</span> Screen&amp; print() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">"print"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="7、Overloading_Based_on_const">7、Overloading Based on  const</h2><p>We can overload a member function based on whether it is  const for the same reasons that we can overload a function based on whether a pointer parameter points to  const. A  const object will use only the  const member. A non const object could use<br>either member, but the non const version is a better match.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Screen&amp; display(<span class="built_in">std</span>::ostream &amp;os)</span><br><span class="line">        &#123; do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> Screen&amp; display(<span class="built_in">std</span>::ostream &amp;os) <span class="keyword">const</span></span><br><span class="line">        &#123; do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span><br><span class="line">        </span>&#123; os &lt;&lt; contents; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="8、Parameter_Lists_and_Function_Bodies_Are_in_Class_Scope">8、Parameter Lists and Function Bodies Are in Class Scope</h2><p>In a member function defined outside the class, the parameter list and member-function body both appear after the member name. These are defined inside the class scope and so may refer to other class members without qualification.</p>
<h2 id="9、Function_Return_Types_Aren’t_Always_in_Class_Scope">9、Function Return Types Aren’t Always in Class Scope</h2><p>In contrast to the parameter types, the return type appears before the member name. If the function is defined outside the class body, then the name used for the return type is outside the class scope. If the return type uses a type defined by the class, it must use the fully qualified name. </p>
<h2 id="10、类成员声明中的名字查找(Name_Lookup_for_Class_Member_Declarations)">10、类成员声明中的名字查找(Name Lookup for Class Member Declarations)</h2><p>1、The declarations of the class members that appear before the use of the name are considered.<br>2、If the lookup in step 1 is not successful, the declarations that appear in the scope in which the class is defined, and that appear before the class definition itself, are considered.</p>
<h2 id="11、类成员定义中的名字查找(Name_Lookup_in_Class_Member_Definitions)">11、类成员定义中的名字查找(Name Lookup in Class Member Definitions)</h2><p>1、Declarations in the member-function local scopes are considered first.<br>2、If the a declaration for the name is not found in the member function, the declarations for all the class members are considered.<br>3、If a declaration for the name is not found in the class, the declarations that appear in scope before the member function definition are considered.<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="variable">height</span>;</span><br><span class="line">class Screen </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">void</span> dummy_fcn(<span class="built_in">int</span> <span class="variable">height</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cursor</span> = <span class="variable">width</span> * <span class="variable">height</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">cursor</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="variable">height</span>, <span class="variable">width</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>dummy_fun函数内赋值语句中的height指的是dummy_fun函数参数中的height。如果想使用Screen中的成员height，则<code>cursor = width * Screen::height;</code> 如果想使用全局变量height，则<code>cursor = width * ::height;</code></p>
<h2 id="12、typedef_引起的微妙错误">12、typedef 引起的微妙错误</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="literal">typedef</span> string <span class="built_in">Type</span>;</span><br><span class="line"><span class="built_in">Type</span> initVal();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exercise</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    public:</span><br><span class="line">            <span class="literal">typedef</span> <span class="built_in">double</span> <span class="built_in">Type</span>;</span><br><span class="line">            <span class="built_in">Type</span> setVal(<span class="built_in">Type</span>); <span class="comment">// Type为double</span></span><br><span class="line">            <span class="built_in">Type</span> initVal(); <span class="comment">// Type为double</span></span><br><span class="line">    private:</span><br><span class="line">            <span class="built_in">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，在类的外部定义函数时，返回值的类型</span></span><br><span class="line">Exercise::<span class="built_in">Type</span> Exercise::setVal(<span class="built_in">Type</span> parm) </span><br><span class="line">&#123;</span><br><span class="line">    val = parm + initVal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把<code>typedef double Type</code>放到setVal和initVal的后面，就会出现错误。因为按照类成员声明的名字查找规则，setVal中的Type为string。等到编译器解析到<code>typedef double Type</code>语句时，Type有两种意思了，于是发生编译错误。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">error: declaration of ‘<span class="keyword">typedef</span> <span class="keyword">double</span> Exercise::Type’</span><br><span class="line">error: changes meaning of ‘Type’ from ‘<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">std</span>::<span class="built_in">string</span> Type’</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2016/01/24/c-primer笔记1/" data-id="cinvexiyj002ptw3a900zn0aa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-基础/">c++基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-wpa-supplicant-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/23/wpa-supplicant-1/" class="article-date">
  <time datetime="2015-12-23T02:40:58.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/23/wpa-supplicant-1/">wpa_supplicant</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>```</p>
<p>// 启动wpa_supplicant时候的命令行参数保存在struct wpa_params结构的变量中<br>struct wpa_params<br>{<br>    int daemonize;<br>    int wait_for_monitor;<br>    char *pid_file;<br>    int wpa_debug_level;<br>    int wpa_debug_show_keys;<br>    int wpa_debug_timestamp;</p>
<pre><code>/<span class="keyword">*</span> Global ctrl_iface path/parameter <span class="keyword">*</span>/
char <span class="keyword">*</span>ctrl_interface;

/<span class="keyword">*</span> Global ctrl_iface group <span class="keyword">*</span>/
char <span class="keyword">*</span>ctrl_interface_group;


int dbus_ctrl_interface;
const char <span class="keyword">*</span>wpa_debug_file_path;
int wpa_debug_syslog;
int wpa_debug_tracing;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> override_driver - Optional driver parameter override
 <span class="keyword">*</span>
 <span class="keyword">*</span> This parameter can be used to override the driver parameter in
 <span class="keyword">*</span> dynamic interface addition to force a specific driver wrapper to be
 <span class="keyword">*</span> used instead.
 <span class="keyword">*</span>/
char <span class="keyword">*</span>override_driver;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> override_ctrl_interface - Optional ctrl_interface override
 <span class="keyword">*</span>
 <span class="keyword">*</span> This parameter can be used to override the ctrl_interface parameter
 <span class="keyword">*</span> in dynamic interface addition to force a control interface to be
 <span class="keyword">*</span> created.
 <span class="keyword">*</span>/
char <span class="keyword">*</span>override_ctrl_interface;

char <span class="keyword">*</span>entropy_file;
</code></pre><h1 id="ifdef_CONFIG_P2P">ifdef CONFIG_P2P</h1><pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> conf_p2p_dev - Configuration file used to hold the
 <span class="keyword">*</span> P2P Device configuration parameters.
 <span class="keyword">*</span>
 <span class="keyword">*</span> This can also be %NULL. In such a case, if a P2P Device dedicated
 <span class="keyword">*</span> interfaces is created, the main configuration file will be used.
 <span class="keyword">*</span>/
char <span class="keyword">*</span>conf_p2p_dev;
</code></pre><h1 id="endif_/_CONFIG_P2P_/">endif /<em> CONFIG_P2P </em>/</h1><p>};</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/23/wpa-supplicant-1/" data-id="cinvexiqq000ftw3a2qdxcx9q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wpa-supplicant" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/15/wpa-supplicant/" class="article-date">
  <time datetime="2015-12-15T02:32:39.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/wpa-supplicant/">wpa_supplicant</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最简单的运行wpa_supplicant的命令<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">wpa\_supplicant -iwlan0 -C/<span class="keyword">var</span>/<span class="keyword">run</span>/wpa_supplicant -<span class="literal">d</span></span><br></pre></td></tr></table></figure></p>
<p>-iwlan0表示使用wlan0无线网卡<br>-C表示控制接口(ctrl interface)所在的目录。控制接口提供了外部程序与wpa_supplicant进行交互的接口，外部程序通过控制接口来获取wpa_supplicant的相关信息，并且能够控制它的行为。<br>-d表示输出调试信息<br>程序成功执行后，会在/var/run/wpa_supplicant目录下面生成wlan0的套接字文件<br><code>srwxrwx--- 1 root root 0 Dec 15 10:42 wlan0</code></p>
<p>如果系统中有多个无线网卡，可以开启多个wpa_supplicant进程，每个wpa_supplicant进程控制一个无线网卡。当然，也可以只使用一个wpa_supplicant进程来控制多个无线网卡，每个无线网卡通过-N命令行参数来分隔：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">wpa\_supplicant -iwlan0 -C/<span class="keyword">var</span>/<span class="keyword">run</span>/wpa_supplicant -<span class="keyword">N</span></span><br><span class="line">                -iwlan1 -C/<span class="keyword">var</span>/<span class="keyword">run</span>/wpa_supplicant -<span class="literal">d</span></span><br></pre></td></tr></table></figure></p>
<p>此时，会生成两个控制接口<br><figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">ll /var/run/wpa_supplicant</span><br><span class="line"></span><br><span class="line">srwxrwx--- <span class="number">1</span> <span class="literal">root</span> <span class="literal">root</span> <span class="number">0</span> <span class="constant">Dec</span> <span class="number">15</span> <span class="number">10</span>:<span class="number">58</span> wlan<span class="number">0</span></span><br><span class="line">srwxrwx--- <span class="number">1</span> <span class="literal">root</span> <span class="literal">root</span> <span class="number">0</span> <span class="constant">Dec</span> <span class="number">15</span> <span class="number">10</span>:<span class="number">58</span> wlan1</span><br></pre></td></tr></table></figure></p>
<p>wpa_cli程序的核心是一个事件循环eloop，在事件循环eloop中会循环处理信号事件、定时器事件、文件描述符的读写事件。而这些事件信息都存储在struct eloop_data这样的结构变量中，程序循环处理事件也就是循环处理struct eloop_data结构变量。</p>
<h1 id="1-_信号事件">1. 信号事件</h1><p>与信号事件有关的数据结构是struct eloop_signal，具体信息如下：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">struct eloop_signal </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> sig;                      <span class="comment">/* signal number */</span></span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line">    eloop_signal_handler <span class="keyword">handler</span>; <span class="comment">/* signal handler */</span></span><br><span class="line">    <span class="keyword">int</span> signaled;                 <span class="comment">/* 进程是否收到该信号的标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>struct eloop_data中与信号事件有关的数据域如下：<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">struct eloop_data </span><br><span class="line">&#123;</span><br><span class="line">    /<span class="keyword">*</span> other fields <span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">    int signal_count;             /<span class="keyword">*</span> 程序初始化过程中注册的信号处理函数的数量 <span class="keyword">*</span>/</span><br><span class="line">    struct eloop_signal <span class="keyword">*</span>signals; /<span class="keyword">*</span> 程序初始化过程中注册的所有的信号处理函数 <span class="keyword">*</span>/</span><br><span class="line">    int signaled;  /<span class="keyword">*</span> 程序运行过程中是否有未处理的信号的标志 <span class="keyword">*</span>/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wpa_cli的信号处理过程是这样的：无论进程收到什么信号，都会调用eloop_handle_signal函数来处理信号。在eloop_handle_signal内，只会简单的在eloop_data中记录某个信号发生了,除此之外，没有做任何其他事情。而真正的信号处理过程是推迟到事件循环eloop中去处理的。wpa_cli在初始化的时候仅仅注册了SIGINT和SIGTERM这两个信号的处理函数。</p>
<h1 id="2-_定时器事件">2. 定时器事件</h1><p>与定时器事件有关的数据结构是struct eloop_timeout，具体信息如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">eloop_t</span>imeout </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> dl_list <span class="built_in">list</span>;     <span class="comment">// 定时器事件的链表</span></span><br><span class="line">    <span class="keyword">struct</span> os_reltime time;  <span class="comment">// 事件的发生时间</span></span><br><span class="line">    <span class="keyword">void</span> *eloop_data;       </span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line">    <span class="keyword">eloop_t</span>imeout_handler handler; <span class="comment">// 定时器事件的处理函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>struct eloop_data中与信号事件有关的数据域如下：<br><figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eloop_data</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/* other fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dl_list</span> timeout; // 定时器事件的链表头</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在交互(Interactive)模式下，wpa_cli在进入事件循环函数eloop_run之前，注册了try_connection定时器事件。try_connection定时器事件在eloop_run中被执行，它会调用wpa_cli_open_connection去连接wpa_supplicant程序创建的控制接口，如果连接失败，则把自己再注册为一个1秒后触发的定时器事件；如果连接成功，则会生成两个与wpa_supplicant的连接：struct wpa_ctrl *ctrl_conn和struct wpa_ctrl *mon_conn。与wpa_supplicant进行的命令请求和响应，是通过ctrl_conn这个连接来进行的，但是与它有关的读写事件并不会注册在eloop_data中；而与mon_conn有关的读事件是注册到eloop_data中的，用来读取wpa_supplicant发送的广播事件。连接成功之后，wpa_cli会注册一个每隔一段时间就与wpa_supplicant通讯的心跳事件，还会把标准输入注册到eloop_data中，以便能够读取用户输入的命令。<br>与wpa_supplicant通讯的心跳事件的处理函数wpa_cli_ping到底做了哪些事情呢？其实，它只是调用了wpa_ctrl_request。那wpa_ctrl_request又是何许人也呢？它是wpa_cli用来向wpa_supplicant发送命令请求并接收响应数据的通用接口。在wpa_ctrl_request中，程序利用struct wpa_ctrl *ctrl_conn这个连接向wpa_supplicant发送命令请求，然后读取wpa_supplicant的数据响应并打印到标准输出，这与前文中的“与ctrl_conn有关的读写事件并不会注册在eloop_data中”是一致的。</p>
<p>至此，我们可以知道，eloop_data中注册了一个定时器事件(每隔一段时间就与wpa_supplicant通讯的心跳事件)和两个文件描述符读事件(一个是标准输入，用于获取用户的输入；另一个是mon_conn连接的读事件，用于获取wpa_supplicant主动发送的广播事件)。</p>
<h1 id="3-_文件描述符的读写事件">3. 文件描述符的读写事件</h1><p>与文件描述符的读写事件有关的数据结构是struct eloop_sock和struct eloop_sock_table，具体信息如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> eloop_sock </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;                   <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">void</span> *eloop_data;</span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line">    eloop_sock_handler handler; <span class="comment">// 处理函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">eloop_sock_t</span>able </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count;                  <span class="comment">// 该类型的文件描述符的数量</span></span><br><span class="line">    <span class="keyword">struct</span> eloop_sock *table;   <span class="comment">// 该类型的文件描述符集合</span></span><br><span class="line">    <span class="keyword">eloop_event_t</span>ype type;      <span class="comment">// 文件描述符类型：READ,WRITE,EXCEPTION</span></span><br><span class="line">    <span class="keyword">int</span> changed;                <span class="comment">// 该类型的文件描述符集合是否发生过改变</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>struct eloop_data中与信号事件有关的数据域如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> eloop_data </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* other fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">eloop_sock_t</span>able readers;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">eloop_sock_t</span>able writers;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">eloop_sock_t</span>able exceptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过前面的分析可以知道，eloop_data中只有在readers中注册了两个文件描述符。其中一个是mon_conn连接的读事件，当wpa_supplicant主动发送广播信息时，会调用wpa_cli_mon_receive函数将广播信息打印到标准输出。另一个是标准输入的读事件，当用户输出一个命令的时候，会在wpa_cli中所支持的命令集合wpa_cli_commands中进行匹配，<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> wpa_cli_cmd </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cmd;</span><br><span class="line">    <span class="keyword">int</span> (*handler)(<span class="keyword">struct</span> wpa_ctrl *ctrl, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]);</span><br><span class="line">    <span class="keyword">char</span> ** (*completion)(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> pos);</span><br><span class="line">    <span class="keyword">enum</span> wpa_cli_cmd_flags flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *usage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> wpa_cli_cmd wpa_cli_commands[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">"status"</span>, wpa_cli_cmd_status, <span class="literal">NULL</span>,</span><br><span class="line">      cli_cmd_flag_none,</span><br><span class="line">      <span class="string">"[verbose] = get current WPA/EAPOL/EAP status"</span> &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other commands</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果匹配到某一条命令，则调用该命令的的处理函数handler，该handler与定时器心跳事件的处理函数wpa_cli_ping的处理过程是一样的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/15/wpa-supplicant/" data-id="cinvexiqn000etw3ai2hxr5mp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-svn分支和合并" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/13/svn分支和合并/" class="article-date">
  <time datetime="2015-12-13T04:11:59.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/svn分支和合并/">svn分支和合并</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Creating_a_Branch">Creating a Branch</h1><p>Creating a branch is very simple—you make a copy of the project in the repository using the svn copy command.<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ svn <span class="keyword">copy</span> http:<span class="comment">//svn.example.com/repos/calc/trunk \</span></span><br><span class="line">           http:<span class="comment">//svn.example.com/repos/calc/branches/my-calc-branch \</span></span><br><span class="line">        -<span class="keyword">m</span> <span class="string">"Creating a private branch of /calc/trunk."</span></span><br><span class="line">Committed revision 341.</span><br></pre></td></tr></table></figure></p>
<h1 id="Working_with_Your_Branch">Working with Your Branch</h1><p>Now that you’ve created a branch of the project, you can check out a new working copy to start using it:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn checkout http:<span class="comment">//svn.example.com/repos/calc/branches/my-calc-branch</span></span><br><span class="line">A my-calc-branch/Makefile</span><br><span class="line">A my-calc-branch/integer<span class="class">.c</span></span><br><span class="line">A my-calc-branch/<span class="tag">button</span><span class="class">.c</span></span><br><span class="line">Checked out revision <span class="number">341</span>.</span><br></pre></td></tr></table></figure></p>
<p>There’s nothing special about this working copy; it simply mirrors a different directory in the repository. Subversion has no internal concept of a branch—it knows only how to make copies. When you copy a directory, the resultant directory is only a “branch” because you attach that meaning to it. You may think of the directory differently, or treat it differently, but to Subversion it’s just an ordinary directory that happens to carry some extra historical information. Most teams follow a convention of putting all branches into a /branches directory, but you’re free to invent any policy you wish.</p>
<h1 id="Changeset">Changeset</h1><p>A changeset is just a collection of changes with a unique name. The changes might include textual edits to file contents, modifications to tree structure, or tweaks to metadata. In more common speak, a changeset is just a patch with a name you can refer<br>to.<br>In Subversion, a global revision number N names a tree in the repository.  It’s also the name of an implicit changeset: if you<br>compare tree N with tree N-1, you can derive the exact patch that was committed.  For this reason, it’s easy to think of revision N as not just a tree, but a changeset as well. And Subversion’s svn merge command is able to use revision numbers. You can merge specific changesets from one branch to another by naming them in the merge arguments: passing -c 9238 to svn merge would merge changeset r9238 into your working copy.</p>
<h1 id="Merge">Merge</h1><p>A better name for the merge command might have been svn diff-and-apply, because that’s all that happens: two repository trees are compared, and the differences are applied to a working copy. If you’re using svn merge to do basic copying of changes between branches, it will generally do the right thing automatically. For example, a command such as the following:<br><code>$ svn merge http://svn.example.com/repos/calc/some-branch</code><br>will attempt to duplicate any changes made on some-branch into your current working directory. The command is smart enough to only duplicate changes that your working copy doesn’t yet have. If you repeat this command once a week, it will only duplicate the<br>“newest” branch changes that happened since you last merged.If you choose to use the svn merge command in all its full glory by giving it specific revision ranges to duplicate, the command takes three main arguments:</p>
<ol>
<li>An initial repository tree (often called the left side of the comparison)</li>
<li>A final repository tree (often called the right side of the comparison)</li>
<li>A working copy to accept the differences as local changes (often called the target of the merge)<br>Once these three arguments are specified, the two trees are compared, and the differences are applied to the target working copy as local modifications. When the command is done, the results are no different than if you had hand-edited the files or run various svn add or svn delete commands yourself. If you like the results, you can commit them. If you don’t like the results, you can simply svn revert all of the changes.<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ svn merge <span class="string">http:</span><span class="comment">//svn.example.com/repos/branch1@150 \</span></span><br><span class="line"><span class="string">http:</span><span class="comment">//svn.example.com/repos/branch2@212 \</span></span><br><span class="line">my-working-copy</span><br><span class="line">$ svn merge -r <span class="number">100</span>:<span class="number">200</span> <span class="string">http:</span><span class="comment">//svn.example.com/repos/trunk my-working-copy</span></span><br><span class="line">$ svn merge -r <span class="number">100</span>:<span class="number">200</span> <span class="string">http:</span><span class="comment">//svn.example.com/repos/trunk</span></span><br><span class="line">$ svn merge -c <span class="number">355</span> <span class="string">http:</span><span class="comment">//svn.example.com/repos/calc/trunk</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>The first syntax lays out all three arguments explicitly, naming each tree in the form URL@REV and naming the working copy target. The second syntax can be used as a shorthand for situations when you’re comparing two different revisions of the same URL.<br>The last syntax shows how the working copy argument is optional; if omitted, it defaults to the current directory. The last syntax shows only replicate just a single change.</p>
<h1 id="Keeping_a_Branch_in_Sync">Keeping a Branch in Sync</h1><p>Let’s suppose that a week has passed since you started working on your private branch. Your new feature isn’t finished yet, but at the same time you know that other people on your team have continued to make important changes in the project’s /trunk. In fact, this is a best practice: frequently keeping your branch in sync with the main development line helps prevent “surprise” conflicts when it comes time for you to fold your changes back into the trunk.<br>Subversion is aware of the history of your branch and knows when it divided away from the trunk. To replicate the latest, greatest trunk changes to your branch, first make sure your working copy of the branch is “clean”—that it has no local modifications reported by svn status. Then simply run:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn merge http:<span class="comment">//svn.example.com/repos/calc/trunk</span></span><br><span class="line">--- Merging r345 through r356 into <span class="string">'.'</span>:</span><br><span class="line">U <span class="tag">button</span><span class="class">.c</span></span><br><span class="line">U integer.c</span><br></pre></td></tr></table></figure></p>
<p>This basic syntax—svn merge URL—tells Subversion to merge all recent changes from the URL to the current working directory. After running the prior example, your branch working copy now contains new local modifications, and these edits are duplications of all of the changes that have happened on the trunk since you first created your branch:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn status</span><br><span class="line">M .</span><br><span class="line">M <span class="tag">button</span><span class="class">.c</span></span><br><span class="line">M integer.c</span><br></pre></td></tr></table></figure></p>
<p>At this point, the wise thing to do is look at the changes carefully with svn diff, and then build and test your branch. Notice that the current working directory (“.”) has also been modified; the svn diff will show that its svn:mergeinfo property has been either created or modified. This is important merge-related metadata that you should not touch, since it will be needed by future svn merge commands.<br>After performing the merge, you might also need to resolve some conflicts (just as you do with svn update) or possibly make some small edits to get things working properly. (Remember, just because there are no syntactic conflicts doesn’t mean there aren’t any semantic conflicts!) If you encounter serious problems, you can always abort the local changes by running svn revert . -R (which will undo all local modifications) and start a long “what’s going on?” discussion with your collaborators. If things look good, however, you can submit these changes into the repository:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn commit -m <span class="string">"Merged latest trunk changes to my-calc-branch."</span></span><br><span class="line">Sending .</span><br><span class="line">Sending <span class="tag">button</span><span class="class">.c</span></span><br><span class="line">Sending integer<span class="class">.c</span></span><br><span class="line">Transmitting file data ..</span><br><span class="line">Committed revision <span class="number">357</span>.</span><br></pre></td></tr></table></figure></p>
<p>At this point, your private branch is now “in sync” with the trunk, so you can rest easier knowing that as you continue to work in isolation, you’re not drifting too far away from what everyone else is doing.<br>Suppose that another week has passed. You’ve committed more changes to your branch, and your comrades have continued to improve the trunk as well. Once again, you’d like to replicate the latest trunk changes to your branch and bring yourself in sync. Just run the same merge command again!<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>svn merge <span class="symbol">http:</span>/<span class="regexp">/svn.example.com/repos</span><span class="regexp">/calc/trunk</span></span><br><span class="line">--- <span class="constant">Merging </span>r357 through r38<span class="number">0</span> into <span class="string">'.'</span><span class="symbol">:</span></span><br><span class="line"><span class="constant">U </span>integer.c</span><br><span class="line"><span class="constant">U Makefile</span></span><br><span class="line"><span class="constant">A README</span></span><br></pre></td></tr></table></figure></p>
<p>Subversion knows which trunk changes you’ve already replicated to your branch, so it carefully replicates only those changes you don’t yet have. What happens when you finally finish your work, though?  The process is simple. First, bring your branch in sync with the trunk again, just as you’ve been doing all along:<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>svn merge <span class="symbol">http:</span>/<span class="regexp">/svn.example.com/repos</span><span class="regexp">/calc/trunk</span></span><br><span class="line">--- <span class="constant">Merging </span>r381 through r385 into <span class="string">'.'</span><span class="symbol">:</span></span><br><span class="line"><span class="constant">U </span>button.c</span><br><span class="line"><span class="constant">U README</span></span><br><span class="line"><span class="variable">$ </span><span class="comment"># build, test, ...</span></span><br><span class="line"><span class="variable">$ </span>svn commit -m <span class="string">"Final merge of trunk changes to my-calc-branch."</span></span><br><span class="line"><span class="constant">Sending </span>.</span><br><span class="line"><span class="constant">Sending </span>button.c</span><br><span class="line"><span class="constant">Sending README</span></span><br><span class="line"><span class="constant">Transmitting </span>file data ..</span><br><span class="line"><span class="constant">Committed </span>revision <span class="number">390</span>.</span><br></pre></td></tr></table></figure></p>
<p>Now, you use svn merge to replicate your branch changes back into the trunk. You’ll need an up-to-date working copy of /trunk. However you get a trunk working copy, remember that it’s a best practice to do your merge into a working copy that has no local edits and has been recently updated (i.e., is not a mixture of local revisions).<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ svn <span class="operator"><span class="keyword">update</span> # (make sure the working copy <span class="keyword">is</span> up <span class="keyword">to</span> <span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">At</span> revision <span class="number">390.</span></span><br><span class="line">$ svn <span class="keyword">merge</span> <span class="comment">--reintegrate http://svn.example.com/repos/calc/branches/my-calc-branch</span></span><br><span class="line"><span class="comment">--- Merging differences between repository URLs into '.':</span></span><br><span class="line">U button.c</span><br><span class="line">U <span class="built_in">integer</span>.c</span><br><span class="line">U Makefile</span><br><span class="line">U .</span><br><span class="line">$ # build, test, verify, ...</span><br><span class="line">$ svn <span class="keyword">commit</span> -m <span class="string">"Merge my-calc-branch back into trunk!"</span></span><br><span class="line">Sending .</span><br><span class="line">Sending button.c</span><br><span class="line">Sending <span class="built_in">integer</span>.c</span><br><span class="line">Sending Makefile</span><br><span class="line">Transmitting file <span class="keyword">data</span> ..</span><br><span class="line">Committed revision <span class="number">391.</span></span></span><br></pre></td></tr></table></figure></p>
<p>Notice our use of the —reintegrate option this time around. The option is critical for reintegrating changes from a branch back into its original line of development—don’t forget it! It’s needed because this sort of “merge back” is a different sort of work than what you’ve been doing up until now. Now that your private branch is merged to trunk, you may wish to remove it from the repository:<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">$ svn <span class="keyword">delete</span> http:<span class="comment">//svn.example.com/repos/calc/branches/my-calc-branch \</span></span><br><span class="line">-m <span class="string">"Remove my-calc-branch."</span></span><br><span class="line">Committed revision <span class="number">392.</span></span><br></pre></td></tr></table></figure></p>
<p>In Subversion 1.5, once a —reintegrate merge is done from branch to trunk, the branch is no longer usable for further work. It’s not able to correctly absorb new trunk changes, nor can it be properly reintegrated to trunk again. For this reason, if you want to<br>keep working on your feature branch, we recommend destroying it and then recreating it from the trunk:</p>
<h1 id="Mergeinfo">Mergeinfo</h1><p>The basic mechanism Subversion uses to track changesets—that is, which changes have been merged to which branches—is by recording data in properties. Specifically, merge data is tracked in the svn:mergeinfo property attached to files and directories.<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cd my-calc-branch</span><br><span class="line"><span class="variable">$ </span>svn propget <span class="symbol">svn:</span>mergeinfo .</span><br><span class="line">/<span class="symbol">trunk:</span><span class="number">341</span>-<span class="number">390</span></span><br></pre></td></tr></table></figure></p>
<p>There’s also a subcommand, svn mergeinfo, which can be helpful in seeing not only which changesets a directory has absorbed, but also which changesets it’s still eligible to receive. This gives a sort of preview of the next set of changes that svn merge will replicate to your branch.<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cd my-calc-branch</span><br><span class="line"><span class="comment"># Which changes have already been merged from trunk to branch?</span></span><br><span class="line"><span class="variable">$ </span>svn mergeinfo <span class="symbol">http:</span>/<span class="regexp">/svn.example.com/repos</span><span class="regexp">/calc/trunk</span></span><br><span class="line">r341</span><br><span class="line">r342</span><br><span class="line">…</span><br><span class="line">r389</span><br><span class="line">r39<span class="number">0</span></span><br><span class="line"><span class="comment"># Which changes are still eligible to merge from trunk to branch?</span></span><br><span class="line"><span class="variable">$ </span>svn mergeinfo <span class="symbol">http:</span>/<span class="regexp">/svn.example.com/repos</span><span class="regexp">/calc/trunk</span> --show-revs eligible</span><br><span class="line">r391</span><br><span class="line">r392</span><br><span class="line">r393</span><br><span class="line">r394</span><br><span class="line">r395</span><br></pre></td></tr></table></figure></p>
<p>The svn mergeinfo command requires a “source” URL (where the changes would be coming from), and takes an optional “target” URL (where the changes would be merged to). If no target URL is given, it assumes that the current working directory is the target. In the prior example, because we’re querying our branch working copy, the command assumes we’re interested in receiving changes to /branches/mybranch from the specified trunk URL. Another way to get a more precise preview of a merge operation is to use the<br>—dry-run option:<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>svn merge <span class="symbol">http:</span>/<span class="regexp">/svn.example.com/repos</span><span class="regexp">/calc/trunk</span> --dry-run</span><br><span class="line"><span class="constant">U </span>integer.c</span><br><span class="line"><span class="variable">$ </span>svn status</span><br><span class="line"><span class="comment"># nothing printed, working copy is still unchanged.</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Undoing_Changes">Undoing Changes</h1><p>An extremely common use for svn merge is to roll back a change that has already been committed. Suppose you’re working away happily on a working copy of /calc/trunk, and you discover that the change made way back in revision 303, which changed integer.c, is completely wrong. All you need to do is to specify a reverse difference. (You can do this by specifying —revision 303:302, or by an equivalent —change -303.)</p>
<h1 id="Traversing_Branches">Traversing Branches</h1><p>The svn switch command transforms an existing working copy to reflect a different branch. “Switching” a working copy that has no local modifications to a different branch results in the working copy looking just as it would if you’d done a fresh checkout of the directory.<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ svn info | grep <span class="built_in">URL</span></span><br><span class="line"><span class="built_in">URL</span>: <span class="keyword">http</span>://svn.example.com/repos/calc/trunk</span><br><span class="line">$ svn <span class="keyword">switch</span> <span class="keyword">http</span>://svn.example.com/repos/calc/branches/my-calc-branch</span><br><span class="line">U <span class="keyword">integer</span>.c</span><br><span class="line">U button.c</span><br><span class="line">U Makefile</span><br><span class="line">Updated <span class="built_in">to</span> revision <span class="number">341.</span></span><br><span class="line">$ svn info | grep <span class="built_in">URL</span></span><br><span class="line"><span class="built_in">URL</span>: <span class="keyword">http</span>://svn.example.com/repos/calc/branches/my-calc-branch</span><br></pre></td></tr></table></figure></p>
<h1 id="Tags">Tags</h1><p>A tag is just a “snapshot” of a project in time. Once again, svn copy comes to the rescue. If you want to create a snapshot of<br>/calc/trunk exactly as it looks in the HEAD revision, make a copy of it:<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ svn <span class="keyword">copy</span> http:<span class="comment">//svn.example.com/repos/calc/trunk \</span></span><br><span class="line">           http:<span class="comment">//svn.example.com/repos/calc/tags/release-1.0 \</span></span><br><span class="line">        -<span class="keyword">m</span> <span class="string">"Tagging the 1.0 release of the 'calc' project."</span></span><br><span class="line">Committed revision 902.</span><br></pre></td></tr></table></figure></p>
<p>This example assumes that a /calc/tags directory already exists. (If it doesn’t, you can create it using svn mkdir.)  After the copy completes, the new release-1.0 directory is forever a snapshot of how the /trunk directory looked in the HEAD revision at the time you made the copy.<br>In Subversion, there’s no difference between a tag and a branch. Both are just ordinary directories that are created by copying. Just as with branches, the only reason a copied directory is a “tag” is because humans have decided to treat it that way: as long as nobody ever commits to the directory, it forever remains a snapshot. If people start committing to it, it becomes a branch.</p>
<h1 id="Common_Branching_Patterns">Common Branching Patterns</h1><h2 id="1-_Release_Branches">1. Release Branches</h2><p>Most software has a typical life cycle: code, test, release, repeat. There are two problems with this process. First, developers need to keep writing new features while quality assurance teams take time to test supposedly stable versions of the software. New work cannot halt while the software is tested. Second, the team almost always needs to support older, released versions of software; if a bug is discovered in the latest code, it most likely exists in released versions as well, and customers will want to get that bug fix without having to wait for a major new release. The typical procedure looks like this:</p>
<ol>
<li>Developers commit all new work to the trunk. Day-to-day changes are committed to /trunk: new features, bug fixes, and so on.</li>
<li>The trunk is copied to a “release” branch. When the team thinks the software is ready for release (say, a 1.0 release), /trunk might be copied to /branches/1.0.</li>
<li>Teams continue to work in parallel. One team begins rigorous testing of the release branch, while another team continues new work (say, for version 2.0) on /trunk. If bugs are discovered in either location, fixes are ported back and forth as necessary. At<br>some point, however, even that process stops. The branch is “frozen” for final testing right before a release.</li>
<li>The branch is tagged and released. When testing is complete, /branches/1.0 is copied to /tags/1.0.0 as a reference snapshot. The tag is packaged and released to customers.</li>
<li>The branch is maintained over time. While work continues on /trunk for version 2.0, bug fixes continue to be ported from /trunk to /branches/1.0. When enough bug fixes have accumulated, management may decide to do a 1.0.1 release: /branches/1.0 is copied to /tags/1.0.1, and the tag is packaged and released.<br>This entire process repeats as the software matures: when the 2.0 work is complete, a new 2.0 release branch is created, tested, tagged, and eventually released. After some years, the repository ends up with a number of release branches in “maintenance” mode, and a number of tags representing final shipped versions.</li>
</ol>
<h2 id="2-_Feature_Branches">2. Feature Branches</h2><p>It’s a temporary branch created to work on a complex change without interfering with the stability of /trunk. Unlike release branches (which may need to be supported forever), feature branches are born, used for a while, merged back to the trunk, and then ultimately deleted.<br>Here’s a great risk to working on a branch for weeks or months; trunk changes may continue to pour in, to the point where the two lines of development differ so greatly that it may become a nightmare trying to merge the branch back to the trunk. This situation is best avoided by regularly merging trunk changes to the branch. Make up a policy: once a week, merge the last week’s worth of trunk changes to the branch.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/13/svn分支和合并/" data-id="cinvexirh000ntw3aellcrebj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svn/">svn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-locale" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/locale/" class="article-date">
  <time datetime="2015-12-09T11:58:15.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/locale/">locale</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>运行locale指令得到当前系统编码设置的详细资料(UTF-8才是编码世界最通用的语言)。<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="setting">LANG=<span class="value">en_US.UTF-<span class="number">8</span></span></span></span><br><span class="line"><span class="setting">LC_CTYPE=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_NUMERIC=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_TIME=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_COLLATE=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_MONETARY=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_MESSAGES=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_PAPER=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_NAME=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_ADDRESS=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_TELEPHONE=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_MEASUREMENT=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_IDENTIFICATION=<span class="value"><span class="string">"en_US.UTF-8"</span></span></span></span><br><span class="line"><span class="setting">LC_ALL=<span class="value"></span></span></span><br></pre></td></tr></table></figure></p>
<p>locale 的命名规则为&lt;语言&gt;_&lt;地区&gt;.&lt;字符集编码&gt; ，如zh_CN.UTF-8，zh代表中文，CN代表大陆地区，UTF-8表示字符集。在locale 环境中，有一组变量，代表国际化环境中的不同设置：<br>1、 语言符号及其分类(LC_CTYPE)<br>2、 数字(LC_NUMERIC)<br>3、 比较和排序习惯(LC_COLLATE)<br>4、 时间显示格式(LC_TIME)<br>5、 货币单位(LC_MONETARY)<br>6、 信息主要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)<br>7、 姓名书写方式(LC_NAME)<br>8、 地址书写方式(LC_ADDRESS)<br>9、 电话号码书写方式(LC_TELEPHONE)<br>10、度量衡表达方式(LC_MEASUREMENT)<br>11、默认纸张尺寸大小(LC_PAPER)<br>12、对locale自身包含信息的概述(LC_IDENTIFICATION)。</p>
<p>此外，还有两个特殊的设置</p>
<ul>
<li>LANG<br>LC_* 的默认值，是最低级别的设置，如果LC_* 没有设置，则使用该值。 </li>
<li>LC_ALL<br>如果该值设置了，则该值会覆盖所有LC_* 的设置值。注意，LANG 的值不受影响。 </li>
</ul>
<p>它们之间有一个优先级的关系：LC_ALL &gt; LC_* &gt; LANG</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/09/locale/" data-id="cinvexirm000rtw3agh5s6j2l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux点滴/">linux点滴</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-svn高级话题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/svn高级话题/" class="article-date">
  <time datetime="2015-12-09T07:53:10.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/svn高级话题/">svn高级话题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Revision_Specifiers">1. Revision Specifiers</h1><p>Revision numbers in Subversion are pretty straightforward—integers that keep getting larger as you commit more changes to<br>your versioned data. Besides the integer revision numbers, svn allows as input some additional forms of revision specifiers: revision keywords and revision dates.</p>
<ul>
<li>HEAD<br>The latest (or “youngest”) revision in the repository.</li>
<li>BASE<br>The revision number of an item in a working copy. If the item has been locally modified, this refers to the way the item appears without those local modifications.</li>
<li>COMMITTED<br>The most recent revision prior to, or equal to, BASE, in which an item changed.</li>
<li>PREV<br>The revision immediately before the last revision in which an item changed.<br>Here are some examples of revision keywords in action:<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>svn diff -r <span class="constant">PREV</span><span class="symbol">:COMMITTED</span> foo.c</span><br><span class="line"><span class="comment"># shows the last change committed to foo.c</span></span><br><span class="line"><span class="variable">$ </span>svn log -r <span class="constant">HEAD</span></span><br><span class="line"><span class="comment"># shows log message for the latest repository commit</span></span><br><span class="line"><span class="variable">$ </span>svn diff -r <span class="constant">HEAD</span></span><br><span class="line"><span class="comment"># compares your working copy (with all of its local changes) to the</span></span><br><span class="line"><span class="comment"># latest version of that tree in the repository</span></span><br><span class="line"><span class="variable">$ </span>svn diff -r <span class="constant">BASE</span><span class="symbol">:HEAD</span> foo.c</span><br><span class="line"><span class="comment"># compares the unmodified version of foo.c with the latest version of</span></span><br><span class="line"><span class="comment"># foo.c in the repository</span></span><br><span class="line"><span class="variable">$ </span>svn log -r <span class="constant">BASE</span><span class="symbol">:HEAD</span></span><br><span class="line"><span class="comment"># shows all commit logs for the current versioned directory since you</span></span><br><span class="line"><span class="comment"># last updated</span></span><br><span class="line"><span class="variable">$ </span>svn update -r <span class="constant">PREV</span> foo.c</span><br><span class="line"><span class="comment"># rewinds the last change on foo.c, decreasing foo.c's working revision</span></span><br><span class="line"><span class="variable">$ </span>svn diff -r <span class="constant">BASE</span><span class="symbol">:</span><span class="number">14</span> foo.c</span><br><span class="line"><span class="comment"># compares the unmodified version of foo.c with the way foo.c looked</span></span><br><span class="line"><span class="comment"># in revision 14</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2-_Ignoring_Unversioned_Items">2. Ignoring Unversioned Items</h1><p>In any given working copy, there is a good chance that alongside all those versioned files and directories are other files and directories that are neither versioned nor intended to be.</p>
<p>So Subversion provides two ways for telling it which files you would prefer that it simply disregard. One of the ways involves the use of Subversion’s runtime configuration system(see the section called “Runtime Configuration Area”), and therefore applies to all the Subversion operations that make use of that runtime configuration—generally those performed on a particular computer or by a particular user of a computer. The other way makes use of Subversion’s directory property support and is more tightly bound to the versioned tree itself, and therefore affects everyone who has a working copy of that tree. Both of the mechanisms use file patterns (strings of literal and special wildcard characters used to match against filenames) to decide which files to ignore.</p>
<p>The Subversion runtime configuration system provides an option, global-ignores, whose value is a whitespace-delimited collection of file patterns.When found on a versioned directory, the svn:ignore property is expected to contain a list of newline-delimited file patterns that Subversion should use to determine ignorable objects in that same directory. These patterns do not override those found in the global-ignores runtime configuration option, but are instead appended to that list. And it’s worth noting again that, unlike the global-ignores option, the patterns found in the svn:ignore property apply only to the directory on which that property is set, and not to any of its subdirectories. </p>
<p>Say you have the following output from svn status:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ svn status calc</span><br><span class="line">M calc/<span class="keyword">button.c</span><br><span class="line"></span>? calc/calculator</span><br><span class="line">? calc/<span class="preprocessor">data</span>.c</span><br><span class="line">? calc/debug_log</span><br><span class="line">? calc/debug_log.<span class="number">1</span></span><br><span class="line">? calc/debug_log.<span class="number">2</span>.gz</span><br><span class="line">? calc/debug_log.<span class="number">3</span>.gz</span><br></pre></td></tr></table></figure></p>
<p>In this example, you have made some property modifications to button.c, but in your working copy, you also have some unversioned files. And you know that you aren’t interested in seeing those log files every time you run svn status. So you use <code>svn propedit svn:ignore calc</code> to add some ignore patterns to the calc directory. For example, you might add this as the new value of the svn:ignore property:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calculator</span><br><span class="line">debug_<span class="built_in">log</span>*</span><br></pre></td></tr></table></figure></p>
<p>After you’ve added this property, you will now have a local property modification on the calc directory. But notice what else is different about your svn status output:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ svn status</span><br><span class="line">M calc</span><br><span class="line">M calc/<span class="keyword">button.c</span><br><span class="line"></span>? calc/<span class="preprocessor">data</span>.c</span><br></pre></td></tr></table></figure></p>
<h1 id="3-_Sparse_Directories">3. Sparse Directories</h1><p>By default, most Subversion operations on directories act in a recursive manner. Subversion introduces a feature called sparse dir-<br>ectories (or shallow checkouts) that allows you to easily check out a working copy—or a portion of a working copy—more shallowly than full recursion, with the freedom to bring in previously ignored files and subdirectories at a later time. Here are the depth values that you can request for a given Subversion operation:</p>
<ul>
<li>—depth empty<br>Include only the immediate target of the operation, not any of its file or directory children.</li>
<li>—depth files<br>Include the immediate target of the operation and any of its immediate file children.</li>
<li>—depth immediates<br>Include the immediate target of the operation and any of its immediate file or directory children. The directory children will themselves be empty.</li>
<li>—depth infinity<br>Include the immediate target, its file and directory children, its children’s children, and so on to full recursion.</li>
</ul>
<h1 id="4-_Properties">4. Properties</h1><p>In addition to versioning your directories and files, Subversion provides interfaces for adding, modifying, and removing versioned metadata on each of your versioned directories and files. We refer to this metadata as properties, and they can be thought of as two-column tables that map property names to arbitrary values attached to each item in your working copy. And the best part about these properties is that they, too, are versioned, just like the textual contents of your files. Subversion has reserved the set of properties whose names begin with <code>svn:</code> as its own. You should avoid creating custom properties for your own needs whose names begin with this prefix.</p>
<p>Just as files and directories may have arbitrary property names and values attached to them, each revision as a whole may have<br>arbitrary properties attached to it.The main difference is that revision properties are not versioned.</p>
<ul>
<li>svn propset</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn propset copyright <span class="string">'(c) 2006 Red-Bean Software'</span> calc/<span class="tag">button</span><span class="class">.c</span></span><br><span class="line">property <span class="string">'copyright'</span> set on <span class="string">'calc/button.c'</span></span><br><span class="line"></span><br><span class="line">$ svn propset license -F /path/to/LICENSE calc/<span class="tag">button</span><span class="class">.c</span></span><br><span class="line">property <span class="string">'license'</span> set on <span class="string">'calc/button.c'</span></span><br></pre></td></tr></table></figure>
<p>In addition to the propset command, the svn program supplies the propedit command. This command uses the configured editor program to add or modify properties.<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ svn propset copyright '(c) <span class="number">2006</span> Red-Bean Software' calc/*</span><br><span class="line"><span class="keyword">property</span> 'copyright' <span class="keyword">set</span> <span class="function_start"><span class="keyword">on</span></span> 'calc/Makefile'</span><br><span class="line"><span class="keyword">property</span> 'copyright' <span class="keyword">set</span> <span class="function_start"><span class="keyword">on</span></span> 'calc/button.c'</span><br><span class="line"><span class="keyword">property</span> 'copyright' <span class="keyword">set</span> <span class="function_start"><span class="keyword">on</span></span> 'calc/<span class="type">integer</span>.c'</span><br></pre></td></tr></table></figure></p>
<p>The svn proplist command will list the names of properties that exist on a path. Once you know the names of the prop-<br>erties on the node, you can request their values individually using svn propget.<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn proplist calc/<span class="tag">button</span><span class="class">.c</span></span><br><span class="line">Properties on <span class="string">'calc/button.c'</span>:</span><br><span class="line">copyright</span><br><span class="line">license</span><br><span class="line">$ svn propget copyright calc/<span class="tag">button</span><span class="class">.c</span></span><br><span class="line">(c) <span class="number">2006</span> Red-Bean Software</span><br></pre></td></tr></table></figure></p>
<p>The last property-related subcommand is propdel.<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ svn propdel license calc/<span class="tag">button</span><span class="class">.c</span></span><br><span class="line">property <span class="string">'license'</span> deleted from <span class="string">'calc/button.c'</span>.</span><br></pre></td></tr></table></figure></p>
<p>Remember those unversioned revision properties? You can modify those, too, using the same svn subcommands that we just described. Simply add the —revprop command-line parameter and specify the revision whose property you wish to modify. Since revisions are global, you don’t need to specify a target path to these property-related commands so long as you are positioned in a working copy of the repository whose revision property you wish to modify. Otherwise, you can simply provide the URL of any path in the repository of interest (including the repository’s root URL). For example, you might want to replace the commit log message of an existing revision. If your current working directory is part of a working copy of your repository, you can simply run the svn propset command with no target path:<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ svn propset svn:<span class="built_in">log</span> <span class="string">'* button.c: Fix a compiler warning.'</span> -r11 <span class="comment">--revprop</span></span><br><span class="line">property <span class="string">'svn:log'</span> <span class="built_in">set</span> <span class="command"><span class="keyword">on</span> <span class="title">repository</span> <span class="title">revision</span> <span class="string">'11'</span></span></span><br></pre></td></tr></table></figure></p>
<p>But even if you haven’t checked out a working copy from that repository, you can still effect the property change by providing the repository’s root URL:<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ svn propset svn:<span class="built_in">log</span> <span class="string">'* button.c: Fix a compiler warning.'</span> -r11 <span class="comment">--revprop \</span></span><br><span class="line"><span class="keyword">http</span>://svn.example.com/repos/project</span><br><span class="line">property <span class="string">'svn:log'</span> <span class="built_in">set</span> <span class="command"><span class="keyword">on</span> <span class="title">repository</span> <span class="title">revision</span> <span class="string">'11'</span></span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/09/svn高级话题/" data-id="cinvexiqs000gtw3awradhcb0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svn/">svn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-svn日常工作流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/svn日常工作流程/" class="article-date">
  <time datetime="2015-12-09T03:42:29.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/svn日常工作流程/">svn日常工作流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The typical work cycle looks like this:</p>
<ol>
<li>Update your working copy.<br>• svn update</li>
<li>Make changes.<br>• svn add<br>• svn delete<br>• svn copy<br>• svn move</li>
<li>Examine your changes.<br>• svn status<br>• svn diff</li>
<li>Possibly undo some changes.<br>• svn revert</li>
<li>Resolve conflicts (merge others’ changes).<br>• svn update<br>• svn resolve</li>
<li>Commit your changes.<br>• svn commit</li>
</ol>
<h1 id="svn_status">svn status</h1><p>To get an overview of your changes before committing, you’ll use the svn status command.  Here are a few examples of the most common status codes that svn status can return. (Note that the text following # is not actually printed by svn status.)<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">? scratch.c         # <span class="keyword">file</span> is not under <span class="keyword">version</span> control</span><br><span class="line">A stuff/loot/bloo.<span class="keyword">h</span> # <span class="keyword">file</span> is scheduled <span class="keyword">for</span> addition</span><br><span class="line">C stuff/loot/lump.c # <span class="keyword">file</span> has textual conflicts from <span class="keyword">an</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">D</span> stuff/fish.c      # <span class="keyword">file</span> is scheduled <span class="keyword">for</span> deletion</span><br><span class="line"><span class="keyword">M</span> bar.c             # the content <span class="keyword">in</span> bar.c has <span class="keyword">local</span> modifications</span><br></pre></td></tr></table></figure></p>
<p>Command <code>svn status</code> does not contact the repository. Instead, they compare the metadata in the .svn directory with the working copy. There is the —show-updates (-u) option, which contacts the repository and adds information about things that are out of date:<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ svn status -<span class="keyword">u</span> -v</span><br><span class="line"><span class="keyword">M</span>      *    44 23 sally README</span><br><span class="line"><span class="keyword">M</span>           44 20 harry bar.c</span><br><span class="line"><span class="comment">       *    44 35 harry stuff/trout.c</span></span><br><span class="line"><span class="keyword">D</span>           44 19 ira   stuff/fish.c</span><br><span class="line">A            0  ?  ?    stuff/things/bloo.<span class="literal">h</span></span><br><span class="line">Status against revision: 46</span><br></pre></td></tr></table></figure></p>
<p><code>svn status</code> also has a —verbose (-v) option, which will show you the status of every item in your working copy, even if it has not been changed. Notice the two asterisks: if you were to run svn update at this point, you would receive changes to README and trout.c. This tells you some very useful information—you’ll need to update and get the server changes on README before you commit, or the repository will reject your commit for being out of date.</p>
<h1 id="svn_revert">svn revert</h1><p>Suppose while viewing the output of svn diff you determine that all the changes you made to a particular file are mistakes. Maybe you shouldn’t have changed the file at all, or perhaps it would be easier to make different changes starting from scratch.Subversion reverts the file to its premodified state by overwriting it with the cached “pristine” copy from the .svn area. But also note that svn revert can undo any scheduled operations<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>svn status <span class="constant">README</span></span><br><span class="line"><span class="variable">$ </span>svn delete <span class="constant">README</span></span><br><span class="line"><span class="constant">D README</span></span><br><span class="line"><span class="variable">$ </span>svn revert <span class="constant">README</span></span><br><span class="line"><span class="constant">Reverted </span><span class="string">'README'</span></span><br><span class="line"><span class="variable">$ </span>svn status <span class="constant">README</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Resolve_Conflicts_(Merging_Others’_Changes)">Resolve Conflicts (Merging Others’ Changes)</h1><p>We’ve already seen how svn status -u can predict conflicts. Suppose you run svn update and some interesting things occur:<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ svn <span class="keyword">update</span></span><br><span class="line"><span class="keyword">U</span> INSTALL</span><br><span class="line"><span class="keyword">G</span> README</span><br><span class="line">Conflict discovered <span class="keyword">in</span> 'bar.c'.</span><br><span class="line">Select: (p) postpone, (df) diff-full, (<span class="keyword">e</span>) <span class="keyword">edit</span>,</span><br><span class="line">(<span class="keyword">h</span>) <span class="keyword">help</span> <span class="keyword">for</span> <span class="keyword">more</span> options:</span><br></pre></td></tr></table></figure></p>
<p>The U and G codes are no cause for concern; those files cleanly absorbed changes from the repository. The files marked with U contained no local changes but were Updated with changes from the repository. The G stands for merGed, which means that the file had local changes to begin with, but the changes coming from the repository didn’t overlap with the local changes. But the next two lines are part of a feature called interactive conflict resolution. This means that the changes from the server overlapped with your own, and you have the opportunity to resolve this conflict. The most commonly used options are displayed, but you can see all of the options by typing h:<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">p</span>) postpone - <span class="keyword">mark</span> the conflict <span class="keyword">to</span> <span class="keyword">be</span> resolved <span class="keyword">later</span></span><br><span class="line">(df) diff-full - show <span class="keyword">all</span> <span class="keyword">changes</span> made <span class="keyword">to</span> merged <span class="keyword">file</span></span><br><span class="line">(<span class="keyword">e</span>) <span class="keyword">edit</span> - <span class="keyword">change</span> merged <span class="keyword">file</span> in <span class="keyword">an</span> editor</span><br><span class="line">(<span class="keyword">r</span>) resolved - accept merged <span class="keyword">version</span> of <span class="keyword">file</span></span><br><span class="line">(mf) mine-full - accept my <span class="keyword">version</span> of entire <span class="keyword">file</span> (ignore their <span class="keyword">changes</span>)</span><br><span class="line">(<span class="keyword">tf</span>) theirs-full - accept their <span class="keyword">version</span> of entire <span class="keyword">file</span> (lose my <span class="keyword">changes</span>)</span><br><span class="line">(<span class="keyword">l</span>) launch - launch external tool <span class="keyword">to</span> <span class="built_in">resolve</span> conflict</span><br><span class="line">(<span class="keyword">h</span>) <span class="keyword">help</span> - show this <span class="keyword">list</span></span><br></pre></td></tr></table></figure></p>
<p>Let’s briefly review each of these options before we go into detail on what each option means.<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">(p)ostpone</span><br><span class="line">    Leave <span class="keyword">the</span> <span class="type">file</span> <span class="keyword">in</span> a conflicted state <span class="keyword">for</span> you <span class="keyword">to</span> resolve <span class="keyword">after</span> your update <span class="keyword">is</span> complete.</span><br><span class="line">(d)iff</span><br><span class="line">    Display <span class="keyword">the</span> differences <span class="keyword">between</span> <span class="keyword">the</span> base revision <span class="keyword">and</span> <span class="keyword">the</span> conflicted <span class="type">file</span> itself <span class="keyword">in</span> unified </span><br><span class="line">    diff format.</span><br><span class="line">(e)dit</span><br><span class="line">    Open <span class="keyword">the</span> <span class="type">file</span> <span class="keyword">in</span> conflict <span class="keyword">with</span> your favorite editor, <span class="keyword">as</span> <span class="keyword">set</span> <span class="keyword">in</span> <span class="keyword">the</span> environment </span><br><span class="line">    variable EDITOR.</span><br><span class="line">(r)esolved</span><br><span class="line">    After editing a <span class="type">file</span>, <span class="keyword">tell</span> svn <span class="keyword">that</span> you've resolved <span class="keyword">the</span> conflicts <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">file</span> <span class="keyword">and</span> <span class="keyword">that</span> </span><br><span class="line">    <span class="keyword">it</span> should accept <span class="keyword">the</span> current <span class="property">contents</span>—basically <span class="keyword">that</span> you've “resolved” <span class="keyword">the</span> conflict.</span><br><span class="line">(m)ine-(f)ull</span><br><span class="line">    Discard <span class="keyword">the</span> newly received changes <span class="keyword">from</span> <span class="keyword">the</span> server <span class="keyword">and</span> use only your <span class="keyword">local</span> changes <span class="keyword">for</span> </span><br><span class="line">    <span class="keyword">the</span> <span class="type">file</span> under review.</span><br><span class="line">(t)heirs-(f)ull</span><br><span class="line">    Discard your <span class="keyword">local</span> changes <span class="keyword">to</span> <span class="keyword">the</span> <span class="type">file</span> under review <span class="keyword">and</span> use only <span class="keyword">the</span> newly received </span><br><span class="line">    changes <span class="keyword">from</span> <span class="keyword">the</span> server.</span><br><span class="line">(l)aunch</span><br><span class="line">    Launch an external program <span class="keyword">to</span> perform <span class="keyword">the</span> conflict resolution. This requires a bit <span class="keyword">of</span> </span><br><span class="line">    preparation beforehand.</span><br><span class="line">(h)elp</span><br><span class="line">    Show <span class="keyword">the</span> <span class="type">list</span> <span class="keyword">of</span> all possible commands you can use <span class="keyword">in</span> interactive conflict resolution.</span><br></pre></td></tr></table></figure></p>
<p>Before deciding how to attack a conflict interactively, odds are that you’d like to see exactly<br>what is in conflict, and the diff command (d) is what you’ll use for this:<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Select: (p) postpone, (df) diff-full, (e) edit,</span><br><span class="line">(h)elp for more options : d</span><br><span class="line"><span class="bullet">--- </span>.svn/text-base/sandwich.txt.svn-base Tue Dec 11 21:33:57 2007</span><br><span class="line"><span class="code">+++</span> .svn/tmp/tempfile.32.tmp Tue Dec 11 21:34:33 2007</span><br><span class="line">@@ -1 +1,5 @@</span><br><span class="line">-Just buy a sandwich.</span><br><span class="line">+&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine</span><br><span class="line"><span class="header">+Go pick up a cheesesteak.</span><br><span class="line">+=======</span></span><br><span class="line">+Bring me a taco!</span><br><span class="line">+&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r32</span><br></pre></td></tr></table></figure></p>
<p>The first line of the diff content shows the previous contents of the working copy (the BASE revision), the next content line is your change, and the last content line is the change that was just received from the server (usually the HEAD revision).</p>
<p>When you <em>postpone</em> a conflict resolution, svn typically does three things to assist you in noticing and resolving that conflict:</p>
<ol>
<li>Subversion prints a C during the update and remembers that the file is in a state of conflict.</li>
<li>If Subversion considers the file to be mergeable, it places conflict markers—special strings of text that delimit the “sides” of the conflict—into the file to visibly demonstrate the overlapping areas. (Subversion uses the svn:mime-type property to decide whether a file is capable of contextual, line-based merging)</li>
<li>For every conflicted file, Subversion places three extra unversioned files in your working copy:</li>
</ol>
<ul>
<li>filename.mine<br>This is your file as it existed in your working copy before you updated your working<br>copy—that is, without conflict markers. This file has only your latest changes in it. </li>
<li>filename.rOLDREV<br>This is the file that was the BASE revision before you updated your working copy. That<br>is, the file that you checked out before you made your latest edits.</li>
<li>filename.rNEWREV<br>This is the file that your Subversion client just received from the server when you updated your working copy. This file corresponds to the HEAD revision of the repository.</li>
</ul>
<p>If you’ve postponed a conflict, you need to resolve the conflict before Subversion will allow you to commit your changes. You’ll do this with the svn resolve command and one of several arguments to the —accept option.</p>
<ul>
<li>If you want to choose the version of the file that you last checked out before making your edits, choose the base argument.</li>
<li>If you want to choose the version that contains only your edits, choose the mine-full argument.</li>
<li>If you want to choose the version that your most recent update pulled from the server, choose the theirs-full argument.</li>
<li>However, if you want to pick and choose from your changes and the changes that your update fetched from the server, merge the conflicted text “by hand” (by examining and editing the conflict markers within the file) and then choose the working argument.</li>
</ul>
<p>svn resolve removes the three temporary files and accepts the version of the file that you specified with the —accept option, and Subversion no longer considers the file to be in a state of conflict:<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">$ svn resolve --accept working sandwich.txt</span><br><span class="line">Resolved conflicted <span class="keyword">state</span> of 'sandwich.txt'</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/09/svn日常工作流程/" data-id="cinvexir0000jtw3a94ye0mzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svn/">svn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-svn基本操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/01/svn基本操作/" class="article-date">
  <time datetime="2015-12-01T06:42:55.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/svn基本操作/">svn基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_help">1. help</h1><p><code>svn help subcommand</code> will describe the syntax, options, and behavior of the subcommand.</p>
<h1 id="2-_import">2. import</h1><p>The <code>svn import</code> command is a quick way to copy an <em>unversioned</em> tree of files into a repository, creating <em>intermediate</em> directories as necessary. You typically use this when you have an existing tree of files that you want to begin tracking in your Subversion repository. 例如，假设svn服务器上存在以下目录<code>https://var/svn/newrepos/</code>，本地机器上存在md5目录，并且md5目录下存在md5.c和md5.h两个文件。现在想把md5这个新的项目导入到svn服务器，使其具有版本管理功能。<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">svn <span class="reserved">import</span> md5 <span class="attribute">https</span>:<span class="regexp">//</span><span class="reserved">var</span>/svn/newrepos/md5 -m <span class="string">'Initial md5'</span></span><br></pre></td></tr></table></figure></p>
<p>Note that after the import is finished, the original tree is not converted into a working copy. To start working, you still need to <code>svn checkout</code> a fresh working copy of the tree.</p>
<h1 id="3-_checkout">3. checkout</h1><p>Most of the time, you will start using a Subversion repository by doing a checkout of your project. Checking out a repository creates a “working copy” of it on your local machine.<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">svn checkout <span class="symbol">https:</span>/<span class="regexp">/var/svn</span><span class="regexp">/newrepos/md</span>5</span><br><span class="line">svn co <span class="symbol">https:</span>/<span class="regexp">/var/svn</span><span class="regexp">/newrepos/md</span>5</span><br></pre></td></tr></table></figure></p>
<p>While you can certainly check out a working copy with the URL of the repository as the only argument, you can also specify a directory after your repository URL. This places your working copy in the new directory that you name.<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">svn co <span class="symbol">https:</span>/<span class="regexp">/var/svn</span><span class="regexp">/newrepos/md</span>5 my_md5</span><br></pre></td></tr></table></figure></p>
<p>That will place your working copy in a directory named my_md5 instead of a directory named md5 as we did previously. The directory my_md5 will be created if it doesn’t already exist.</p>
<h1 id="4-_Authenticating_As_a_Different_User">4. Authenticating As a Different User</h1><p>If you’re working in a shared working copy such as a system configuration directory or a web server document root. In this case,<br>just pass the —username option on the command line, and Subversion will attempt to authenticate as that user, prompting you for a password if necessary.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">svn <span class="built_in">list</span> https:<span class="comment">//var/svn/newrepos/md5 --username xiaoming</span></span><br></pre></td></tr></table></figure></p>
<h1 id="5-_svn_export">5. svn export</h1><p>If you’re building a release and wish to bundle up your files from Subversion but don’t want those pesky .svn directories in the way, you can use svn export to create a local copy of all or part of your repository sans .svn directories.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ svn <span class="keyword">export</span> http:<span class="comment">//svn.example.com/svn/repos1 -r 1729</span></span><br><span class="line"><span class="preprocessor"># Exports revision r1729</span></span><br></pre></td></tr></table></figure></p>
<h1 id="6-_Examining_History">6. Examining History</h1><p>Several commands can provide you with historical data from the repository:</p>
<h2 id="svn_log">svn log</h2><p>Shows you broad information: log messages with date and author information attached to revisions and which paths changed in each revision.  If you wish to see a different range of revisions in a particular order or just a single revision, pass the —revision (-r) option:<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ svn <span class="keyword">log</span> -r 5:19 # shows logs 5 through 19 <span class="keyword">in</span> chronological <span class="keyword">order</span></span><br><span class="line">$ svn <span class="keyword">log</span> -r 19:5 # shows logs 5 through 19 <span class="keyword">in</span> reverse <span class="keyword">order</span></span><br><span class="line">$ svn <span class="keyword">log</span> -r 8 # shows <span class="keyword">log</span> <span class="keyword">for</span> revision 8</span><br></pre></td></tr></table></figure></p>
<p>In verbose mode, svn log will include a list of changed paths in a revision in its output:<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="header">$ svn log -r 8 -v</span><br><span class="line">------------------------------------------------------------------------</span></span><br><span class="line">r8 | sally | 2008-05-21 13:19:25 -0500 (Wed, 21 May 2008) | 1 line</span><br><span class="line">Changed paths:</span><br><span class="line">M /trunk/code/foo.c</span><br><span class="line">M /trunk/code/bar.h</span><br><span class="line">A /trunk/code/doc/README</span><br><span class="line">Frozzled the sub-space winch.</span><br></pre></td></tr></table></figure></p>
<h2 id="svn_diff">svn diff</h2><p>There are three distinct uses of svn diff:</p>
<ul>
<li>Invoking svn diff with no options will compare your working files to the cached “pristine” copies in the .svn area</li>
<li>If a single —revision (-r) number is passed, your working copy is compared to the specified revision in the repository</li>
<li>If two revision numbers, separated by a colon, are passed via —revision (-r), the two revisions are directly compared:<br>svn diff -r 2:3 rules.txt</li>
<li>If a “—change(-c) ARG” is passed, it shows the change made by revision ARG(like -r ARG-1:ARG). If ARG is negative this is<br>like -r ARG:ARG-1</li>
</ul>
<h2 id="svn_cat">svn cat</h2><p>Retrieves a file as it existed in a particular revision number and displays it on your screen</p>
<h2 id="svn_list">svn list</h2><p>Displays the files in a directory for any given revision</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/12/01/svn基本操作/" data-id="cinvexir3000ltw3a1dcaom1o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svn/">svn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CPU点滴" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/20/CPU点滴/" class="article-date">
  <time datetime="2015-11-20T05:44:22.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/20/CPU点滴/">CPU点滴</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_register_memory_architecture">1. register memory architecture</h2><p>One of the operands for ADD operation may be in memory, while the other is in a register. Examples are IBM 360 and Intel x86.</p>
<h2 id="2-_register_plus_memory_architecture">2. register plus memory architecture</h2><p>Both operands for ADD operation may be in memory or in registers, or in combinations. </p>
<h2 id="3-_load/store_architecture">3. load/store architecture</h2><p>Both operands for ADD operation must be in registers. In computer engineering a load/store architecture only allows memory to be accessed by load and store operations, and all values for an operation need to be loaded from memory and be present in registers. Following the operation, the result needs to be stored back to memory. For instance, in a load/store approach both operands for an ADD operation must be in registers. This differs from a register memory architecture in which one of the operands for the ADD operation may be in memory, while the other is in a register. RISC systems such as PowerPC, SPARC, ARM or MIPS use the load/store architecture.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/11/20/CPU点滴/" data-id="cinvexikx0000tw3aavtwry73" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPU访问外部设备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/14/CPU访问外部设备/" class="article-date">
  <time datetime="2015-11-14T12:35:36.000Z" itemprop="datePublished">2015-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/14/CPU访问外部设备/">CPU访问外部设备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>整个计算机由CPU、内存和外部设备组成。当CPU要对内存中的内容进行读写操作时，地址总线负责传输地址，控制总线指明是读取操作还是写入操作，数据总线则用来传输写入内存或从内存读出的信息。而CPU与外部设备的交互，则是通过CPU读写外部设备上的寄存器实现的，外设寄存器也称为“I/O端口”。<br>我们知道，内存中的每个存储单元都有一个地址与其对应，CPU根据这个地址就可以指定自己想要访问的存储单元。那外部设备呢？外部设备中的寄存器也需要有一个地址与之相对应，才能让CPU根据寄存器的地址来区分不同设备之间的寄存器和同一个设备中的不同寄存器。既然，外部设备中的寄存器也需要有一个地址，那么现在的问题是外部设备中的寄存器地址与内存地址的关系是什么呢。<br>1、独立编址(ISOLATED I/O): 也称为“I/O端口”方式，外部设备中的寄存器(I/O端口)地址与内存地址是相互独立、互不影响的，它们分别位于不同的地址空间内。即I/O端口地址位于I/O地址空间内，而内存地址则位于内存地址空间内。不同的地址空间，这个如何理解呢。举个例子，I/O地址空间内存在0xff这样的地址，内存地址空间也可以存在0xff这样的地址，它们两个互不影响。那当地址总线上出现0xff这个地址时，CPU到底是想访问内存还是想访问I/O端口呢，这个是由I/O读控制线、I/O写控制线、内存读控制线、内存写控制线来决定的。如果CPU访问的是I/O端口，那么I/O读控制线或者I/O写控制线被激活；如果CPU访问的是内存，那么内存读控制线或者内存写控制线被激活。所以，采用独立编址方式，对于某个地址（例如0xff）而言，它既可以存在于I/O地址空间内，也可以位于内存地址空间内。在采用独立编址的体系架构下，CPU通过MOV指令来访问内存，而对I/O端口的访问则是通过IN和OUT指令来完成的。IN指令和OUT指令的具体例子如下：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IN</span> <span class="literal">AL</span>, <span class="number">21H</span>  // 从<span class="number">21H</span>端口读取一字节数据到<span class="literal">AL</span>寄存器</span><br><span class="line"><span class="keyword">OUT</span> <span class="number">21H</span>, <span class="literal">AL</span> // 将寄存器<span class="literal">AL</span>的值写入<span class="number">21H</span>端口</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">汇编语言中的数字：</span><br><span class="line">二进制     <span class="number">11111111B</span>     <span class="number">00001111B</span>    // 数字后加B</span><br><span class="line">十进制        <span class="number">255</span>            <span class="number">16</span></span><br><span class="line">十六进制     <span class="number">0FFH</span>            <span class="number">0FH</span>      // 数字后加HS</span><br><span class="line">另外，当十六进制数的第一个字符是字母时，必须在第一个字符之前添加一个<span class="number">0</span> </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>32位处理器的内存地址空间大小是4G，而独立编址的I/O地址空间的大小为64K，即它由65536个8bit的I/O端口组成。I/O端口的编号从 0x0000到0xFFFF，有16位，80x86架构用低16位地址线A0-A15来寻址。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个 32bit的端口。采用独立编址的典型例子是intel 80x86。</p>
<p>2、统一编址(Memory-Mapped I/O)：也称为“I/O内存”方式。外部设备中的寄存器和内存中的存储单元被同等看待，每个I/O端口占用一个内存存储单元的地址，将内存地址的一部分划出来用作IO地址空间。I/O端口占用了内存的地址空间，使内存的存储量容量减小。对于一个32位系统来说，它的4G的地址空间被内存和外部设备中的寄存器共同瓜分。采用统一编址方式，CPU访问外部设备IO端口时，不再需要额外的IN和OUT指令，CPU只需要使用同一套指令就可以访问内存或者IO端口。arm，powerpc在这一类的嵌入式处理器中采用统一编址方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/11/14/CPU访问外部设备/" data-id="cinvexiyz0034tw3a67rj2iwp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux内核list分析三-哈希链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/08/linux内核list分析三-哈希链表/" class="article-date">
  <time datetime="2015-11-08T13:07:29.000Z" itemprop="datePublished">2015-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/08/linux内核list分析三-哈希链表/">linux内核list分析三:哈希链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>linux内核里面的双向循环链表和哈希链表有什么不同呢？1、双向循环链表是循环的，哈希链表不是循环的  2、双向循环链表不区分头结点和数据结点，都用list_head表示，而哈希链表区分头结点(hlist_head)和数据结点(hlist_node)。与哈希链表有关的两个数据结构如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> hlist_head &#123; </span><br><span class="line">    <span class="keyword">struct</span> hlist_node *first;  <span class="comment">//指向每一个hash桶的第一个结点的指针</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> hlist_node &#123; </span><br><span class="line">    <span class="keyword">struct</span> hlist_node *next;   <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> hlist_node **pprev; <span class="comment">//指向上一个结点的next指针的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="1、哈希链表为什么要区分头结点和数据结点？">1、哈希链表为什么要区分头结点和数据结点？</h2><p>头结点和数据结点如果都使用list_head的话，那岂不是更容易实现。内核list.h中描述得很明白：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Double linked lists with a single pointer list head.</span><br><span class="line"> * Mostly useful for hash tables where the two pointer list head is</span><br><span class="line"> * too wasteful.</span><br><span class="line"> * You lose the ability to access the tail in O(1).</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure></p>
<p>意思是说这种双向链表的头结点只有一个指针成员(即struct hlist_node *first)，它主要使用在哈希表中。因为哈希表会有很多表项，每个表项如果使用list_head这样含有两个指针成员的数据结构的话，会造成内存空间的浪费。所以，为了尽可能的减少内存空间的浪费，就要使数据结构变得稍微复杂一些，鱼和熊掌不可兼得啊。</p>
<h2 id="2、hlist_node的pprev成员为什么是struct_hlist_node_**类型的？">2、hlist_node的pprev成员为什么是struct hlist_node **类型的？</h2><p>如果hlist_node的定义是下面这样的话<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> hlist_node &#123; </span><br><span class="line">    <span class="keyword">struct</span> hlist_node *next;</span><br><span class="line">    <span class="keyword">struct</span> hlist_node *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一个数据结点的prev成员应该指向头结点，但是因为prev成员指向的是hlist_node的数据类型的指针，而头结点的数据类型是hlist_head，所以无法实现。为了解决这样的问题，才有了下面的hlist_node的定义<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> hlist_node &#123; </span><br><span class="line">    <span class="keyword">struct</span> hlist_node *next;</span><br><span class="line">    <span class="keyword">struct</span> hlist_node **pprev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/hlist_1.jpg" alt=""><br>在上图中，第一个数据结点的pprev成员(数据类型struct hlist_node **)指向头结点的first成员(数据类型struct hlist_node *)，第二个数据结点的pprev成员(数据类型struct hlist_node **)指向第一个数据结点的next成员(数据类型struct hlist_node *)，从而对于第一个数据结点的操作和非第一个数据结点的操作就没有区别了，都统一起来了。这样就不用对第一个数据结点进行特殊处理了，为编写代码带来了极大的好处，这种设计有点小艺术。</p>
<p>其他的hlist的初始化、插入、删除、遍历请自行参阅list.h源文件，源文件是最好的老师。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/11/08/linux内核list分析三-哈希链表/" data-id="cinvexirs000wtw3aw58zk230" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux内核list分析二-双向循环链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/08/linux内核list分析二-双向循环链表/" class="article-date">
  <time datetime="2015-11-08T09:05:49.000Z" itemprop="datePublished">2015-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/08/linux内核list分析二-双向循环链表/">linux内核list分析二:双向循环链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大学时代，我们就已经学过链表了，例如下面的例子<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> person *prev, *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找指定的person是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">person_exists</span><span class="params">(<span class="keyword">struct</span> person *head, <span class="keyword">struct</span> person in_person)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> person *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = head-&gt;next; p != head; p = p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;height == in_person.height &amp;&amp; p-&gt;weight == in_person.weight)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了struct person这样的链表，通常会实现该链表的插入、删除、查找等操作。现在因为业务需求，又需要struct animal这样的链表，同样，我们也会实现该链表的插入、删除、查找等操作。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> legs;</span><br><span class="line">    <span class="keyword">struct</span> animal *prev, *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找指定的animal是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">animal_exists</span><span class="params">(<span class="keyword">struct</span> animal *head, <span class="keyword">struct</span> animal in_animal)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> animal *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = head-&gt;next; p != head; p = p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;legs == in_animal.legs)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那如果再出现其他的数据类型也需要使用到链表的操作，我们也要为新增的数据类型编写新的链表插入、删除、查找等操作，这样就出现了大量的冗余代码。其实，查找person与anmial是否存在的代码处理逻辑都是一样的，只是数据类型不一样而已。所以为了解决这个问题，linux内核中把与链表有关的操作抽象出来，其他需要使用链表操作的数据类型只要使用内核定义的链表就OK，无需自己再开发与链表的基本操作相关的代码。</p>
<p>linux内核双向循环链表仅仅使用了一个数据结构struct list_head，即链表的头结点和数据结点都是使用struct list_head表示<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> list_head&#123; </span><br><span class="line">    <span class="keyword">struct</span> list_head *next, *prev; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>让我们看看使用了struct list_head的struct animal是怎样的。下面代码中的INIT_LIST_HEAD、list_add、list_for_each_entry都是linux内核实现的。它的具体实现可以参考include/linux/list.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> legs;</span><br><span class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化链表头结点</span></span><br><span class="line"><span class="keyword">struct</span> list_head animal_list;</span><br><span class="line">INIT_LIST_HEAD(&amp;animal_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化struct animal</span></span><br><span class="line"><span class="keyword">struct</span> animal animal1;</span><br><span class="line">animal1.legs = <span class="number">4</span>;</span><br><span class="line">INIT_LIST_HEAD(&amp;animal1.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将animal1加入链表</span></span><br><span class="line">list_add(&amp;animal1, &amp;animal_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入其它animal到链表</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 animal_list</span></span><br><span class="line"><span class="keyword">struct</span> animal *p_animal;</span><br><span class="line">list_for_each_entry(p_animal, &amp;animal_list, <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"legs = %d\n"</span>, p_animal-&gt;legs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的内存布局如下：<br><img src="/img/list_head_1.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/11/08/linux内核list分析二-双向循环链表/" data-id="cinvexirr000vtw3a8hew8a5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux内核list分析一-前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/07/linux内核list分析一-前言/" class="article-date">
  <time datetime="2015-11-07T07:32:36.000Z" itemprop="datePublished">2015-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/07/linux内核list分析一-前言/">linux内核list分析一:前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>链表list是linux内核最经典的数据结构之一，不过在深入学习链表的实现之前，需要了解几个知识：offsetof、typeof、container_of</p>
<h2 id="1、offsetof">1、offsetof</h2><p>offsetof的作用是返回结构体中的某个成员在该结构体中的偏移量，请看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>, offsetof(<span class="keyword">struct</span> person, height));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>, offsetof(<span class="keyword">struct</span> person, weight));  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>而offsetof的真实面目是<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure></p>
<p>这里巧妙的利用了0地址。也许有人会产生疑问，怎么可能会对0地址进行操作呢？为了更容易理解，下面都使用struct person为例。其实，0是一个具体的常量值，它是一个地址，而(struct person *)0则是一个指针，而且是一个指针常量（即指针本身是常量，但它指向的地址里的内容可以改变）。只要我们不去对一个空指针进行读写，就不会存在非法访问内存的问题，例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  读取操作</span></span><br><span class="line">    <span class="keyword">struct</span> person *xiao_hua = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> person tmp = *xiao_hua; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  写入操作</span></span><br><span class="line">    <span class="keyword">struct</span> person *xiao_hua = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> person tmp = &#123;<span class="number">180</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    *xiaohua = tmp;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<p>那么，其他的操作都是OK的。</p>
<p>offsetof(struct person, weight) 经过宏替换后变为 ((size_t) &amp;((struct person <em>)0)-&gt;weight)<br>1、(struct person </em>)0 表示 一个指向struct person结构的指针，虽然这个struct person结构不存在，但只要不去对它进行读写就OK<br>2、(struct person <em>)0)-&gt;weight 表示 1中的指针所指向的那个struct person结构的weight成员<br>3、&amp;((struct person </em>)0)-&gt;weight 表示 1中的指针所指向的那个struct person结构的weight成员的地址<br>4、weight成员的地址 减去 它所在的struct person结构的地址，就可以得出weight在struct person结构中的偏移量，但是此时，struct person结构的地址为0，所以weight成员的地址就是weight在struct person结构中的偏移量</p>
<h2 id="2、typeof">2、typeof</h2><p>typeof关键字是C语言中的一个新扩展，这个特性在linux内核中应用非常广泛。<br>typeof的参数可以是两种形式：表达式或类型。</p>
<p>(1) 表达式的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  以下示例声明了int类型的var变量，因为表达式foo()是int类型的。由于表达式不会被执行，所以不会调用foo函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    typeof(foo()) var; <span class="comment">// 等价于 int var;</span></span><br></pre></td></tr></table></figure></p>
<p>(2) 类型的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typeof(<span class="keyword">int</span> *) a,b; <span class="comment">// 等价于 int *a,*b;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3、container_of">3、container_of</h2><p>它的作用是根据一个结构体变量中的一个域成员变量的指针来获取指向整个结构体变量的指针。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                      \</span><br><span class="line">        const typeof ( ((type *)0)-&gt;member ) *__mptr = (ptr);   \</span><br><span class="line">        (type *)( ( char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> person xiao_hua = &#123;<span class="number">180</span>, <span class="number">60</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> person *p_xiao_hua = container_of(&amp;xiao_hua.weight, <span class="keyword">struct</span> person, weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p_xiao_hua-&gt;height);  <span class="comment">// 180</span></span><br></pre></td></tr></table></figure></p>
<p>container_of(&amp;xiao_hua.weight, struct person, weight) 宏替换后的结果为<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">typeof</span> <span class="params">( ((<span class="keyword">struct</span> person *)</span>0)-&gt;weight ) *__mptr </span>= (&amp;xiao_hua.weight);</span><br><span class="line">(<span class="keyword">struct</span> person *)( ( <span class="keyword">char</span> *)__mptr - offsetof(<span class="keyword">struct</span> person,weight) );&#125;)</span><br></pre></td></tr></table></figure></p>
<p>第一个语句中的‘typeof ( ((struct person <em>)0)-&gt;weight )’ 其实就是 ‘int’，所以第一个语句就是’const int </em>__mptr = (&amp;xiao_hua.weightr)’<br>第二个语句将weight的地址减去weight在struct person中的偏移量就得到了struct person结构变量的地址。</p>
<p>这里使用了一个中间变量__mptr，也许我们会质疑，它是多余的。但是，请看下面的情况<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                      \</span><br><span class="line">        (type *)( ( char *)ptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> person xiao_hua = &#123;<span class="number">180</span>, <span class="number">60</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> person *p_xiao_hua = container_of(&amp;xiao_hua, <span class="keyword">struct</span> person, weight); <span class="comment">// 错误使用container_of</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p_xiao_hua-&gt;height);</span><br></pre></td></tr></table></figure></p>
<p>所以中间变量__mptr这里起到了提醒开发者的功能。如果开发者传入的ptr指针指向的类型，与结构体中成员的类型不符，编译器在这里会打印一条warning，提示开发者可能存在的错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/11/07/linux内核list分析一-前言/" data-id="cinvexiru000xtw3a815x48l2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hexo和github-pages搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/08/hexo和github-pages搭建个人博客/" class="article-date">
  <time datetime="2015-08-08T02:05:30.000Z" itemprop="datePublished">2015-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/08/hexo和github-pages搭建个人博客/">hexo和github pages搭建个人博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>搭建个人博客需要用到两个软件git和node.js，所以请先安装完成这两个软件。本教程仅适用于windows平台。</p>
<h2 id="一、_github的配置">一、 github的配置</h2><p>我们在本地写完博客以后，会提交到github上。github提供了两种认证方式：用户名密码和ssh。如果使用用户名和密码的认证方式，那么我们每次提交到github的时候都会要求我们输入用户名和密码，这种方式用户体验不好。所以，我们使用ssh认证方式，即在本地生成一对私钥和公钥，然后把公钥添加到自己在github的账号信息里，这样提交博客到github上时会自动完成认证过程。</p>
<h2 id="1-1_检查ssh密钥是否已经存在">1.1 检查ssh密钥是否已经存在</h2><p>首先，我们需要检查自己的机器上是否已经存在ssh密钥，打开git bash并输入以下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br><span class="line"><span class="comment"># Lists the files in your .ssh directory, if they exist</span></span><br></pre></td></tr></table></figure></p>
<p>如果存在 id_rsa.pub 和 id_rsa这两个文件，说明之前已经生成过ssh密钥，请忽略步骤1.2</p>
<h2 id="1-2_生成ssh密钥">1.2 生成ssh密钥</h2><p>打开git bash，执行以下命令，别忘了将邮箱地址替换成自己在github上的邮箱地址。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br><span class="line"><span class="comment"># Creates a new ssh key, using the provided email as a label</span></span><br><span class="line">Generating public/private rsa key pair.</span><br></pre></td></tr></table></figure></p>
<p>让密钥文件保存在默认位置，直接按回车键即可。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure></p>
<p>输入一个使用密钥文件时需要输入的密码（不然每个人都可以随便使用此密钥文件来访问你的github）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure></p>
<p>输入密码之后，界面会输出成功生成密钥的信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line"><span class="number">01</span>:<span class="number">0</span>f:f4:<span class="number">3</span>b:ca:<span class="number">85</span>:d6:<span class="number">17</span>:a1:<span class="number">7</span>d:f0:<span class="number">68</span>:<span class="number">9</span>d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3_把公钥添加到自己的github账号">1.3 把公钥添加到自己的github账号</h2><p>打开公钥文件/Users/you/.ssh/id_rsa.pub，复制一下里面的全部内容。需要注意的一点是，复制公钥的时候不能多了换行符或者空格，否则添加公钥时会失败。然后，参见github的<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">添加ssh密钥的官方文档</a>的“Step 4: Add your SSH key to your account”章节，将自己的公钥添加到github账号。</p>
<h2 id="1-4_测试是否能ssh连接到github">1.4 测试是否能ssh连接到github</h2><p>打开git bash，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># Attempts to ssh to GitHub</span></span><br></pre></td></tr></table></figure></p>
<p>你会看到以下信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">'github.com (207.97.227.239)'</span> can<span class="string">'t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure></p>
<p>输入yes，看到以下信息说明ssh配置成功<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、_github_pages的配置">二、 github pages的配置</h2><p>首先，github是一个具有版本管理功能的代码仓库，我们可以在上面建立多个项目。每一个项目会有自己的一个默认主页，主页内只会列出项目的源文件。这对于一个新手来说，不知从何入手。人们需要有一个对这个项目的具体介绍的主页，以帮助第一次接触这个项目的人对此项目有一个大概的了解。所以我们应该自定义项目的主页，来代替原本只是列出项目源文件的主页。github pages就是完成这样的功能的。github pages能够建立两种类型的网站，第一种是为每一个github用户或者组织建立的网站，用来介绍该用户或组织，这种网站每个用户或者组织只能建立一个；第二种是为用户或者组织的github上的项目建立的网站，用来介绍项目的情况，这种网站每个用户或者组织能建立多个。我们搭建个人博客需要建立的网站是第一种网站，所以需要在github上新建一个项目，这个项目的名字有特殊的要求，即项目的名字必须符合“username.github.io”这种格式，其中username是自己在github上的账户名称。</p>
<h2 id="三、_git的配置">三、 git的配置</h2><p>Git会根据用户的名字和邮箱来记录提交，GitHub也是用这些信息来做权限的处理。所在在使用git向github提交文件之前，需要先在git中设置自己的github用户名和邮箱。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name  <span class="string">"github_user_name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your_email@youremail.com"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="四、_hexo的配置">四、 hexo的配置</h2><p>hexo是一款基于node.js的静态博客框架。</p>
<h2 id="4-1_安装hexo">4.1 安装hexo</h2><p>打开git bash，执行以下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<h2 id="4-2_新建并初始化博客项目blog">4.2 新建并初始化博客项目blog</h2><p>打开git bash，执行以下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<h2 id="4-3_在本地浏览博客界面">4.3 在本地浏览博客界面</h2><p>打开git bash，执行以下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>然后，打开浏览器，输入网址<code>http://127.0.0.1:4000/</code>，看到如下图所示的经典的“hello world”，说明配置成功。我们看到的“hello world”文章是hexo为我们发出的第一篇博客。<br><img src="/img/hello_world.PNG" alt=""></p>
<h2 id="五、_利用hexo写一篇博客并发布到github">五、 利用hexo写一篇博客并发布到github</h2><h2 id="5-1_新建一篇博客">5.1 新建一篇博客</h2><p>在git bash中将当前目录切换到上一步骤中的blog目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">'your_first_blog_title'</span></span><br></pre></td></tr></table></figure></p>
<p>这时，会生成blog/source/_posts/your_first_blog_title.md文件</p>
<h2 id="5-2_编辑博客">5.2 编辑博客</h2><p>用自己喜欢的编辑工具打开your_first_blog_title.md文件，利用markdown语法来编辑博客，保存。</p>
<h2 id="5-3_修改项目配置文件">5.3 修改项目配置文件</h2><p>打开blog/_config.yml，修改以下内容<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## <span class="string">Docs:</span> <span class="string">http:</span><span class="comment">//hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="string">deploy:</span></span><br><span class="line"><span class="label">  type:</span> git</span><br><span class="line"><span class="label">  repo:</span> git<span class="annotation">@github</span>.<span class="string">com:</span>user_name/user_name.github.io.git</span><br><span class="line"><span class="label">  branch:</span> master</span><br></pre></td></tr></table></figure></p>
<h2 id="5-4_生成静态网站">5.4 生成静态网站</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<h2 id="5-5_发布到github">5.5 发布到github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<h2 id="5-6_欣赏">5.6 欣赏</h2><p>在浏览器中输入网址<code>https://user_name.github.io</code>，欣赏一下自己刚刚发布的博客吧！</p>
<h2 id="六、_ssh-agent的配置">六、 ssh-agent的配置</h2><p>在上一步骤中提交文件到github的时候，会让我们输入访问密钥证书的密码。每次都要这样，怎么破呢？ssh-agent可以帮助我们解决这个问题。我们需要在打开git bash的时候自动运行ssh-agent，所以需要把下面的shell代码复制到~/.profile或者~/.bashrc文件中。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">Note</span>: ~/.ssh/environment should not be used, as it</span></span><br><span class="line"><span class="comment">#       already has a different purpose in SSH.</span></span><br><span class="line"></span><br><span class="line">env=~/.ssh/agent.env</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">Note</span>: Don't bother checking SSH_AGENT_PID. It's not used</span></span><br><span class="line"><span class="comment">#       by SSH itself, and it might even be incorrect</span></span><br><span class="line"><span class="comment">#       (for example, when using agent-forwarding over SSH).</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">agent_is_running</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SSH_AUTH_SOCK</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># ssh-add returns:</span></span><br><span class="line">        <span class="comment">#   0 = agent running, has keys</span></span><br><span class="line">        <span class="comment">#   1 = agent running, no keys</span></span><br><span class="line">        <span class="comment">#   2 = agent not running</span></span><br><span class="line">        ssh-add <span class="operator">-l</span> &gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span> || [ $? <span class="operator">-eq</span> <span class="number">1</span> ]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">agent_has_keys</span></span>() &#123;</span><br><span class="line">    ssh-add <span class="operator">-l</span> &gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">agent_load_env</span></span>() &#123;</span><br><span class="line">    . <span class="string">"<span class="variable">$env</span>"</span> &gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">agent_start</span></span>() &#123;</span><br><span class="line">    (<span class="built_in">umask</span> <span class="number">077</span>; ssh-agent &gt;<span class="string">"<span class="variable">$env</span>"</span>)</span><br><span class="line">    . <span class="string">"<span class="variable">$env</span>"</span> &gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! agent_is_running; <span class="keyword">then</span></span><br><span class="line">    agent_load_env</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if your keys are not stored in ~/.ssh/id_rsa or ~/.ssh/id_dsa, you'll need</span></span><br><span class="line"><span class="comment"># to paste the proper path after ssh-add</span></span><br><span class="line"><span class="keyword">if</span> ! agent_is_running; <span class="keyword">then</span></span><br><span class="line">    agent_start</span><br><span class="line">    ssh-add</span><br><span class="line"><span class="keyword">elif</span> ! agent_has_keys; <span class="keyword">then</span></span><br><span class="line">    ssh-add</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> env</span><br></pre></td></tr></table></figure></p>
<p>保存文件后，在第一次打开git bash的时候，会提示我们输入访问ssh密钥的密码，我们输入正确的密码之后，以后再提交博客到github的时候就是完全自动化的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/08/08/hexo和github-pages搭建个人博客/" data-id="cinvexirw000ytw3a6ryrlqm8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/05/hello-world/" class="article-date">
  <time datetime="2015-07-05T07:48:53.427Z" itemprop="datePublished">2015-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/07/05/hello-world/" data-id="cinvexirx000ztw3ai8cnbybg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ctags" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/05/ctags/" class="article-date">
  <time datetime="2015-07-05T07:13:46.000Z" itemprop="datePublished">2015-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/05/ctags/">ctags</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Ability">Ability</h2><p>ctags可以使我们在函数调用和函数定义之间来回跳转，方便阅读源代。The ability to jump from the current source file to definitions of functions and structures in other files. A tag is an identifier that appears in a “tags” file.  It is a sort of label that can be jumped to.  For example: In C programs each function name can be used as a tag.  The “tags” file has to be generated by a program like ctags, before the tag commands can be used.</p>
<h2 id="原理">原理</h2><p>ctags分析源代码中的函数、变量、宏定义等信息，将这些tag的名字和它们所在的文件，以及如何通过命令跳转到这些tag等信息保存到名为tags的文件中。</p>
<h2 id="用法">用法</h2><ol>
<li><p><code>ctags -R *</code><br> 要想使用ctags带来的在函数调用和函数定义之间来回跳转的功能，首先要生成名为tags的文件。在<strong>shell</strong>环境中切换到源代码根目录，输入命令<code>ctags -R *</code>，即可在源代码根目录下生成tags文件。</p>
</li>
<li><p><code>vim -t &lt;tag&gt;</code><br> To search for a specific tag and open Vim to its definition, run the above command in your shell.</p>
</li>
<li><p>Open any source file in Vim and use the following basic commands:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Keyboard command</th>
<th>Action </th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl-]</td>
<td>Jump to the tag underneath the cursor</td>
</tr>
<tr>
<td>Ctrl-t</td>
<td>Jump back up in the tag stack</td>
</tr>
<tr>
<td><code>:tag &lt;tag&gt;</code></td>
<td>Position the cursor on the tag</td>
</tr>
<tr>
<td><code>:ts &lt;tag&gt;</code></td>
<td>Search for a particular tag</td>
</tr>
<tr>
<td>:tags</td>
<td>Show where you are in the tag stack</td>
</tr>
<tr>
<td>:tn</td>
<td>Go to the next definition for the last tag</td>
</tr>
<tr>
<td>:tp</td>
<td>Go to the previous definition for the last tag</td>
</tr>
</tbody>
</table>
<h2 id="注意">注意</h2><p>运行vim的时候，必须在tags文件所在的目录下运行，因为vim启动时会在当前目录内寻找tags文件并加载它。否则，运行vim的时候还要用<code>:set tags=</code>命令设定tags文件的路径，这样vim才能找到tags文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhouzijiang.github.io/2015/07/05/ctags/" data-id="cinvexis10013tw3a4xhup3s5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-基础/">c++基础</a><span class="tag-list-count">28</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/">gdb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux点滴/">linux点滴</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/svn/">svn</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/TCP/" style="font-size: 18px;">TCP</a> <a href="/tags/c/" style="font-size: 12px;">c++</a> <a href="/tags/c-基础/" style="font-size: 20px;">c++基础</a> <a href="/tags/gdb/" style="font-size: 10px;">gdb</a> <a href="/tags/linux/" style="font-size: 16px;">linux</a> <a href="/tags/linux点滴/" style="font-size: 14px;">linux点滴</a> <a href="/tags/svn/" style="font-size: 16px;">svn</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/23/gdb-1-启动和退出/">gdb(1):启动和退出</a>
          </li>
        
          <li>
            <a href="/2016/03/29/最让人头疼的歧义most-vexing-parse/">最让人头疼的歧义most vexing parse</a>
          </li>
        
          <li>
            <a href="/2016/03/29/不可复制noncopyable/">不可复制noncopyable</a>
          </li>
        
          <li>
            <a href="/2016/03/26/线程同步之条件变量/">线程同步之条件变量</a>
          </li>
        
          <li>
            <a href="/2016/03/21/c-primer笔记27-Pointer-to-Class-Member/">c++ primer笔记27: Pointer to Class Member</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 zhouzijiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>